<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.26 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc strict="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-tschofenig-core-coap-tcp-tls-05.txt" category="std">

  <front>
    <title abbrev="TCP/TLS Transport for CoAP">A TCP and TLS Transport for the Constrained Application Protocol (CoAP)</title>

    <author initials="C." surname="Bormann" fullname="Carsten Bormann" role="editor">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>
    <author initials="S." surname="Lemay" fullname="Simon Lemay">
      <organization>Zebra Technologies</organization>
      <address>
        <postal>
          <street>820 W. Jackson Blvd.suite 700</street>
          <city>Chicago</city>
          <code>60607</code>
          <country>United States of America</country>
        </postal>
        <phone>+1-847-634-6700</phone>
        <email>slemay@zebra.com</email>
      </address>
    </author>
    <author initials="V." surname="Solorzano Barboza" fullname="Valik Solorzano Barboza">
      <organization>Zebra Technologies</organization>
      <address>
        <postal>
          <street>820 W. Jackson Blvd. suite 700</street>
          <city>Chicago</city>
          <code>60607</code>
          <country>United States of America</country>
        </postal>
        <phone>+1-847-634-6700</phone>
        <email>vsolorzanobarboza@zebra.com</email>
      </address>
    </author>
    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>ARM Ltd.</organization>
      <address>
        <postal>
          <street>110 Fulbourn Rd</street>
          <city>Cambridge</city>
          <code>CB1 9NJ</code>
          <country>Great Britain</country>
        </postal>
        <email>Hannes.tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>

    <date year="2015" month="June" day="10"/>

    <area>Applications Area (app)</area>
    <workgroup>CORE</workgroup>
    

    <abstract>


<t>The Hypertext Transfer Protocol (HTTP) was designed with TCP as the underlying 
  transport protocol.  The Constrained Application Protocol (CoAP), while 
  inspired by HTTP, has been defined to make use of UDP instead of TCP.  Therefore, 
  reliable delivery and a simple congestion control and flow control mechanism 
  are provided by the message layer of the CoAP protocol.</t>

<t>A number of environments benefit from the use of CoAP directly over a reliable 
  byte stream like TCP that already provides these services.  This document 
  defines the use of CoAP over TCP as well as CoAP over TLS.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The <xref target="RFC7252">Constrained Application Protocol (CoAP)</xref> was designed
for Internet of Things (IoT) deployments, assuming that UDP can be
used freely – UDP <xref target="RFC0768"/>, or DTLS <xref target="RFC6347"/> over UDP, is a good choice for
transferring small amounts of data in networks that follow the IP
architecture.
Some CoAP deployments, however, may have to integrate well with
existing enterprise infrastructure, where the use of UDP-based
protocols may not be well-received or may even be blocked by firewalls.
Middleboxes that are unaware of CoAP usage for IoT can make the use of UDP
brittle.</t>

<t>Where NATs are still present,
CoAP over TCP can also help with their traversal. NATs often calculate
expiration timers
based on the transport layer protocol being used by application protocols.
Many NATs are built around the assumption that a transport layer protocol such as
TCP gives them additional information about the session life cycle
and keep TCP-based NAT bindings around for a longer period. UDP on the other hand
does not provide such information to a NAT and timeouts tend to be
much shorter, as research confirms <xref target="HomeGateway"/>.</t>

<t>Some environments may also benefit from the more sophisticated congestion
control capabilities provided by many TCP implementations.
(Note that there is ongoing work to add more elaborate congestion control
to CoAP as well, see <xref target="I-D.bormann-core-cocoa"/>.)</t>

<t>Finally, CoAP may be integrated into a Web environment where the front-end
uses CoAP from IoT devices to a cloud infrastructure but the CoAP messages
are then transported in TCP between the back-end services.
A TCP-to-UDP gateway can be
used at the cloud boundary to talk to the UDP-based IoT.</t>

<t>To make both IoT devices work smoothly in these demanding environments, CoAP
needs
to make use of a different transport protocol, namely TCP <xref target="RFC0793"/> and in some situations even TLS <xref target="RFC5246"/>.</t>

<t>The present document
describes a shim header that conveys length information about
each CoAP message included.  Modifications to CoAP beyond the replacement
of the message layer
(e.g., to introduce further optimizations) are intentionally avoided.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and
“OPTIONAL” in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>
<section anchor="constrained-application-protocol" title="Constrained Application Protocol">

<t>The interaction model of CoAP over TCP is very similar to the one for
CoAP over UDP with the key difference that TCP voids the need to
provide certain transport layer protocol features, such as reliable
delivery, fragmentation and reassembly, as well as congestion control,
at the CoAP level. The protocol stack is illustrated in <xref target="stack"/> (derived
from <xref target="RFC7252"/>, Figure 1).</t>

<figure title="The CoAP over TLS/TCP Protocol Stack" anchor="stack"><artwork><![CDATA[
        +----------------------+
        |      Application     |
        +----------------------+
        +----------------------+
        |  Requests/Responses  |  CoAP (RFC7252)
        |----------------------|
        |    Message adapter   |  This Document
        +----------------------+
        +-----------+    ^
        |    TLS    |    |
        +-----------+    v
        +----------------------+
        |          TCP         |
        +----------------------+
]]></artwork></figure>

<t>Since TCP offers reliable delivery, there is no need to offer a redundant
acknowledgement at the CoAP messaging layer.</t>

<t>Hence, the only message type allowed when transporting data with CoAP over TCP is
the Non-Confirmable message (NON).  By nature of TCP, a NON over TCP is still
transmitted
reliably. <xref target="NON"/> (derived from <xref target="RFC7252"/>, Figure 3) shows this
message exchange graphically.  A UDP-to-TCP gateway will therefore discard
all
empty messages, such as empty ACKs (after operating on them at the
message layer), and re-pack the contents of all non-empty CON, NON, or
ACK messages (i.e., those ACK messages that have a piggy-backed
response) into NON messages.</t>

<t>Similarly, there is no need to detect duplicate delivery of a message.
In UDP CoAP, the Message ID is used for relating acknowledgements to
Confirmable messages as well as for duplicate detection.
Since the Message ID thus is not meaningful over TCP, it is elided (as indicated
by the
dashes in <xref target="NON"/>).</t>

<figure title="NON Message Transmission over TCP." anchor="NON"><artwork><![CDATA[
        Client              Server
           |                  |
           |   NON [------]   |
           +----------------->|
           |                  |
]]></artwork></figure>

<t>As a result of removing the message layer in CoAP over TCP, there is
no longer a need to distinguish message types.  Since the two-bit
field for the message shall not be empty, all messages
are marked with the bit combination indicating the NON type (no
message layer acknowledgement is expected or even possible). A
response is sent back as defined
in <xref target="RFC7252"/>, as
illustrated in <xref target="NON2"/> (derived from <xref target="RFC7252"/>, Figure 6).</t>

<figure title="NON Request/Response." anchor="NON2"><artwork><![CDATA[
        Client              Server
           |                  |
           |   NON [------]   |
           | GET /temperature |
           |   (Token 0x74)   |
           +----------------->|
           |                  |
           |   NON [------]   |
           |   2.05 Content   |
           |   (Token 0x74)   |
           |     "22.5 C"     |
           |<-----------------+
           |                  |
]]></artwork></figure>

</section>
<section anchor="message-format" title="Message Format">

<t>The CoAP message format defined in <xref target="RFC7252"/>, as shown in <xref target="CoAP-Header"/>, relies on the datagram transport (UDP, or DTLS over
UDP) for keeping the individual messages separate.</t>

<figure title="RFC 7252 defined CoAP Message Format." anchor="CoAP-Header"><artwork><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver| T |  TKL  |      Code     |          Message ID           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Token (if any, TKL bytes) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Options (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1|    Payload (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>In a stream oriented transport protocol such as TCP, a form of messages delimitation is needed.  For this purpose, CoAP over TCP
introduces a length field. <xref target="Shim"/> shows a 1-byte shim header
carrying length information prepending the CoAP message header.</t>

<figure title="CoAP Header with prepended Shim Header." anchor="Shim"><artwork><![CDATA[
     0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Length Shim  |Ver| T |  TKL  |      Code     |   Token (TKL
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   bytes) ...  |  Options (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1|    Payload (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>— Alternative L1 —</t>

<t>The ‘Message Length’ field is a 16-bit unsigned integer in network
byte order.</t>

<t>— Alternative L2 —</t>

<t>The ‘Message Length’ field starts with an 8-bit unsigned
integer. Length encoding follows the same mechanism as “Major type 0”
from the CBOR specification <xref target="RFC7049"/>.
The length field is indicated by the 5 least significant bits of the byte.
Values are used as such:</t>

<t><list style="symbols">
  <t>between 0b000_00001 and 0b000_10111 (1 to 23) indicates the actual length
of the following message</t>
  <t>0b000_11000 (24) means an additional 8-bit unsigned Integer is appended
to the initial length field indicating the total length</t>
  <t>0b000_11001 (25) means an additional 16-bit unsigned Integer (in
network byte order) is appended
to the initial length field indicating the total length</t>
  <t>0b000_11010 (26) means an additional 32-bit unsigned Integer (in
network byte order) is appended
to the initial length field indicating the total length</t>
</list></t>

<t>The 3 most significant bits in the initial length field are reserved for
future use.
If a recipient gets a message larger than it can handle, it SHOULD if possible
send back a 4.13 in accordance with <xref target="RFC7252"/> section on error
code.</t>

<t>— Common for L1 and L2 Alternatives —</t>

<t>The “length” field provides the length of the subsequent CoAP message
(including the CoAP header but excluding this message length field) in
bytes.  T is always the code for NON (1).</t>

<t>— Alternative L3 —</t>

<t>The initial byte of the frame contains two nibbles, in a similar way to the
CoAP option encoding (Section 3.1 of <xref target="RFC7252"/>).  The first nibble is used to indicate the length
of the options (including any option delimiter), and the payload (if
any); it does not include the Code byte or the Token bytes.  The first
nibble is interpreted as a 4-bit unsigned integer.  A value between 0
and 12 directly indicates the length of the options/payload, in bytes.
The other three values have a special meaning:</t>

<t><list style="hanging">
  <t hangText='13:'>
  An 8-bit unsigned integer follows the initial byte and indicates the
length of options/payload minus 13.</t>
  <t hangText='14:'>
  A 16-bit unsigned integer in network byte order follows the initial
byte and indicates the length of options/payload minus 269.</t>
  <t hangText='15:'>
  A 32-bit unsigned integer in network byte order follows the initial
byte and indicates the length of options/payload minus 65805.</t>
</list></t>

<t>The second nibble of the initial byte indicates the token length.</t>

<t>Example: 01 43 7f is a frame just containing a 2.03 code with the
token 7f.</t>

<figure title="CoAP Header with prepended Shim Header (L3)." anchor="ShimL3"><artwork><![CDATA[
     0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Len  |  TKL  | Len+ bytes... |      Code     | TKL bytes ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Options (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1|    Payload (if any) ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>— End L Alternatives</t>

<t>The Message ID is meaningless and thus elided.  The semantics of the
other CoAP header fields is left unchanged.</t>

<section anchor="discussion" title="Discussion">

<t>One might wish that,
when CoAP is used over TLS, then the TLS record layer length field
could be used in place of the shim header length.  Each CoAP message would
be transported in a
separate TLS record layer message, making the shim header that includes the
length information redundant.</t>

<t>However,
RFC 5246 says that “Client
message boundaries are not preserved in the record layer (i.e.,
multiple client messages of the same ContentType MAY be coalesced
into a single TLSPlaintext record, or a single message MAY be
fragmented across several records).” While the Record Layer provides
length information about the encapsulated application data and handshaking payloads,
TLS implementations typically do not support an API interface that would
provide access to
the record layer delimiting information.
An additional problem with this approach is that this approach would remove
the
potential optimization of packing several CoAP messages into one
record layer message, which is normally a way to amortize the record layer
and MAC overhead
over all these messages.</t>

<t>In summary, we are not pursuing this idea for an optimization.</t>

<t>One other observation is that the message size limitations defined in
Section 4.6 of <xref target="RFC7252"/> are no longer strictly necessary.
Consenting [how?] implementations may want to interchange messages
with payload sizes than 1024 bytes, potentially also obviating the
need for the Block protocol <xref target="I-D.ietf-core-block"/>.  It must be noted that
entirely getting rid of the block protocol is
not a generally applicable solution, as:</t>

<t><list style="symbols">
  <t>a UDP-to-TCP gateway may simply not have the context to convert a
message with a Block option into the equivalent exchange without any
use of a Block option.</t>
  <t>large messages might also cause undesired head-of-line blocking.</t>
</list></t>

<t>The general assumption is therefore that the block protocol will
continue to be used over TCP, even if applications occasionally do
exchange messages with payload sizes larger than desirable in UDP.</t>

</section>
</section>
<section anchor="message-transmission" title="Message Transmission">

<t>As CoAP exchanges messages asynchronously over the TCP connection, the
client can send multiple requests without waiting for responses.  For
this reason, and due to the nature of TCP, responses are returned
during the same TCP connection as the request.  In the event that the
connection gets terminated, all requests that have not elicited a
response yet shall be canceled; clients may transmit the request
again once a connection is reestablished.</t>

<t>Furthermore, since TCP is bidirectional, requests can be sent from
both the connecting host or the endpoint that accepted the connection.
In other words, who initiated the TCP connection has no bearing on the
meaning of the CoAP terms client and server, which are relating only
to an individual request and response pair.</t>

</section>
<section anchor="URI" title="CoAP URI">

<t>CoAP <xref target="RFC7252"/> defines the “coap” and “coaps” URI schemes for
identifying CoAP resources and providing a means of locating the
resource. RFC 7252 defines these resources for use with CoAP over UDP.</t>

<t>The present specification introduces two new URI schemes, namely “coap+tcp”
and “coaps+tcp”.  The rules from Section 6 of <xref target="RFC7252"/> apply to
these two new URI schemes.</t>

<t><xref target="RFC7252"/>, Section 8 (Multicast CoAP), does not apply to the URI
schemes defined in the present specification.</t>

<t>Resources made available via one of the “coap+tcp” or “coaps+tcp” schemes
have no shared identity with the other scheme or with the “coap” or
“coaps” scheme, even if their resource identifiers indicate the
same authority (the same host listening to the same port).
The schemes constitute distinct namespaces and, in combination with
the authority, are considered to be distinct
origin servers.</t>

<section anchor="coaptcp-uri-scheme" title="coap+tcp URI scheme">

<figure><artwork><![CDATA[
coap-tcp-URI = "coap+tcp:" "//" host [ ":" port ] path-abempty
               [ "?" query ]
]]></artwork></figure>

<t>The semantics defined in <xref target="RFC7252"/>, Section 6.1, applies to this
URI scheme, with the following changes:</t>

<t><list style="symbols">
  <t>The port subcomponent indicates the TCP port
at which the CoAP server is located.  (If it is empty or not given,
then the default port 5683 is assumed, as with UDP.)</t>
</list></t>

</section>
<section anchor="coapstcp-uri-scheme" title="coaps+tcp URI scheme">

<figure><artwork><![CDATA[
coaps-tcp-URI = "coaps+tcp:" "//" host [ ":" port ] path-abempty
                [ "?" query ]
]]></artwork></figure>

<t>The semantics defined in <xref target="RFC7252"/>, Section 6.2, applies to this
URI scheme, with the following changes:</t>

<t><list style="symbols">
  <t>The port subcomponent indicates the TCP port at which the TLS server
for the CoAP server is located.  If it is empty or not given, then
the default port 443 is assumed (this is different from the default
port for “coaps”, i.e., CoAP over DTLS over UDP).</t>
  <t>When CoAP is exchanged over TLS port 443 then the “TLS Application
Layer Protocol Negotiation Extension” <xref target="RFC7301"/> MUST be used to allow demultiplexing
at the server-side unless out-of-band information ensures that the
client only interacts with a server that is able to demultiplex CoAP
messages over port 443. This would, for example, be true for many
Internet of Things deployments where clients are pre-configured to
only ever talk with specific servers.
      <cref anchor="_1" source="cabo">Shouldn’t we simply always require ALPN?
   The protocol should not be defined in such a way that it
   depends on some undefined pre-configuration mechanism.</cref></t>
</list></t>

</section>
</section>
<section anchor="security" title="Security Considerations">

<t>This document defines how to convey CoAP over TCP and TLS. It does not
introduce new vulnerabilities beyond those described already in the
CoAP specification. CoAP <xref target="RFC7252"/> makes use of DTLS 1.2 and this
specification consequently uses TLS 1.2 <xref target="RFC5246"/>. CoAP MUST NOT be
used with older versions of TLS. Guidelines for use of cipher suites
and TLS extensions can be found in <xref target="I-D.ietf-dice-profile"/>.</t>

</section>
<section anchor="iana" title="IANA Considerations">

<section anchor="service-name-and-port-number-registration" title="Service Name and Port Number Registration">

<t>IANA is requested to assign the port number 5683 and the service name “coap+tcp”,
in accordance with <xref target="RFC6335"/>.</t>

<t><list style="hanging">
  <t hangText='Service Name.'><vspace blankLines='0'/>
  coap+tcp</t>
  <t hangText='Transport Protocol.'><vspace blankLines='0'/>
  tcp</t>
  <t hangText='Assignee.'><vspace blankLines='0'/>
  IESG &lt;iesg@ietf.org&gt;</t>
  <t hangText='Contact.'><vspace blankLines='0'/>
  IETF Chair &lt;chair@ietf.org&gt;</t>
  <t hangText='Description.'><vspace blankLines='0'/>
  Constrained Application Protocol (CoAP)</t>
  <t hangText='Reference.'><vspace blankLines='0'/>
  [RFCthis]</t>
  <t hangText='Port Number.'><vspace blankLines='0'/>
  5683</t>
</list></t>

<t>Similarly, IANA is requested to assign the
service name “coaps+tcp”, in accordance with <xref target="RFC6335"/>.
However, no separate port number is used for “coaps” over TCP; instead,
the ALPN protocol ID defined in <xref target="alpnpid"/> is used over port 443.</t>

<t><list style="hanging">
  <t hangText='Service Name.'><vspace blankLines='0'/>
  coaps+tcp</t>
  <t hangText='Transport Protocol.'><vspace blankLines='0'/>
  tcp</t>
  <t hangText='Assignee.'><vspace blankLines='0'/>
  IESG &lt;iesg@ietf.org&gt;</t>
  <t hangText='Contact.'><vspace blankLines='0'/>
  IETF Chair &lt;chair@ietf.org&gt;</t>
  <t hangText='Description.'><vspace blankLines='0'/>
  Constrained Application Protocol (CoAP)</t>
  <t hangText='Reference.'><vspace blankLines='0'/>
  <xref target="RFC7301"/>, [RFCthis]</t>
  <t hangText='Port Number.'><vspace blankLines='0'/>
  443  (see also <xref target="alpnpid"/> of [RFCthis]})</t>
</list></t>

</section>
<section anchor="uri-schemes" title="URI Schemes">

<t>This document registers two new URI schemes, namely “coap+tcp” and
“coaps+tcp”, for the use of CoAP over TCP and for CoAP over TLS over
TCP, respectively. The “coap+tcp” and “coaps+tcp” URI schemes can thus
be compared to the “http” and “https” URI schemes.</t>

<t>The syntax of the “coap” and “coaps” URI schemes is specified in
Section 6 of <xref target="RFC7252"/> and the present document re-uses their
semantics for “coap+tcp” and “coaps+tcp”, respectively, with the
exception that TCP, or TLS over TCP is used as a transport protocol.</t>

<t>IANA is requested to add these new URI schemes to the registry
established with <xref target="RFC4395"/>.</t>

</section>
<section anchor="alpnpid" title="ALPN Protocol ID">

<t>This document requests a value from the “Application Layer Protocol
Negotiation (ALPN) Protocol IDs” created by <xref target="RFC7301"/>:</t>

<t><list style="hanging">
  <t hangText='Protocol:'><vspace blankLines='0'/>
  CoAP</t>
  <t hangText='Identification Sequence:'><vspace blankLines='0'/>
  0x63 0x6f 0x61 0x70 (“coap”)</t>
  <t hangText='Reference:'><vspace blankLines='0'/>
  [RFCthis]</t>
</list></t>

</section>
</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>We would like to thank Stephen Berard, Geoffrey Cristallo, Olivier Delaby,
Michael Koster, Matthias Kovatsch, Szymon Sasin, and Zach Shelby for their
feedback.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='RFC5246'>

<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='http://www.rfc-editor.org/rfc/rfc5246.txt' />
</reference>



<reference anchor='RFC7252'>

<front>
<title>The Constrained Application Protocol (CoAP)</title>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'>
<organization /></author>
<author initials='K.' surname='Hartke' fullname='K. Hartke'>
<organization /></author>
<author initials='C.' surname='Bormann' fullname='C. Bormann'>
<organization /></author>
<date year='2014' month='June' />
<abstract>
<t>The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks. The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) often have high packet error rates and a typical throughput of 10s of kbit/s. The protocol is designed for machine- to-machine (M2M) applications such as smart energy and building automation.&lt;/t>&lt;t> CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types. CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments.</t></abstract></front>

<seriesInfo name='RFC' value='7252' />
<format type='TXT' octets='258789' target='http://www.rfc-editor.org/rfc/rfc7252.txt' />
</reference>



<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>



<reference anchor='RFC4395'>

<front>
<title>Guidelines and Registration Procedures for New URI Schemes</title>
<author initials='T.' surname='Hansen' fullname='T. Hansen'>
<organization /></author>
<author initials='T.' surname='Hardie' fullname='T. Hardie'>
<organization /></author>
<author initials='L.' surname='Masinter' fullname='L. Masinter'>
<organization /></author>
<date year='2006' month='February' />
<abstract>
<t>This document provides guidelines and recommendations for the definition of Uniform Resource Identifier (URI) schemes.  It also updates the process and IANA registry for URI schemes.  It obsoletes both RFC 2717 and RFC 2718.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='35' />
<seriesInfo name='RFC' value='4395' />
<format type='TXT' octets='31933' target='http://www.rfc-editor.org/rfc/rfc4395.txt' />
</reference>



<reference anchor='RFC0793'>

<front>
<title abbrev='Transmission Control Protocol'>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='Jon Postel'>
<organization>University of Southern California (USC)/Information Sciences Institute</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal></address></author>
<date year='1981' day='1' month='September' /></front>

<seriesInfo name='STD' value='7' />
<seriesInfo name='RFC' value='793' />
<format type='TXT' octets='172710' target='http://www.rfc-editor.org/rfc/rfc793.txt' />
</reference>



<reference anchor='RFC7301'>

<front>
<title>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</title>
<author initials='S.' surname='Friedl' fullname='S. Friedl'>
<organization /></author>
<author initials='A.' surname='Popov' fullname='A. Popov'>
<organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'>
<organization /></author>
<author initials='E.' surname='Stephan' fullname='E. Stephan'>
<organization /></author>
<date year='2014' month='July' />
<abstract>
<t>This document describes a Transport Layer Security (TLS) extension for application-layer protocol negotiation within the TLS handshake.  For instances in which multiple application protocols are supported on the same TCP or UDP port, this extension allows the application layer to negotiate which protocol will be used within the TLS connection.</t></abstract></front>

<seriesInfo name='RFC' value='7301' />
<format type='TXT' octets='17439' target='http://www.rfc-editor.org/rfc/rfc7301.txt' />
</reference>



<reference anchor='I-D.ietf-dice-profile'>
<front>
<title>A TLS/DTLS Profile for the Internet of Things</title>

<author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>
    <organization />
</author>

<author initials='T' surname='Fossati' fullname='Thomas Fossati'>
    <organization />
</author>

<date month='May' day='28' year='2015' />

<abstract><t>A common design pattern in Internet of Things (IoT) deployments is the use of a constrained device that collects data via sensor or controls actuators for use in home automation, industrial control systems, smart cities and other IoT deployments.  This document defines a Transport Layer Security (TLS) and Datagram TLS (DTLS) 1.2 profile that offers communications security for this data exchange thereby preventing eavesdropping, tampering, and message forgery.  The lack of communication security is a common vulnerability in Internet of Things products that can easily be solved by using these well-researched and widely deployed Internet security protocols.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-dice-profile-12' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-dice-profile-12.txt' />
</reference>




    </references>

    <references title='Informative References'>





<reference anchor='I-D.bormann-core-cocoa'>
<front>
<title>CoAP Simple Congestion Control/Advanced</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<author initials='A' surname='Betzler' fullname='August Betzler'>
    <organization />
</author>

<author initials='C' surname='Gomez' fullname='Carles Gomez'>
    <organization />
</author>

<author initials='I' surname='Demirkol' fullname='Ilker Demirkol'>
    <organization />
</author>

<date month='July' day='3' year='2014' />

<abstract><t>The CoAP protocol needs to be implemented in such a way that it does not cause persistent congestion on the network it uses.  The CoRE CoAP specification defines basic behavior that exhibits low risk of congestion with minimal implementation requirements.  It also leaves room for combining the base specification with advanced congestion control mechanisms with higher performance.  This specification defines some simple advanced CoRE Congestion Control mechanisms, Simple CoCoA.  In the present version -02, it is making use of input from simulations and experiments in real networks.  The specification might still benefit from simplifying it further.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-bormann-core-cocoa-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-bormann-core-cocoa-02.txt' />
</reference>



<reference anchor='I-D.ietf-core-block'>
<front>
<title>Block-wise transfers in CoAP</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<date month='March' day='9' year='2015' />

<abstract><t>CoAP is a RESTful transfer protocol for constrained nodes and networks.  Basic CoAP messages work well for the small payloads we expect from temperature sensors, light switches, and similar building-automation devices.  Occasionally, however, applications will need to transfer larger payloads -- for instance, for firmware updates.  With HTTP, TCP does the grunt work of slicing large payloads up into multiple packets and ensuring that they all arrive and are handled in the right order.  CoAP is based on datagram transports such as UDP or DTLS, which limits the maximum size of resource representations that can be transferred without too much fragmentation.  Although UDP supports larger payloads through IP fragmentation, it is limited to 64 KiB and, more importantly, doesn't really work well for constrained applications and networks.  Instead of relying on IP fragmentation, this specification extends basic CoAP with a pair of "Block" options, for transferring multiple blocks of information from a resource representation in multiple request-response pairs.  In many important cases, the Block options enable a server to be truly stateless: the server can handle each block transfer separately, with no need for a connection setup or other server-side memory of previous block transfers.  In summary, the Block options provide a minimal way to transfer larger representations in a block-wise fashion.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-block-17' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-block-17.txt' />
</reference>



<reference anchor='RFC0768'>

<front>
<title>User Datagram Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'>
<organization>University of Southern California (USC)/Information Sciences Institute</organization>
<address>
<postal>
<street>4676 Admiralty Way</street>
<city>Marina del Rey</city>
<region>CA</region>
<code>90291</code>
<country>US</country></postal>
<phone>+1 213 822 1511</phone></address></author>
<date year='1980' day='28' month='August' /></front>

<seriesInfo name='STD' value='6' />
<seriesInfo name='RFC' value='768' />
<format type='TXT' octets='5896' target='http://www.rfc-editor.org/rfc/rfc768.txt' />
</reference>



<reference anchor='RFC6347'>

<front>
<title>Datagram Transport Layer Security Version 1.2</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<author initials='N.' surname='Modadugu' fullname='N. Modadugu'>
<organization /></author>
<date year='2012' month='January' />
<abstract>
<t>This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6347' />
<format type='TXT' octets='73546' target='http://www.rfc-editor.org/rfc/rfc6347.txt' />
</reference>



<reference anchor='RFC6335'>

<front>
<title>Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry</title>
<author initials='M.' surname='Cotton' fullname='M. Cotton'>
<organization /></author>
<author initials='L.' surname='Eggert' fullname='L. Eggert'>
<organization /></author>
<author initials='J.' surname='Touch' fullname='J. Touch'>
<organization /></author>
<author initials='M.' surname='Westerlund' fullname='M. Westerlund'>
<organization /></author>
<author initials='S.' surname='Cheshire' fullname='S. Cheshire'>
<organization /></author>
<date year='2011' month='August' />
<abstract>
<t>This document defines the procedures that the Internet Assigned Numbers Authority (IANA) uses when handling assignment and other requests related to the Service Name and Transport Protocol Port Number registry. It also discusses the rationale and principles behind these procedures and how they facilitate the long-term sustainability of the registry.&lt;/t>&lt;t> This document updates IANA's procedures by obsoleting the previous UDP and TCP port assignment procedures defined in Sections 8 and 9.1 of the IANA Allocation Guidelines, and it updates the IANA service name and port assignment procedures for UDP-Lite, the Datagram Congestion Control Protocol (DCCP), and the Stream Control Transmission Protocol (SCTP). It also updates the DNS SRV specification to clarify what a service name is and how it is registered. This memo documents an Internet Best Current Practice.</t></abstract></front>

<seriesInfo name='BCP' value='165' />
<seriesInfo name='RFC' value='6335' />
<format type='TXT' octets='79088' target='http://www.rfc-editor.org/rfc/rfc6335.txt' />
</reference>



<reference anchor='RFC7049'>

<front>
<title>Concise Binary Object Representation (CBOR)</title>
<author initials='C.' surname='Bormann' fullname='C. Bormann'>
<organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'>
<organization /></author>
<date year='2013' month='October' />
<abstract>
<t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t></abstract></front>

<seriesInfo name='RFC' value='7049' />
<format type='TXT' octets='134062' target='http://www.rfc-editor.org/rfc/rfc7049.txt' />
</reference>


<reference anchor="HomeGateway" >
  <front>
    <title>An experimental study of home gateway characteristics</title>
    <author initials="L." surname="Eggert" fullname="Lars Eggert">
      <organization></organization>
    </author>
    <date year="2010"/>
  </front>
  <seriesInfo name="Proceedings" value="of the 10th annual conference on Internet measurement"/>
</reference>


    </references>


<!--  LocalWords:  TCP CoAP UDP firewalling firewalled TLS IP SCTP
 -->
<!--  LocalWords:  DCCP IoT optimizations ACKs acknowledgement TKL
 -->
<!--  LocalWords:  prepending URI DTLS demultiplexing demultiplex pre
 -->
<!--  LocalWords:  IANA ALPN Middleboxes NATs ACK acknowledgements
 -->
<!--  LocalWords:  datagram prepended CBOR namespaces subcomponent
 -->
<!--  LocalWords:  Assignee
 -->



  </back>
</rfc>

