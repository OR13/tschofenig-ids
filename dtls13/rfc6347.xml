<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.36 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" category="std" obsoletes="4347">

  <front>
    <title abbrev="DTLS">Datagram Transport Layer Security Version 1.2</title>

    <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
      <organization>RTFM, Inc.</organization>
      <address>
        <postal>
          <street>2064 Edgewood Drive</street>
          <city>Palo Alto</city>
          <code>CA 94303</code>
        </postal>
        <email>ekr@rtfm.com</email>
      </address>
    </author>
    <author initials="N." surname="Modadugu" fullname="Nagendra Modadugu">
      <organization>Google, Inc.</organization>
      <address>
        <email>nagendra@cs.stanford.edu</email>
      </address>
    </author>

    <date year="2012" month="January"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document specifies version 1.2 of the Datagram Transport Layer
   Security (DTLS) protocol.  The DTLS protocol provides communications
   privacy for datagram protocols.  The protocol allows client/server
   applications to communicate in a way that is designed to prevent
   eavesdropping, tampering, or message forgery.  The DTLS protocol is
   based on the Transport Layer Security (TLS) protocol and provides
   equivalent security guarantees.  Datagram semantics of the underlying
   transport are preserved by the DTLS protocol.  This document updates
   DTLS 1.0 to work with TLS version 1.2.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>TLS [TLS] is the most widely deployed protocol for securing network
   traffic.  It is widely used for protecting Web traffic and for e-mail
   protocols such as IMAP [IMAP] and POP [POP].  The primary advantage
   of TLS is that it provides a transparent connection-oriented channel.
   Thus, it is easy to secure an application protocol by inserting TLS
   between the application layer and the transport layer.  However, TLS
   must run over a reliable transport channel – typically TCP [TCP].
   Therefore, it cannot be used to secure unreliable datagram traffic.</t>

<t>An increasing number of application layer protocols have been
   designed that use UDP transport.  In particular, protocols such as
   the Session Initiation Protocol (SIP) [SIP] and electronic gaming
   protocols are increasingly popular.  (Note that SIP can run over both
   TCP and UDP, but that there are situations in which UDP is
   preferable.)  Currently, designers of these applications are faced
   with a number of unsatisfactory choices.  First, they can use IPsec
   <xref target="RFC4301"></xref>.  However, for a number of reasons detailed in [WHYIPSEC],
   this is only suitable for some applications.  Second, they can design
   a custom application layer security protocol.  Unfortunately,
   although application layer security protocols generally provide
   superior security properties (e.g., end-to-end security in the case
   of S/MIME), they typically require a large amount of effort to design
   – in contrast to the relatively small amount of effort required to
   run the protocol over TLS.</t>

<t>In many cases, the most desirable way to secure client/server
   applications would be to use TLS; however, the requirement for
   datagram semantics automatically prohibits use of TLS.  This memo
   describes a protocol for this purpose: Datagram Transport Layer
   Security (DTLS).  DTLS is deliberately designed to be as similar to
   TLS as possible, both to minimize new security invention and to
   maximize the amount of code and infrastructure reuse.</t>

<t>DTLS 1.0 [DTLS1] was originally defined as a delta from [TLS11].
   This document introduces a new version of DTLS, DTLS 1.2, which is
   defined as a series of deltas to TLS 1.2 [TLS12].  There is no DTLS
   1.1; that version number was skipped in order to harmonize version
   numbers with TLS.  This version also clarifies some confusing points
   in the DTLS 1.0 specification.</t>

<t>Implementations that speak both DTLS 1.2 and DTLS 1.0 can
   interoperate with those that speak only DTLS 1.0 (using DTLS 1.0 of
   course), just as TLS 1.2 implementations can interoperate with
   previous versions of TLS (see Appendix E.1 of [TLS12] for details),
   with the exception that there is no DTLS version of SSLv2 or SSLv3,
   so backward compatibility issues for those protocols do not apply.</t>

<section anchor="requirements-terminology" title="Requirements Terminology">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
   “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
   document are to be interpreted as described in RFC 2119 [REQ].</t>

</section>
</section>
<section anchor="usage-model" title="Usage Model">

<t>The DTLS protocol is designed to secure data between communicating
   applications.  It is designed to run in application space, without
   requiring any kernel modifications.</t>

<t>Datagram transport does not require or provide reliable or in-order
   delivery of data.  The DTLS protocol preserves this property for
   payload data.  Applications such as media streaming, Internet
   telephony, and online gaming use datagram transport for communication
   due to the delay-sensitive nature of transported data.  The behavior
   of such applications is unchanged when the DTLS protocol is used to
   secure communication, since the DTLS protocol does not compensate for
   lost or re-ordered data traffic.</t>

</section>
<section anchor="overview-of-dtls" title="Overview of DTLS">

<t>The basic design philosophy of DTLS is to construct “TLS over
   datagram transport”.  The reason that TLS cannot be used directly in
   datagram environments is simply that packets may be lost or
   reordered.  TLS has no internal facilities to handle this kind of
   unreliability; therefore, TLS implementations break when rehosted on
   datagram transport.  The purpose of DTLS is to make only the minimal
   changes to TLS required to fix this problem.  To the greatest extent
   possible, DTLS is identical to TLS.  Whenever we need to invent new
   mechanisms, we attempt to do so in such a way that preserves the
   style of TLS.</t>

<t>Unreliability creates problems for TLS at two levels:</t>

<figure><artwork><![CDATA[
  1. TLS does not allow independent decryption of individual
     records.  Because the integrity check depends on the sequence
     number, if record N is not received, then the integrity check
     on record N+1 will be based on the wrong sequence number and
     thus will fail.  (Note that prior to TLS 1.1, there was no
     explicit IV and so decryption would also fail.)

  2. The TLS handshake layer assumes that handshake messages are
     delivered reliably and breaks if those messages are lost.
]]></artwork></figure>

<t>The rest of this section describes the approach that DTLS uses to
   solve these problems.</t>

<section anchor="loss-insensitive-messaging" title="Loss-Insensitive Messaging">

<t>In TLS’s traffic encryption layer (called the TLS Record Layer),
   records are not independent.  There are two kinds of inter-record
   dependency:</t>

<figure><artwork><![CDATA[
  1. Cryptographic context (stream cipher key stream) is retained
     between records.

  2. Anti-replay and message reordering protection are provided by a
     MAC that includes a sequence number, but the sequence numbers
     are implicit in the records.
]]></artwork></figure>

<t>DTLS solves the first problem by banning stream ciphers.  DTLS solves
   the second problem by adding explicit sequence numbers.</t>

</section>
<section anchor="providing-reliability-for-handshake" title="Providing Reliability for Handshake">

<t>The TLS handshake is a lockstep cryptographic handshake.  Messages
   must be transmitted and received in a defined order; any other order
   is an error.  Clearly, this is incompatible with reordering and
   message loss.  In addition, TLS handshake messages are potentially
   larger than any given datagram, thus creating the problem of IP
   fragmentation.  DTLS must provide fixes for both of these problems.</t>

<section anchor="packet-loss" title="Packet Loss">

<t>DTLS uses a simple retransmission timer to handle packet loss.  The
   following figure demonstrates the basic concept, using the first
   phase of the DTLS handshake:</t>

<figure><artwork><![CDATA[
     Client                                   Server
     ------                                   ------
     ClientHello           ------>

                             X<-- HelloVerifyRequest
                                              (lost)

     [Timer Expires]

     ClientHello           ------>
     (retransmit)
]]></artwork></figure>

<t>Once the client has transmitted the ClientHello message, it expects
   to see a HelloVerifyRequest from the server.  However, if the
   server’s message is lost, the client knows that either the
   ClientHello or the HelloVerifyRequest has been lost and retransmits.
   When the server receives the retransmission, it knows to retransmit.</t>

<t>The server also maintains a retransmission timer and retransmits when
   that timer expires.</t>

<t>Note that timeout and retransmission do not apply to the
   HelloVerifyRequest, because this would require creating state on the
   server.  The HelloVerifyRequest is designed to be small enough that
   it will not itself be fragmented, thus avoiding concerns about
   interleaving multiple HelloVerifyRequests.</t>

</section>
<section anchor="reordering" title="Reordering">

<t>In DTLS, each handshake message is assigned a specific sequence
   number within that handshake.  When a peer receives a handshake
   message, it can quickly determine whether that message is the next
   message it expects.  If it is, then it processes it.  If not, it
   queues it for future handling once all previous messages have been
   received.</t>

</section>
<section anchor="message-size" title="Message Size">

<t>TLS and DTLS handshake messages can be quite large (in theory up to
   2^24-1 bytes, in practice many kilobytes).  By contrast, UDP
   datagrams are often limited to &lt;1500 bytes if IP fragmentation is not
   desired.  In order to compensate for this limitation, each DTLS
   handshake message may be fragmented over several DTLS records, each
   of which is intended to fit in a single IP datagram.  Each DTLS
   handshake message contains both a fragment offset and a fragment
   length.  Thus, a recipient in possession of all bytes of a handshake
   message can reassemble the original unfragmented message.</t>

</section>
</section>
<section anchor="replay-detection" title="Replay Detection">

<t>DTLS optionally supports record replay detection.  The technique used
   is the same as in IPsec AH/ESP, by maintaining a bitmap window of
   received records.  Records that are too old to fit in the window and
   records that have previously been received are silently discarded.
   The replay detection feature is optional, since packet duplication is
   not always malicious, but can also occur due to routing errors.
   Applications may conceivably detect duplicate packets and accordingly
   modify their data transmission strategy.</t>

</section>
</section>
<section anchor="differences-from-tls" title="Differences from TLS">

<t>As mentioned in Section 3, DTLS is intentionally very similar to TLS.
   Therefore, instead of presenting DTLS as a new protocol, we present
   it as a series of deltas from TLS 1.2 [TLS12].  Where we do not
   explicitly call out differences, DTLS is the same as in [TLS12].</t>

<section anchor="record-layer" title="Record Layer">

<t>The DTLS record layer is extremely similar to that of TLS 1.2.  The
   only change is the inclusion of an explicit sequence number in the
   record.  This sequence number allows the recipient to correctly
   verify the TLS MAC.  The DTLS record format is shown below:</t>

<figure><artwork><![CDATA[
  struct {
       ContentType type;
       ProtocolVersion version;
       uint16 epoch;                                    // New field
       uint48 sequence_number;                          // New field
       uint16 length;
       opaque fragment[DTLSPlaintext.length];
     } DTLSPlaintext;
]]></artwork></figure>

<t>type</t>

<figure><artwork><![CDATA[
  Equivalent to the type field in a TLS 1.2 record.
]]></artwork></figure>

<t>version</t>

<figure><artwork><![CDATA[
  The version of the protocol being employed.  This document
  describes DTLS version 1.2, which uses the version { 254, 253 }.
  The version value of 254.253 is the 1's complement of DTLS version
  1.2.  This maximal spacing between TLS and DTLS version numbers
  ensures that records from the two protocols can be easily
  distinguished.  It should be noted that future on-the-wire version
  numbers of DTLS are decreasing in value (while the true version
  number is increasing in value.)
]]></artwork></figure>

<t>epoch</t>

<figure><artwork><![CDATA[
  A counter value that is incremented on every cipher state change.
]]></artwork></figure>

<t>sequence_number</t>

<figure><artwork><![CDATA[
  The sequence number for this record.
]]></artwork></figure>

<t>length</t>

<figure><artwork><![CDATA[
  Identical to the length field in a TLS 1.2 record.  As in TLS 1.2,
  the length should not exceed 2^14.
]]></artwork></figure>

<t>fragment</t>

<figure><artwork><![CDATA[
  Identical to the fragment field of a TLS 1.2 record.
]]></artwork></figure>

<t>DTLS uses an explicit sequence number, rather than an implicit one,
   carried in the sequence_number field of the record.  Sequence numbers
   are maintained separately for each epoch, with each sequence_number
   initially being 0 for each epoch.  For instance, if a handshake
   message from epoch 0 is retransmitted, it might have a sequence
   number after a message from epoch 1, even if the message from epoch 1
   was transmitted first.  Note that some care needs to be taken during
   the handshake to ensure that retransmitted messages use the right
   epoch and keying material.</t>

<t>If several handshakes are performed in close succession, there might
   be multiple records on the wire with the same sequence number but
   from different cipher states.  The epoch field allows recipients to
   distinguish such packets.  The epoch number is initially zero and is
   incremented each time a ChangeCipherSpec message is sent.  In order
   to ensure that any given sequence/epoch pair is unique,
   implementations MUST NOT allow the same epoch value to be reused
   within two times the TCP maximum segment lifetime.  In practice, TLS
   implementations rarely rehandshake; therefore, we do not expect this
   to be a problem.</t>

<t>Note that because DTLS records may be reordered, a record from epoch
   1 may be received after epoch 2 has begun.  In general,
   implementations SHOULD discard packets from earlier epochs, but if
   packet loss causes noticeable problems they MAY choose to retain
   keying material from previous epochs for up to the default MSL
   specified for TCP [TCP] to allow for packet reordering.  (Note that
   the intention here is that implementors use the current guidance from
   the IETF for MSL, not that they attempt to interrogate the MSL that
   the system TCP stack is using.)  Until the handshake has completed,
   implementations MUST accept packets from the old epoch.</t>

<t>Conversely, it is possible for records that are protected by the
   newly negotiated context to be received prior to the completion of a
   handshake.  For instance, the server may send its Finished message
   and then start transmitting data.  Implementations MAY either buffer
   or discard such packets, though when DTLS is used over reliable
   transports (e.g., SCTP), they SHOULD be buffered and processed once
   the handshake completes.  Note that TLS’s restrictions on when
   packets may be sent still apply, and the receiver treats the packets
   as if they were sent in the right order.  In particular, it is still
   impermissible to send data prior to completion of the first
   handshake.</t>

<t>Note that in the special case of a rehandshake on an existing
   association, it is safe to process a data packet immediately, even if
   the ChangeCipherSpec or Finished messages have not yet been received
   provided that either the rehandshake resumes the existing session or
   that it uses exactly the same security parameters as the existing
   association.  In any other case, the implementation MUST wait for the
   receipt of the Finished message to prevent downgrade attack.</t>

<t>As in TLS, implementations MUST either abandon an association or
   rehandshake prior to allowing the sequence number to wrap.</t>

<t>Similarly, implementations MUST NOT allow the epoch to wrap, but
   instead MUST establish a new association, terminating the old
   association as described in Section 4.2.8.  In practice,
   implementations rarely rehandshake repeatedly on the same channel, so
   this is not likely to be an issue.</t>

<section anchor="transport-layer-mapping" title="Transport Layer Mapping">

<t>Each DTLS record MUST fit within a single datagram.  In order to
   avoid IP fragmentation, clients of the DTLS record layer SHOULD
   attempt to size records so that they fit within any PMTU estimates
   obtained from the record layer.</t>

<t>Note that unlike IPsec, DTLS records do not contain any association
   identifiers.  Applications must arrange to multiplex between
   associations.  With UDP, this is presumably done with the host/port
   number.</t>

<t>Multiple DTLS records may be placed in a single datagram.  They are
   simply encoded consecutively.  The DTLS record framing is sufficient
   to determine the boundaries.  Note, however, that the first byte of
   the datagram payload must be the beginning of a record.  Records may
   not span datagrams.</t>

<t>Some transports, such as DCCP [DCCP] provide their own sequence
   numbers.  When carried over those transports, both the DTLS and the
   transport sequence numbers will be present.  Although this introduces
   a small amount of inefficiency, the transport layer and DTLS sequence
   numbers serve different purposes; therefore, for conceptual
   simplicity, it is superior to use both sequence numbers.  In the
   future, extensions to DTLS may be specified that allow the use of
   only one set of sequence numbers for deployment in constrained
   environments.</t>

<t>Some transports, such as DCCP, provide congestion control for traffic
   carried over them.  If the congestion window is sufficiently narrow,
   DTLS handshake retransmissions may be held rather than transmitted
   immediately, potentially leading to timeouts and spurious
   retransmission.  When DTLS is used over such transports, care should
   be taken not to overrun the likely congestion window. [DCCPDTLS]
   defines a mapping of DTLS to DCCP that takes these issues into
   account.</t>

<section anchor="pmtu-issues" title="PMTU Issues">

<t>In general, DTLS’s philosophy is to leave PMTU discovery to the
   application.  However, DTLS cannot completely ignore PMTU for three
   reasons:</t>

<t><list style="symbols">
  <t>The DTLS record framing expands the datagram size, thus lowering
the effective PMTU from the application’s perspective.</t>
  <t>In some implementations, the application may not directly talk to
the network, in which case the DTLS stack may absorb ICMP
<xref target="RFC1191"></xref> “Datagram Too Big” indications or ICMPv6 <xref target="RFC4443"></xref>
“Packet Too Big” indications.</t>
  <t>The DTLS handshake messages can exceed the PMTU.</t>
</list></t>

<t>In order to deal with the first two issues, the DTLS record layer
   SHOULD behave as described below.</t>

<t>If PMTU estimates are available from the underlying transport
   protocol, they should be made available to upper layer protocols.  In
   particular:</t>

<t><list style="symbols">
  <t>For DTLS over UDP, the upper layer protocol SHOULD be allowed to
obtain the PMTU estimate maintained in the IP layer.</t>
  <t>For DTLS over DCCP, the upper layer protocol SHOULD be allowed to
obtain the current estimate of the PMTU.</t>
  <t>For DTLS over TCP or SCTP, which automatically fragment and
reassemble datagrams, there is no PMTU limitation.  However, the
upper layer protocol MUST NOT write any record that exceeds the
maximum record size of 2^14 bytes.</t>
</list></t>

<t>The DTLS record layer SHOULD allow the upper layer protocol to
   discover the amount of record expansion expected by the DTLS
   processing.  Note that this number is only an estimate because of
   block padding and the potential use of DTLS compression.</t>

<t>If there is a transport protocol indication (either via ICMP or via a
   refusal to send the datagram as in Section 14 of [DCCP]), then the
   DTLS record layer MUST inform the upper layer protocol of the error.</t>

<t>The DTLS record layer SHOULD NOT interfere with upper layer protocols
   performing PMTU discovery, whether via <xref target="RFC1191"></xref> or <xref target="RFC4821"></xref>
   mechanisms.  In particular:</t>

<t><list style="symbols">
  <t>Where allowed by the underlying transport protocol, the upper
layer protocol SHOULD be allowed to set the state of the DF bit
(in IPv4) or prohibit local fragmentation (in IPv6).</t>
  <t>If the underlying transport protocol allows the application to
request PMTU probing (e.g., DCCP), the DTLS record layer should
honor this request.</t>
</list></t>

<t>The final issue is the DTLS handshake protocol.  From the perspective
   of the DTLS record layer, this is merely another upper layer
   protocol.  However, DTLS handshakes occur infrequently and involve
   only a few round trips; therefore, the handshake protocol PMTU
   handling places a premium on rapid completion over accurate PMTU
   discovery.  In order to allow connections under these circumstances,
   DTLS implementations SHOULD follow the following rules:</t>

<t><list style="symbols">
  <t>If the DTLS record layer informs the DTLS handshake layer that a
message is too big, it SHOULD immediately attempt to fragment it,
using any existing information about the PMTU.</t>
  <t>If repeated retransmissions do not result in a response, and the
PMTU is unknown, subsequent retransmissions SHOULD back off to a
smaller record size, fragmenting the handshake message as
appropriate.  This standard does not specify an exact number of
retransmits to attempt before backing off, but 2-3 seems
appropriate.</t>
</list></t>

</section>
</section>
<section anchor="record-payload-protection" title="Record Payload Protection">

<t>Like TLS, DTLS transmits data as a series of protected records.  The
   rest of this section describes the details of that format.</t>

<section anchor="mac" title="MAC">

<t>The DTLS MAC is the same as that of TLS 1.2. However, rather than
   using TLS’s implicit sequence number, the sequence number used to
   compute the MAC is the 64-bit value formed by concatenating the epoch
   and the sequence number in the order they appear on the wire.  Note
   that the DTLS epoch + sequence number is the same length as the TLS
   sequence number.</t>

<t>TLS MAC calculation is parameterized on the protocol version number,
   which, in the case of DTLS, is the on-the-wire version, i.e., {254,
   253} for DTLS 1.2.</t>

<t>Note that one important difference between DTLS and TLS MAC handling
   is that in TLS, MAC errors must result in connection termination.  In
   DTLS, the receiving implementation MAY simply discard the offending
   record and continue with the connection.  This change is possible
   because DTLS records are not dependent on each other in the way that
   TLS records are.</t>

<t>In general, DTLS implementations SHOULD silently discard records with
   bad MACs or that are otherwise invalid.  They MAY log an error.  If a
   DTLS implementation chooses to generate an alert when it receives a
   message with an invalid MAC, it MUST generate a bad_record_mac alert</t>

<t>with level fatal and terminate its connection state.  Note that
   because errors do not cause connection termination, DTLS stacks are
   more efficient error type oracles than TLS stacks.  Thus, it is
   especially important that the advice in Section 6.2.3.2 of [TLS12] be
   followed.</t>

</section>
<section anchor="null-or-standard-stream-cipher" title="Null or Standard Stream Cipher">

<t>The DTLS NULL cipher is performed exactly as the TLS 1.2 NULL cipher.</t>

<t>The only stream cipher described in TLS 1.2 is RC4, which cannot be
   randomly accessed.  RC4 MUST NOT be used with DTLS.</t>

</section>
<section anchor="block-cipher" title="Block Cipher">

<t>DTLS block cipher encryption and decryption are performed exactly as
   with TLS 1.2.</t>

</section>
<section anchor="aead-ciphers" title="AEAD Ciphers">

<t>TLS 1.2 introduced authenticated encryption with additional data
   (AEAD) cipher suites.  The existing AEAD cipher suites, defined in
   [ECCGCM] and [RSAGCM], can be used with DTLS exactly as with TLS 1.2.</t>

</section>
<section anchor="new-cipher-suites" title="New Cipher Suites">

<t>Upon registration, new TLS cipher suites MUST indicate whether they
   are suitable for DTLS usage and what, if any, adaptations must be
   made (see Section 7 for IANA considerations).</t>

</section>
<section anchor="anti-replay" title="Anti-Replay">

<t>DTLS records contain a sequence number to provide replay protection.
   Sequence number verification SHOULD be performed using the following
   sliding window procedure, borrowed from Section 3.4.3 of [ESP].</t>

<t>The receiver packet counter for this session MUST be initialized to
   zero when the session is established.  For each received record, the
   receiver MUST verify that the record contains a sequence number that
   does not duplicate the sequence number of any other record received
   during the life of this session.  This SHOULD be the first check
   applied to a packet after it has been matched to a session, to speed
   rejection of duplicate records.</t>

<t>Duplicates are rejected through the use of a sliding receive window.
   (How the window is implemented is a local matter, but the following
   text describes the functionality that the implementation must
   exhibit.)  A minimum window size of 32 MUST be supported, but a
   window size of 64 is preferred and SHOULD be employed as the default.
   Another window size (larger than the minimum) MAY be chosen by the
   receiver.  (The receiver does not notify the sender of the window
   size.)</t>

<t>The “right” edge of the window represents the highest validated
   sequence number value received on this session.  Records that contain
   sequence numbers lower than the “left” edge of the window are
   rejected.  Packets falling within the window are checked against a
   list of received packets within the window.  An efficient means for
   performing this check, based on the use of a bit mask, is described
   in Section 3.4.3 of [ESP].</t>

<t>If the received record falls within the window and is new, or if the
   packet is to the right of the window, then the receiver proceeds to
   MAC verification.  If the MAC validation fails, the receiver MUST
   discard the received record as invalid.  The receive window is
   updated only if the MAC verification succeeds.</t>

</section>
<section anchor="handling-invalid-records" title="Handling Invalid Records">

<t>Unlike TLS, DTLS is resilient in the face of invalid records (e.g.,
   invalid formatting, length, MAC, etc.).  In general, invalid records
   SHOULD be silently discarded, thus preserving the association;
   however, an error MAY be logged for diagnostic purposes.
   Implementations which choose to generate an alert instead, MUST
   generate fatal level alerts to avoid attacks where the attacker
   repeatedly probes the implementation to see how it responds to
   various types of error.  Note that if DTLS is run over UDP, then any
   implementation which does this will be extremely susceptible to
   denial-of-service (DoS) attacks because UDP forgery is so easy.
   Thus, this practice is NOT RECOMMENDED for such transports.</t>

<t>If DTLS is being carried over a transport that is resistant to
   forgery (e.g., SCTP with SCTP-AUTH), then it is safer to send alerts
   because an attacker will have difficulty forging a datagram that will
   not be rejected by the transport layer.</t>

</section>
</section>
</section>
<section anchor="the-dtls-handshake-protocol" title="The DTLS Handshake Protocol">

<t>DTLS uses all of the same handshake messages and flows as TLS, with
   three principal changes:</t>

<figure><artwork><![CDATA[
  1. A stateless cookie exchange has been added to prevent denial-
     of-service attacks.

  2. Modifications to the handshake header to handle message loss,
     reordering, and DTLS message fragmentation (in order to avoid
     IP fragmentation).

  3. Retransmission timers to handle message loss.
]]></artwork></figure>

<t>With these exceptions, the DTLS message formats, flows, and logic are
   the same as those of TLS 1.2.</t>

<section anchor="denial-of-service-countermeasures" title="Denial-of-Service Countermeasures">

<t>Datagram security protocols are extremely susceptible to a variety of
   DoS attacks.  Two attacks are of particular concern:</t>

<figure><artwork><![CDATA[
  1. An attacker can consume excessive resources on the server by
     transmitting a series of handshake initiation requests, causing
     the server to allocate state and potentially to perform
     expensive cryptographic operations.

  2. An attacker can use the server as an amplifier by sending
     connection initiation messages with a forged source of the
     victim.  The server then sends its next message (in DTLS, a
     Certificate message, which can be quite large) to the victim
     machine, thus flooding it.
]]></artwork></figure>

<t>In order to counter both of these attacks, DTLS borrows the stateless
   cookie technique used by Photuris [PHOTURIS] and IKE [IKEv2].  When
   the client sends its ClientHello message to the server, the server
   MAY respond with a HelloVerifyRequest message.  This message contains
   a stateless cookie generated using the technique of [PHOTURIS].  The
   client MUST retransmit the ClientHello with the cookie added.  The
   server then verifies the cookie and proceeds with the handshake only
   if it is valid.  This mechanism forces the attacker/client to be able
   to receive the cookie, which makes DoS attacks with spoofed IP
   addresses difficult.  This mechanism does not provide any defense
   against DoS attacks mounted from valid IP addresses.</t>

<t>The exchange is shown below:</t>

<figure><artwork><![CDATA[
  Client                                   Server
  ------                                   ------
  ClientHello           ------>

                        <----- HelloVerifyRequest
                               (contains cookie)

  ClientHello           ------>
  (with cookie)

  [Rest of handshake]
]]></artwork></figure>

<t>DTLS therefore modifies the ClientHello message to add the cookie
   value.</t>

<figure><artwork><![CDATA[
   struct {
     ProtocolVersion client_version;
     Random random;
     SessionID session_id;
     opaque cookie<0..2^8-1>;                             // New field
     CipherSuite cipher_suites<2..2^16-1>;
           CompressionMethod compression_methods<1..2^8-1>;
   } ClientHello;
]]></artwork></figure>

<t>When sending the first ClientHello, the client does not have a cookie
   yet; in this case, the Cookie field is left empty (zero length).</t>

<t>The definition of HelloVerifyRequest is as follows:</t>

<figure><artwork><![CDATA[
   struct {
     ProtocolVersion server_version;
     opaque cookie<0..2^8-1>;
   } HelloVerifyRequest;
]]></artwork></figure>

<t>The HelloVerifyRequest message type is hello_verify_request(3).</t>

<t>The server_version field has the same syntax as in TLS.  However, in
   order to avoid the requirement to do version negotiation in the
   initial handshake, DTLS 1.2 server implementations SHOULD use DTLS
   version 1.0 regardless of the version of TLS that is expected to be
   negotiated.  DTLS 1.2 and 1.0 clients MUST use the version solely to
   indicate packet formatting (which is the same in both DTLS 1.2 and
   1.0) and not as part of version negotiation.  In particular, DTLS 1.2
   clients MUST NOT assume that because the server uses version 1.0 in
   the HelloVerifyRequest that the server is not DTLS 1.2 or that it
   will eventually negotiate DTLS 1.0 rather than DTLS 1.2.</t>

<t>When responding to a HelloVerifyRequest, the client MUST use the same
   parameter values (version, random, session_id, cipher_suites,
   compression_method) as it did in the original ClientHello.  The
   server SHOULD use those values to generate its cookie and verify that
   they are correct upon cookie receipt.  The server MUST use the same
   version number in the HelloVerifyRequest that it would use when
   sending a ServerHello.  Upon receipt of the ServerHello, the client
   MUST verify that the server version values match.  In order to avoid
   sequence number duplication in case of multiple HelloVerifyRequests,
   the server MUST use the record sequence number in the ClientHello as
   the record sequence number in the HelloVerifyRequest.</t>

<t>Note: This specification increases the cookie size limit to 255 bytes
   for greater future flexibility.  The limit remains 32 for previous
   versions of DTLS.</t>

<t>The DTLS server SHOULD generate cookies in such a way that they can
   be verified without retaining any per-client state on the server.
   One technique is to have a randomly generated secret and generate
   cookies as:</t>

<figure><artwork><![CDATA[
  Cookie = HMAC(Secret, Client-IP, Client-Parameters)
]]></artwork></figure>

<t>When the second ClientHello is received, the server can verify that
   the Cookie is valid and that the client can receive packets at the
   given IP address.  In order to avoid sequence number duplication in
   case of multiple cookie exchanges, the server MUST use the record
   sequence number in the ClientHello as the record sequence number in
   its initial ServerHello.  Subsequent ServerHellos will only be sent
   after the server has created state and MUST increment normally.</t>

<t>One potential attack on this scheme is for the attacker to collect a
   number of cookies from different addresses and then reuse them to
   attack the server.  The server can defend against this attack by
   changing the Secret value frequently, thus invalidating those
   cookies.  If the server wishes that legitimate clients be able to
   handshake through the transition (e.g., they received a cookie with
   Secret 1 and then sent the second ClientHello after the server has
   changed to Secret 2), the server can have a limited window during
   which it accepts both secrets.  [IKEv2] suggests adding a version
   number to cookies to detect this case.  An alternative approach is
   simply to try verifying with both secrets.</t>

<t>DTLS servers SHOULD perform a cookie exchange whenever a new
   handshake is being performed.  If the server is being operated in an
   environment where amplification is not a problem, the server MAY be
   configured not to perform a cookie exchange.  The default SHOULD be
   that the exchange is performed, however.  In addition, the server MAY</t>

<t>choose not to do a cookie exchange when a session is resumed.
   Clients MUST be prepared to do a cookie exchange with every
   handshake.</t>

<t>If HelloVerifyRequest is used, the initial ClientHello and
   HelloVerifyRequest are not included in the calculation of the
   handshake_messages (for the CertificateVerify message) and
   verify_data (for the Finished message).</t>

<t>If a server receives a ClientHello with an invalid cookie, it SHOULD
   treat it the same as a ClientHello with no cookie.  This avoids
   race/deadlock conditions if the client somehow gets a bad cookie
   (e.g., because the server changes its cookie signing key).</t>

<t>Note to implementors: This may result in clients receiving multiple
   HelloVerifyRequest messages with different cookies.  Clients SHOULD
   handle this by sending a new ClientHello with a cookie in response to
   the new HelloVerifyRequest.</t>

</section>
<section anchor="handshake-message-format" title="Handshake Message Format">

<t>In order to support message loss, reordering, and message
   fragmentation, DTLS modifies the TLS 1.2 handshake header:</t>

<figure><artwork><![CDATA[
   struct {
     HandshakeType msg_type;
     uint24 length;
     uint16 message_seq;                               // New field
     uint24 fragment_offset;                           // New field
     uint24 fragment_length;                           // New field
     select (HandshakeType) {
       case hello_request: HelloRequest;
       case client_hello:  ClientHello;
       case hello_verify_request: HelloVerifyRequest;  // New type
       case server_hello:  ServerHello;
       case certificate:Certificate;
       case server_key_exchange: ServerKeyExchange;
       case certificate_request: CertificateRequest;
       case server_hello_done:ServerHelloDone;
       case certificate_verify:  CertificateVerify;
       case client_key_exchange: ClientKeyExchange;
       case finished: Finished;
     } body;
   } Handshake;
]]></artwork></figure>

<t>The first message each side transmits in each handshake always has
   message_seq = 0.  Whenever each new message is generated, the
   message_seq value is incremented by one.  Note that in the case of a
   rehandshake, this implies that the HelloRequest will have message_seq
   = 0 and the ServerHello will have message_seq = 1.  When a message is
   retransmitted, the same message_seq value is used.  For example:</t>

<figure><artwork><![CDATA[
     Client                             Server
     ------                             ------
     ClientHello (seq=0)  ------>

                             X<-- HelloVerifyRequest (seq=0)
                                             (lost)

     [Timer Expires]

     ClientHello (seq=0)  ------>
     (retransmit)

                          <------ HelloVerifyRequest (seq=0)

     ClientHello (seq=1)  ------>
     (with cookie)

                          <------        ServerHello (seq=1)
                          <------        Certificate (seq=2)
                          <------    ServerHelloDone (seq=3)

     [Rest of handshake]
]]></artwork></figure>

<t>Note, however, that from the perspective of the DTLS record layer,
   the retransmission is a new record.  This record will have a new
   DTLSPlaintext.sequence_number value.</t>

<t>DTLS implementations maintain (at least notionally) a
   next_receive_seq counter.  This counter is initially set to zero.
   When a message is received, if its sequence number matches
   next_receive_seq, next_receive_seq is incremented and the message is
   processed.  If the sequence number is less than next_receive_seq, the
   message MUST be discarded.  If the sequence number is greater than
   next_receive_seq, the implementation SHOULD queue the message but MAY
   discard it.  (This is a simple space/bandwidth tradeoff).</t>

</section>
<section anchor="handshake-message-fragmentation-and-reassembly" title="Handshake Message Fragmentation and Reassembly">

<t>As noted in Section 4.1.1, each DTLS message MUST fit within a single
   transport layer datagram.  However, handshake messages are
   potentially bigger than the maximum record size.  Therefore, DTLS
   provides a mechanism for fragmenting a handshake message over a
   number of records, each of which can be transmitted separately, thus
   avoiding IP fragmentation.</t>

<t>When transmitting the handshake message, the sender divides the
   message into a series of N contiguous data ranges.  These ranges MUST
   NOT be larger than the maximum handshake fragment size and MUST
   jointly contain the entire handshake message.  The ranges SHOULD NOT
   overlap.  The sender then creates N handshake messages, all with the
   same message_seq value as the original handshake message.  Each new
   message is labeled with the fragment_offset (the number of bytes
   contained in previous fragments) and the fragment_length (the length
   of this fragment).  The length field in all messages is the same as
   the length field of the original message.  An unfragmented message is
   a degenerate case with fragment_offset=0 and fragment_length=length.</t>

<t>When a DTLS implementation receives a handshake message fragment, it
   MUST buffer it until it has the entire handshake message.  DTLS
   implementations MUST be able to handle overlapping fragment ranges.
   This allows senders to retransmit handshake messages with smaller
   fragment sizes if the PMTU estimate changes.</t>

<t>Note that as with TLS, multiple handshake messages may be placed in
   the same DTLS record, provided that there is room and that they are
   part of the same flight.  Thus, there are two acceptable ways to pack
   two DTLS messages into the same datagram: in the same record or in
   separate records.</t>

</section>
<section anchor="timeout-and-retransmission" title="Timeout and Retransmission">

<t>DTLS messages are grouped into a series of message flights, according
   to the diagrams below.  Although each flight of messages may consist
   of a number of messages, they should be viewed as monolithic for the
   purpose of timeout and retransmission.</t>

<figure title="Message Flights for Full Handshake" anchor="figure-1"><artwork><![CDATA[
   Client                                          Server
   ------                                          ------

   ClientHello             -------->                           Flight 1

                           <-------    HelloVerifyRequest      Flight 2

   ClientHello             -------->                           Flight 3

                                              ServerHello    \
                                             Certificate*     \
                                       ServerKeyExchange*      Flight 4
                                      CertificateRequest*     /
                           <--------      ServerHelloDone    /

   Certificate*                                              \
   ClientKeyExchange                                          \
   CertificateVerify*                                          Flight 5
   [ChangeCipherSpec]                                         /
   Finished                -------->                         /

                                       [ChangeCipherSpec]    \ Flight 6
                           <--------             Finished    /
]]></artwork></figure>

<figure title="Message Flights for Session-Resuming Handshake  (No Cookie Exchange)" anchor="figure-2"><artwork><![CDATA[
   Client                                           Server
   ------                                           ------

   ClientHello             -------->                          Flight 1

                                              ServerHello    \
                                       [ChangeCipherSpec]     Flight 2
                            <--------             Finished    /

   [ChangeCipherSpec]                                         \Flight 3
   Finished                 -------->                         /
]]></artwork></figure>

<t>DTLS uses a simple timeout and retransmission scheme with the
   following state machine.  Because DTLS clients send the first message
   (ClientHello), they start in the PREPARING state.  DTLS servers start
   in the WAITING state, but with empty buffers and no retransmit timer.</t>

<figure title="DTLS Timeout and Retransmission State Machine" anchor="figure-3"><artwork><![CDATA[
                      +-----------+
                      | PREPARING |
                +---> |           | <--------------------+
                |     |           |                      |
                |     +-----------+                      |
                |           |                            |
                |           | Buffer next flight         |
                |           |                            |
                |          \|/                           |
                |     +-----------+                      |
                |     |           |                      |
                |     |  SENDING  |<------------------+  |
                |     |           |                   |  | Send
                |     +-----------+                   |  | HelloRequest
        Receive |           |                         |  |
           next |           | Send flight             |  | or
         flight |  +--------+                         |  |
                |  |        | Set retransmit timer    |  | Receive
                |  |       \|/                        |  | HelloRequest
                |  |  +-----------+                   |  | Send
                |  |  |           |                   |  | ClientHello
                +--)--|  WAITING  |-------------------+  |
                |  |  |           |   Timer expires   |  |
                |  |  +-----------+                   |  |
                |  |         |                        |  |
                |  |         |                        |  |
                |  |         +------------------------+  |
                |  |                Read retransmit      |
        Receive |  |                                     |
           last |  |                                     |
         flight |  |                                     |
                |  |                                     |
               \|/\|/                                    |
                                                         |
            +-----------+                                |
            |           |                                |
            | FINISHED  | -------------------------------+
            |           |
            +-----------+
                 |  /|\
                 |   |
                 |   |
                 +---+

              Read retransmit
           Retransmit last flight
]]></artwork></figure>

<t>The state machine has three basic states.</t>

<t>In the PREPARING state, the implementation does whatever computations
   are necessary to prepare the next flight of messages.  It then
   buffers them up for transmission (emptying the buffer first) and
   enters the SENDING state.</t>

<t>In the SENDING state, the implementation transmits the buffered
   flight of messages.  Once the messages have been sent, the
   implementation then enters the FINISHED state if this is the last
   flight in the handshake.  Or, if the implementation expects to
   receive more messages, it sets a retransmit timer and then enters the
   WAITING state.</t>

<t>There are three ways to exit the WAITING state:</t>

<t><list style="numbers">
  <t>The retransmit timer expires: the implementation transitions to
the SENDING state, where it retransmits the flight, resets the
retransmit timer, and returns to the WAITING state.</t>
  <t>The implementation reads a retransmitted flight from the peer: the
implementation transitions to the SENDING state, where it
retransmits the flight, resets the retransmit timer, and returns
to the WAITING state.  The rationale here is that the receipt of a
duplicate message is the likely result of timer expiry on the peer
and therefore suggests that part of one’s previous flight was
lost.</t>
  <t>The implementation receives the next flight of messages: if this
is the final flight of messages, the implementation transitions to
FINISHED.  If the implementation needs to send a new flight, it
transitions to the PREPARING state.  Partial reads (whether
partial messages or only some of the messages in the flight) do
not cause state transitions or timer resets.</t>
</list></t>

<t>Because DTLS clients send the first message (ClientHello), they start
   in the PREPARING state.  DTLS servers start in the WAITING state, but
   with empty buffers and no retransmit timer.</t>

<t>When the server desires a rehandshake, it transitions from the
   FINISHED state to the PREPARING state to transmit the HelloRequest.
   When the client receives a HelloRequest, it transitions from FINISHED
   to PREPARING to transmit the ClientHello.</t>

<t>In addition, for at least twice the default MSL defined for [TCP],
   when in the FINISHED state, the node that transmits the last flight
   (the server in an ordinary handshake or the client in a resumed
   handshake) MUST respond to a retransmit of the peer’s last flight</t>

<t>with a retransmit of the last flight.  This avoids deadlock
   conditions if the last flight gets lost.  This requirement applies to
   DTLS 1.0 as well, and though not explicit in [DTLS1], it was always
   required for the state machine to function correctly.  To see why
   this is necessary, consider what happens in an ordinary handshake if
   the server’s Finished message is lost: the server believes the
   handshake is complete but it actually is not.  As the client is
   waiting for the Finished message, the client’s retransmit timer will
   fire and it will retransmit the client’s Finished message.  This will
   cause the server to respond with its own Finished message, completing
   the handshake.  The same logic applies on the server side for the
   resumed handshake.</t>

<t>Note that because of packet loss, it is possible for one side to be
   sending application data even though the other side has not received
   the first side’s Finished message.  Implementations MUST either
   discard or buffer all application data packets for the new epoch
   until they have received the Finished message for that epoch.
   Implementations MAY treat receipt of application data with a new
   epoch prior to receipt of the corresponding Finished message as
   evidence of reordering or packet loss and retransmit their final
   flight immediately, shortcutting the retransmission timer.</t>

<section anchor="timer-values" title="Timer Values">

<t>Though timer values are the choice of the implementation, mishandling
   of the timer can lead to serious congestion problems; for example, if
   many instances of a DTLS time out early and retransmit too quickly on
   a congested link.  Implementations SHOULD use an initial timer value
   of 1 second (the minimum defined in RFC 6298 <xref target="RFC6298"></xref>) and double
   the value at each retransmission, up to no less than the RFC 6298
   maximum of 60 seconds.  Note that we recommend a 1-second timer
   rather than the 3-second RFC 6298 default in order to improve latency
   for time-sensitive applications.  Because DTLS only uses
   retransmission for handshake and not dataflow, the effect on
   congestion should be minimal.</t>

<t>Implementations SHOULD retain the current timer value until a
   transmission without loss occurs, at which time the value may be
   reset to the initial value.  After a long period of idleness, no less
   than 10 times the current timer value, implementations may reset the
   timer to the initial value.  One situation where this might occur is
   when a rehandshake is used after substantial data transfer.</t>

</section>
</section>
<section anchor="changecipherspec" title="ChangeCipherSpec">

<t>As with TLS, the ChangeCipherSpec message is not technically a
   handshake message but MUST be treated as part of the same flight as
   the associated Finished message for the purposes of timeout and
   retransmission.  This creates a potential ambiguity because the order
   of the ChangeCipherSpec cannot be established unambiguously with
   respect to the handshake messages in case of message loss.</t>

<t>This is not a problem with any current TLS mode because the expected
   set of handshake messages logically preceeding the ChangeCipherSpec
   is predictable from the rest of the handshake state.  However, future
   modes MUST take care to avoid creating ambiguity.</t>

</section>
<section anchor="certificateverify-and-finished-messages" title="CertificateVerify and Finished Messages">

<t>CertificateVerify and Finished messages have the same format as in
   TLS.  Hash calculations include entire handshake messages, including
   DTLS-specific fields: message_seq, fragment_offset, and
   fragment_length.  However, in order to remove sensitivity to
   handshake message fragmentation, the Finished MAC MUST be computed as
   if each handshake message had been sent as a single fragment.  Note
   that in cases where the cookie exchange is used, the initial
   ClientHello and HelloVerifyRequest MUST NOT be included in the
   CertificateVerify or Finished MAC computations.</t>

</section>
<section anchor="alert-messages" title="Alert Messages">

<t>Note that Alert messages are not retransmitted at all, even when they
   occur in the context of a handshake.  However, a DTLS implementation
   which would ordinarily issue an alert SHOULD generate a new alert
   message if the offending record is received again (e.g., as a
   retransmitted handshake message).  Implementations SHOULD detect when
   a peer is persistently sending bad messages and terminate the local
   connection state after such misbehavior is detected.</t>

</section>
<section anchor="establishing-new-associations-with-existing-parameters" title="Establishing New Associations with Existing Parameters">

<t>If a DTLS client-server pair is configured in such a way that
   repeated connections happen on the same host/port quartet, then it is
   possible that a client will silently abandon one connection and then
   initiate another with the same parameters (e.g., after a reboot).
   This will appear to the server as a new handshake with epoch=0.  In
   cases where a server believes it has an existing association on a
   given host/port quartet and it receives an epoch=0 ClientHello, it
   SHOULD proceed with a new handshake but MUST NOT destroy the existing
   association until the client has demonstrated reachability either by
   completing a cookie exchange or by completing a complete handshake
   including delivering a verifiable Finished message.  After a correct
   Finished message is received, the server MUST abandon the previous
   association to avoid confusion between two valid associations with
   overlapping epochs.  The reachability requirement prevents
   off-path/blind attackers from destroying associations merely by
   sending forged ClientHellos.</t>

</section>
</section>
<section anchor="summary-of-new-syntax" title="Summary of New Syntax">

<t>This section includes specifications for the data structures that
   have changed between TLS 1.2 and DTLS 1.2. See [TLS12] for the
   definition of this syntax.</t>

<section anchor="record-layer-1" title="Record Layer">

<figure><artwork><![CDATA[
   struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;                                     // New field
        uint48 sequence_number;                           // New field
        uint16 length;
        opaque fragment[DTLSPlaintext.length];
      } DTLSPlaintext;

      struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;                                     // New field
        uint48 sequence_number;                           // New field
        uint16 length;
        opaque fragment[DTLSCompressed.length];
      } DTLSCompressed;

      struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;                                     // New field
        uint48 sequence_number;                           // New field
        uint16 length;
        select (CipherSpec.cipher_type) {
          case block:  GenericBlockCipher;
          case aead:   GenericAEADCipher;                 // New field
        } fragment;
      } DTLSCiphertext;
]]></artwork></figure>

</section>
<section anchor="handshake-protocol" title="Handshake Protocol">

<figure><artwork><![CDATA[
   enum {
     hello_request(0), client_hello(1), server_hello(2),
     hello_verify_request(3),                          // New field
     certificate(11), server_key_exchange (12),
     certificate_request(13), server_hello_done(14),
     certificate_verify(15), client_key_exchange(16),
     finished(20), (255) } HandshakeType;

   struct {
     HandshakeType msg_type;
     uint24 length;
     uint16 message_seq;                               // New field
     uint24 fragment_offset;                           // New field
     uint24 fragment_length;                           // New field
     select (HandshakeType) {
       case hello_request: HelloRequest;
       case client_hello:  ClientHello;
       case server_hello:  ServerHello;
       case hello_verify_request: HelloVerifyRequest;  // New field
       case certificate:Certificate;
       case server_key_exchange: ServerKeyExchange;
       case certificate_request: CertificateRequest;
       case server_hello_done:ServerHelloDone;
       case certificate_verify:  CertificateVerify;
       case client_key_exchange: ClientKeyExchange;
       case finished: Finished;
     } body; } Handshake;

   struct {
     ProtocolVersion client_version;
     Random random;
     SessionID session_id;
     opaque cookie<0..2^8-1>;                             // New field
     CipherSuite cipher_suites<2..2^16-1>;
     CompressionMethod compression_methods<1..2^8-1>; } ClientHello;

   struct {
     ProtocolVersion server_version;
     opaque cookie<0..2^8-1>; } HelloVerifyRequest;
]]></artwork></figure>

</section>
</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This document describes a variant of TLS 1.2; therefore, most of the
   security considerations are the same as those of TLS 1.2 [TLS12],
   described in Appendices D, E, and F.</t>

<t>The primary additional security consideration raised by DTLS is that
   of denial of service.  DTLS includes a cookie exchange designed to
   protect against denial of service.  However, implementations that do
   not use this cookie exchange are still vulnerable to DoS.  In
   particular, DTLS servers that do not use the cookie exchange may be
   used as attack amplifiers even if they themselves are not
   experiencing DoS.  Therefore, DTLS servers SHOULD use the cookie
   exchange unless there is good reason to believe that amplification is
   not a threat in their environment.  Clients MUST be prepared to do a
   cookie exchange with every handshake.</t>

<t>Unlike TLS implementations, DTLS implementations SHOULD NOT respond
   to invalid records by terminating the connection.  See Section
   4.1.2.7 for details on this.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>The authors would like to thank Dan Boneh, Eu-Jin Goh, Russ Housley,
   Constantine Sapuntzakis, and Hovav Shacham for discussions and
   comments on the design of DTLS.  Thanks to the anonymous NDSS
   reviewers of our original NDSS paper on DTLS [DTLS] for their
   comments.  Also, thanks to Steve Kent for feedback that helped
   clarify many points.  The section on PMTU was cribbed from the DCCP
   specification [DCCP].  Pasi Eronen provided a detailed review of this
   specification.  Peter Saint-Andre provided the list of changes in
   Section 8.  Helpful comments on the document were also received from
   Mark Allman, Jari Arkko, Mohamed Badra, Michael D’Errico, Adrian
   Farrell, Joel Halpern, Ted Hardie, Charlia Kaufman, Pekka Savola,
   Allison Mankin, Nikos Mavrogiannopoulos, Alexey Melnikov, Robin
   Seggelmann, Michael Tuexen, Juho Vaha-Herttua, and Florian Weimer.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document uses the same identifier space as TLS [TLS12], so no
   new IANA registries are required.  When new identifiers are assigned
   for TLS, authors MUST specify whether they are suitable for DTLS.
   IANA has modified all TLS parameter registries to add a DTLS-OK flag,
   indicating whether the specification may be used with DTLS.  At the
   time of publication, all of the [TLS12] registrations except the
   following are suitable for DTLS.  The full table of registrations is
   available at [IANA].</t>

<t>From the TLS Cipher Suite Registry:</t>

<figure><artwork><![CDATA[
  0x00,0x03 TLS_RSA_EXPORT_WITH_RC4_40_MD5        [RFC4346]
  0x00,0x04 TLS_RSA_WITH_RC4_128_MD5              [RFC5246]
  0x00,0x05 TLS_RSA_WITH_RC4_128_SHA              [RFC5246]
  0x00,0x17 TLS_DH_anon_EXPORT_WITH_RC4_40_MD5    [RFC4346]
  0x00,0x18 TLS_DH_anon_WITH_RC4_128_MD5          [RFC5246]
  0x00,0x20 TLS_KRB5_WITH_RC4_128_SHA             [RFC2712]
  0x00,0x24 TLS_KRB5_WITH_RC4_128_MD5             [RFC2712]
  0x00,0x28 TLS_KRB5_EXPORT_WITH_RC4_40_SHA       [RFC2712]
  0x00,0x2B TLS_KRB5_EXPORT_WITH_RC4_40_MD5       [RFC2712]
  0x00,0x8A TLS_PSK_WITH_RC4_128_SHA              [RFC4279]
  0x00,0x8E TLS_DHE_PSK_WITH_RC4_128_SHA          [RFC4279]
  0x00,0x92 TLS_RSA_PSK_WITH_RC4_128_SHA          [RFC4279]
  0xC0,0x02 TLS_ECDH_ECDSA_WITH_RC4_128_SHA       [RFC4492]
  0xC0,0x07 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA      [RFC4492]
  0xC0,0x0C TLS_ECDH_RSA_WITH_RC4_128_SHA         [RFC4492]
  0xC0,0x11 TLS_ECDHE_RSA_WITH_RC4_128_SHA        [RFC4492]
  0xC0,0x16 TLS_ECDH_anon_WITH_RC4_128_SHA        [RFC4492]
  0xC0,0x33 TLS_ECDHE_PSK_WITH_RC4_128_SHA        [RFC5489]
]]></artwork></figure>

<t>From the TLS Exporter Label Registry:</t>

<figure><artwork><![CDATA[
  client EAP encryption       [RFC5216]
  ttls   keying material      [RFC5281]
  ttls   challenge            [RFC5281]
]]></artwork></figure>

<t>This document defines a new handshake message, hello_verify_request,
   whose value has been allocated from the TLS HandshakeType registry
   defined in [TLS12].  The value “3” has been assigned by the IANA.</t>

</section>
<section anchor="changes-since-dtls-10" title="Changes since DTLS 1.0">

<t>This document reflects the following changes since DTLS 1.0 [DTLS1].</t>

<t><list style="symbols">
  <t>Updated to match TLS 1.2 [TLS12].</t>
  <t>Addition of AEAD Ciphers in Section 4.1.2.3 (tracking changes in
TLS 1.2.</t>
  <t>Clarifications regarding sequence numbers and epochs in Section
4.1 and a clear procedure for dealing with state loss in Section
4.2.8.</t>
  <t>Clarifications and more detailed rules regarding Path MTU issues
in Section 4.1.1.1. Clarification of the fragmentation text
throughout.</t>
  <t>Clarifications regarding handling of invalid records in Section
4.1.2.7.</t>
  <t>A new paragraph describing handling of invalid cookies at the end
of Section 4.2.1.</t>
  <t>Some new text describing how to avoid handshake deadlock
conditions at the end of Section 4.2.4.</t>
  <t>Some new text about CertificateVerify messages in Section 4.2.6.</t>
  <t>A prohibition on epoch wrapping in Section 4.1.</t>
  <t>Clarification of the IANA requirements and the explicit
requirement for a new IANA registration flag for each parameter.</t>
  <t>Added a record sequence number mirroring technique for handling
repeated ClientHello messages.</t>
  <t>Recommend a fixed version number for HelloVerifyRequest.</t>
  <t>Numerous editorial changes.</t>
</list></t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC1191' target='http://www.rfc-editor.org/info/rfc1191'>
<front>
<title>Path MTU discovery</title>
<author initials='J.C.' surname='Mogul' fullname='J.C. Mogul'><organization /></author>
<author initials='S.E.' surname='Deering' fullname='S.E. Deering'><organization /></author>
<date year='1990' month='November' />
<abstract><t>This memo describes a technique for dynamically discovering the maximum transmission unit (MTU) of an arbitrary internet path.  It specifies a small change to the way routers generate one type of ICMP message.  For a path that passes through a router that has not been so changed, this technique might not discover the correct Path MTU, but it will always choose a Path MTU as accurate as, and in many cases more accurate than, the Path MTU that would be chosen by current practice.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='1191'/>
<seriesInfo name='DOI' value='10.17487/RFC1191'/>
</reference>



<reference  anchor='RFC4301' target='http://www.rfc-editor.org/info/rfc4301'>
<front>
<title>Security Architecture for the Internet Protocol</title>
<author initials='S.' surname='Kent' fullname='S. Kent'><organization /></author>
<author initials='K.' surname='Seo' fullname='K. Seo'><organization /></author>
<date year='2005' month='December' />
<abstract><t>This document describes an updated version of the &quot;Security Architecture for IP&quot;, which is designed to provide security services for traffic at the IP layer.  This document obsoletes RFC 2401 (November 1998).  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4301'/>
<seriesInfo name='DOI' value='10.17487/RFC4301'/>
</reference>



<reference  anchor='RFC4443' target='http://www.rfc-editor.org/info/rfc4443'>
<front>
<title>Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</title>
<author initials='A.' surname='Conta' fullname='A. Conta'><organization /></author>
<author initials='S.' surname='Deering' fullname='S. Deering'><organization /></author>
<author initials='M.' surname='Gupta' fullname='M. Gupta' role='editor'><organization /></author>
<date year='2006' month='March' />
<abstract><t>This document describes the format of a set of control messages used in ICMPv6 (Internet Control Message Protocol).  ICMPv6 is the Internet Control Message Protocol for Internet Protocol version 6 (IPv6).  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4443'/>
<seriesInfo name='DOI' value='10.17487/RFC4443'/>
</reference>



<reference  anchor='RFC4821' target='http://www.rfc-editor.org/info/rfc4821'>
<front>
<title>Packetization Layer Path MTU Discovery</title>
<author initials='M.' surname='Mathis' fullname='M. Mathis'><organization /></author>
<author initials='J.' surname='Heffner' fullname='J. Heffner'><organization /></author>
<date year='2007' month='March' />
<abstract><t>This document describes a robust method for Path MTU Discovery (PMTUD) that relies on TCP or some other Packetization Layer to probe an Internet path with progressively larger packets.  This method is described as an extension to RFC 1191 and RFC 1981, which specify ICMP-based Path MTU Discovery for IP versions 4 and 6, respectively.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4821'/>
<seriesInfo name='DOI' value='10.17487/RFC4821'/>
</reference>



<reference  anchor='RFC6298' target='http://www.rfc-editor.org/info/rfc6298'>
<front>
<title>Computing TCP's Retransmission Timer</title>
<author initials='V.' surname='Paxson' fullname='V. Paxson'><organization /></author>
<author initials='M.' surname='Allman' fullname='M. Allman'><organization /></author>
<author initials='J.' surname='Chu' fullname='J. Chu'><organization /></author>
<author initials='M.' surname='Sargent' fullname='M. Sargent'><organization /></author>
<date year='2011' month='June' />
<abstract><t>This document defines the standard algorithm that Transmission Control Protocol (TCP) senders are required to use to compute and manage their retransmission timer.  It expands on the discussion in Section 4.2.3.1 of RFC 1122 and upgrades the requirement of supporting the algorithm from a SHOULD to a MUST.  This document obsoletes RFC 2988.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6298'/>
<seriesInfo name='DOI' value='10.17487/RFC6298'/>
</reference>



<reference  anchor='RFC5288' target='http://www.rfc-editor.org/info/rfc5288'>
<front>
<title>AES Galois Counter Mode (GCM) Cipher Suites for TLS</title>
<author initials='J.' surname='Salowey' fullname='J. Salowey'><organization /></author>
<author initials='A.' surname='Choudhury' fullname='A. Choudhury'><organization /></author>
<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This memo describes the use of the Advanced Encryption Standard (AES) in Galois/Counter Mode (GCM) as a Transport Layer Security (TLS) authenticated encryption operation.  GCM provides both confidentiality and data origin authentication, can be efficiently implemented in hardware for speeds of 10 gigabits per second and above, and is also well-suited to software implementations.  This memo defines TLS cipher suites that use AES-GCM with RSA, DSA, and Diffie-Hellman-based key exchange mechanisms.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5288'/>
<seriesInfo name='DOI' value='10.17487/RFC5288'/>
</reference>



<reference  anchor='RFC5246' target='http://www.rfc-editor.org/info/rfc5246'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5246'/>
<seriesInfo name='DOI' value='10.17487/RFC5246'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor='RFC4340' target='http://www.rfc-editor.org/info/rfc4340'>
<front>
<title>Datagram Congestion Control Protocol (DCCP)</title>
<author initials='E.' surname='Kohler' fullname='E. Kohler'><organization /></author>
<author initials='M.' surname='Handley' fullname='M. Handley'><organization /></author>
<author initials='S.' surname='Floyd' fullname='S. Floyd'><organization /></author>
<date year='2006' month='March' />
<abstract><t>The Datagram Congestion Control Protocol (DCCP) is a transport protocol that provides bidirectional unicast connections of congestion-controlled unreliable datagrams.  DCCP is suitable for applications that transfer fairly large amounts of data and that can benefit from control over the tradeoff between timeliness and reliability.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4340'/>
<seriesInfo name='DOI' value='10.17487/RFC4340'/>
</reference>



<reference  anchor='RFC5238' target='http://www.rfc-editor.org/info/rfc5238'>
<front>
<title>Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP)</title>
<author initials='T.' surname='Phelan' fullname='T. Phelan'><organization /></author>
<date year='2008' month='May' />
<abstract><t>This document specifies the use of Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP).  DTLS provides communications privacy for applications that use datagram transport protocols and allows client/server applications to communicate in a way that is designed to prevent eavesdropping and detect tampering or message forgery.  DCCP is a transport protocol that provides a congestion-controlled unreliable datagram service.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5238'/>
<seriesInfo name='DOI' value='10.17487/RFC5238'/>
</reference>



<reference  anchor='RFC4347' target='http://www.rfc-editor.org/info/rfc4347'>
<front>
<title>Datagram Transport Layer Security</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='N.' surname='Modadugu' fullname='N. Modadugu'><organization /></author>
<date year='2006' month='April' />
<abstract><t>This document specifies Version 1.0 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4347'/>
<seriesInfo name='DOI' value='10.17487/RFC4347'/>
</reference>



<reference  anchor='RFC5289' target='http://www.rfc-editor.org/info/rfc5289'>
<front>
<title>TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>RFC 4492 describes elliptic curve cipher suites for Transport Layer Security (TLS).  However, all those cipher suites use HMAC-SHA-1 as their Message Authentication Code (MAC) algorithm.  This document describes sixteen new cipher suites for TLS that specify stronger MAC algorithms.  Eight use Hashed Message Authentication Code (HMAC) with SHA-256 or SHA-384, and eight use AES in Galois Counter Mode (GCM).   This memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='5289'/>
<seriesInfo name='DOI' value='10.17487/RFC5289'/>
</reference>



<reference  anchor='RFC4303' target='http://www.rfc-editor.org/info/rfc4303'>
<front>
<title>IP Encapsulating Security Payload (ESP)</title>
<author initials='S.' surname='Kent' fullname='S. Kent'><organization /></author>
<date year='2005' month='December' />
<abstract><t>This document describes an updated version of the Encapsulating Security Payload (ESP) protocol, which is designed to provide a mix of security services in IPv4 and IPv6.  ESP is used to provide confidentiality, data origin authentication, connectionless integrity, an anti-replay service (a form of partial sequence integrity), and limited traffic flow confidentiality.  This document obsoletes RFC 2406 (November 1998).  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4303'/>
<seriesInfo name='DOI' value='10.17487/RFC4303'/>
</reference>



<reference  anchor='RFC5996' target='http://www.rfc-editor.org/info/rfc5996'>
<front>
<title>Internet Key Exchange Protocol Version 2 (IKEv2)</title>
<author initials='C.' surname='Kaufman' fullname='C. Kaufman'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<author initials='Y.' surname='Nir' fullname='Y. Nir'><organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'><organization /></author>
<date year='2010' month='September' />
<abstract><t>This document describes version 2 of the Internet Key Exchange (IKE) protocol.  IKE is a component of IPsec used for performing mutual authentication and establishing and maintaining Security Associations (SAs).  This document replaces and updates RFC 4306, and includes all of the clarifications from RFC 4718.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5996'/>
<seriesInfo name='DOI' value='10.17487/RFC5996'/>
</reference>



<reference  anchor='RFC3501' target='http://www.rfc-editor.org/info/rfc3501'>
<front>
<title>INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1</title>
<author initials='M.' surname='Crispin' fullname='M. Crispin'><organization /></author>
<date year='2003' month='March' />
<abstract><t>The Internet Message Access Protocol, Version 4rev1 (IMAP4rev1) allows a client to access and manipulate electronic mail messages on a server. IMAP4rev1 permits manipulation of mailboxes (remote message folders) in a way that is functionally equivalent to local folders.  IMAP4rev1 also provides the capability for an offline client to resynchronize with the server. IMAP4rev1 includes operations for creating, deleting, and renaming mailboxes, checking for new messages, permanently removing messages, setting and clearing flags, RFC 2822 and RFC 2045 parsing, searching, and selective fetching of message attributes, texts, and portions thereof.  Messages in IMAP4rev1 are accessed by the use of numbers. These numbers are either message sequence numbers or unique identifiers. IMAP4rev1 supports a single server.  A mechanism for accessing configuration information to support multiple IMAP4rev1 servers is discussed in RFC 2244. IMAP4rev1 does not specify a means of posting mail; this function is handled by a mail transfer protocol such as RFC 2821.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='3501'/>
<seriesInfo name='DOI' value='10.17487/RFC3501'/>
</reference>



<reference  anchor='RFC2522' target='http://www.rfc-editor.org/info/rfc2522'>
<front>
<title>Photuris: Session-Key Management Protocol</title>
<author initials='P.' surname='Karn' fullname='P. Karn'><organization /></author>
<author initials='W.' surname='Simpson' fullname='W. Simpson'><organization /></author>
<date year='1999' month='March' />
<abstract><t>This document defines the basic protocol mechanisms. This document defines an Experimental Protocol for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='2522'/>
<seriesInfo name='DOI' value='10.17487/RFC2522'/>
</reference>



<reference  anchor='RFC1939' target='http://www.rfc-editor.org/info/rfc1939'>
<front>
<title>Post Office Protocol - Version 3</title>
<author initials='J.' surname='Myers' fullname='J. Myers'><organization /></author>
<author initials='M.' surname='Rose' fullname='M. Rose'><organization /></author>
<date year='1996' month='May' />
<abstract><t>The Post Office Protocol - Version 3 (POP3) is intended to permit a workstation to dynamically access a maildrop on a server host in a useful fashion.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='53'/>
<seriesInfo name='RFC' value='1939'/>
<seriesInfo name='DOI' value='10.17487/RFC1939'/>
</reference>



<reference  anchor='RFC3261' target='http://www.rfc-editor.org/info/rfc3261'>
<front>
<title>SIP: Session Initiation Protocol</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'><organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'><organization /></author>
<author initials='G.' surname='Camarillo' fullname='G. Camarillo'><organization /></author>
<author initials='A.' surname='Johnston' fullname='A. Johnston'><organization /></author>
<author initials='J.' surname='Peterson' fullname='J. Peterson'><organization /></author>
<author initials='R.' surname='Sparks' fullname='R. Sparks'><organization /></author>
<author initials='M.' surname='Handley' fullname='M. Handley'><organization /></author>
<author initials='E.' surname='Schooler' fullname='E. Schooler'><organization /></author>
<date year='2002' month='June' />
<abstract><t>This document describes Session Initiation Protocol (SIP), an application-layer control (signaling) protocol for creating, modifying, and terminating sessions with one or more participants.  These sessions include Internet telephone calls, multimedia distribution, and multimedia conferences.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='3261'/>
<seriesInfo name='DOI' value='10.17487/RFC3261'/>
</reference>



<reference  anchor='RFC2246' target='http://www.rfc-editor.org/info/rfc2246'>
<front>
<title>The TLS Protocol Version 1.0</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='C.' surname='Allen' fullname='C. Allen'><organization /></author>
<date year='1999' month='January' />
<abstract><t>This document specifies Version 1.0 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications privacy over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='2246'/>
<seriesInfo name='DOI' value='10.17487/RFC2246'/>
</reference>



<reference  anchor='RFC4346' target='http://www.rfc-editor.org/info/rfc4346'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.1</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2006' month='April' />
<abstract><t>This document specifies Version 1.1 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4346'/>
<seriesInfo name='DOI' value='10.17487/RFC4346'/>
</reference>



<reference  anchor='RFC5406' target='http://www.rfc-editor.org/info/rfc5406'>
<front>
<title>Guidelines for Specifying the Use of IPsec Version 2</title>
<author initials='S.' surname='Bellovin' fullname='S. Bellovin'><organization /></author>
<date year='2009' month='February' />
<abstract><t>The Security Considerations sections of many Internet Drafts say, in effect, &quot;just use IPsec&quot;.  While this is sometimes correct, more often it will leave users without real, interoperable security mechanisms.  This memo offers some guidance on when IPsec Version 2 should and should not be specified.  This document specifies an Internet  Best Current Practices for the Internet Community, and requests  discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='146'/>
<seriesInfo name='RFC' value='5406'/>
<seriesInfo name='DOI' value='10.17487/RFC5406'/>
</reference>




    </references>



  </back>
</rfc>

