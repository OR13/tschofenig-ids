<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.32 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="pre5378Trust200902" docName="draft-ietf-tls-dtls13-latest" category="std" obsoletes="6347" updates="4492, 6066, 6961">

  <front>
    <title abbrev="TLS">The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>

    <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
      <organization>RTFM, Inc.</organization>
      <address>
        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <date year="2016" month="August" day="17"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document specifies Version 1.3 of the Datagram Transport Layer Security 
(DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the 
Internet in a way that is designed to prevent eavesdropping, tampering, and message 
forgery.</t>

<t>The DTLS 1.3 protocol is intentionally based on the Transport Layer Security (TLS) 
1.3 protocol and provides equivalent security guarantees.  Datagram semantics of 
the underlying transport are preserved by the DTLS protocol.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>RFC EDITOR: PLEASE REMOVE THE FOLLOWING PARAGRAPH
The source for this draft is maintained in GitHub. Suggested changes
should be submitted as pull requests at https://github.com/tlswg/dtls13-spec. 
Instructions are on that page as well. Editorial changes can be managed in GitHub, 
but any substantive change should be discussed on the TLS mailing list.</t>

<t>The primary goal of the TLS protocol is to provide privacy and data integrity
between two communicating peers. The TLS protocol is composed of two layers:
the TLS Record Protocol and the TLS Handshake Protocol. However, TLS must 
run over a reliable transport channel – typically TCP <xref target="RFC0793"/>.</t>

<t>There are applications that utilize UDP as a transport and to offer communication
security protection for those applications the Datagram Transport Layer
Security (DTLS) protocol has been designed. DTLS is deliberately designed to be 
as similar to TLS as possible, both to minimize new security invention and to
maximize the amount of code and infrastructure reuse.</t>

<t>DTLS 1.0 was originally defined as a delta from TLS 1.1 and DTLS 1.2 was defined 
as a series of deltas to TLS 1.2.  There is no DTLS 1.1; that version number 
was skipped in order to harmonize version numbers with TLS.  This specification 
describes the most current version of the DTLS protocol aligning with the efforts 
around TLS 1.3.</t>

<t>Implementations that speak both DTLS 1.2 and DTLS 1.3 can interoperate with those 
that speak only DTLS 1.2 (using DTLS 1.2 of course), just as TLS 1.3 implementations 
can interoperate with TLS 1.2 (see Appendix C of <xref target="TLS13"/> for details). While 
backwards compatibility with DTLS 1.0 is possible the use of DTLS 1.0 is not 
recommended as explained in Section 3.1.2 of RFC 7525 <xref target="RFC7525"/>.</t>

</section>
<section anchor="conventions-and-terminology" title="Conventions and Terminology">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

<t>The following terms are used:</t>

<t><list style="symbols">
  <t>client: The endpoint initiating the TLS connection.</t>
  <t>connection: A transport-layer connection between two endpoints.</t>
  <t>endpoint: Either the client or server of the connection.</t>
  <t>handshake: An initial negotiation between client and server that establishes 
the parameters of their transactions.</t>
  <t>peer: An endpoint. When discussing a particular endpoint, “peer” refers to 
the endpoint that is remote to the primary subject of discussion.</t>
  <t>receiver: An endpoint that is receiving records.</t>
  <t>sender: An endpoint that is transmitting records.</t>
  <t>session: An association between a client and a server resulting from a handshake.</t>
  <t>server: The endpoint which did not initiate the TLS connection.</t>
</list></t>

<t>The reader is assumed to be familiar with the TLS 1.3 specification since this 
document defined as a delta from TLS 1.3.</t>

</section>
<section anchor="dtls-rational" title="DTLS Design Rational and Overview">

<t>The basic design philosophy of DTLS is to construct “TLS over
   datagram transport”. Datagram transport does not require or provide 
   reliable or in-order delivery of data.  The DTLS protocol preserves 
   this property for
   application data.  Applications such as media streaming, Internet
   telephony, and online gaming use datagram transport for communication
   due to the delay-sensitive nature of transported data.  The behavior
   of such applications is unchanged when the DTLS protocol is used to
   secure communication, since the DTLS protocol does not compensate for
   lost or re-ordered data traffic.</t>

<t>The reason that TLS cannot be used directly in
   datagram environments is simply that payloads may be lost or
   reordered.  Unreliability and reordering creates problems for TLS 
   at three levels:</t>

<t><list style="numbers">
  <t>TLS does not allow independent decryption of individual
      records.  Because the integrity check depends on the sequence
      number, if record N is not received, then the integrity check
      on record N+1 will be based on the wrong sequence number and
      thus will fail. DTLS solves this problem by adding explicit 
      sequence numbers.</t>
  <t>The TLS handshake is a lock-step cryptographic handshake. 
Messages must be transmitted and received in a defined order; any other order
is an error.  Clearly, this is incompatible with reordering and
message loss.  In addition, TLS handshake messages are potentially
larger than any given datagram, thus creating the problem of IP
fragmentation.  DTLS provides fixes for both of these problems, 
as described in the subsections below.</t>
  <t>Not all TLS 1.3 handshake messages (such as the NewSessionTicket message)
are acknowledged. Hence, a new acknowledgement message has to be integrated 
to detect message loss.</t>
</list></t>

<t>The DTLS 1.3 specification changes the way how cookies are exchanged
   compared to DTLS 1.2. DTLS 1.3 re-uses the HelloRetryRequest message
   and conveys the cookie to the client via an extension. The client 
   then uses the same extension to place the cookie into a ClientHello message. 
   DTLS 1.2 on the other hand used a separate message, namely the HelloVerifyRequest, 
   to pass a cookie to the client and did not utilize the extension mechanism. 
   For backwards compatibility reason the cookie field in the ClientHello
   is present in DTLS 1.3 but is ignored by a DTLS 1.3 compliant server 
   implementation.</t>

<section anchor="packet-loss" title="Packet Loss">

<t>DTLS uses a simple retransmission timer to handle packet loss. 
{{dtls-retransmission} demonstrates the basic concept, using the first
phase of the DTLS handshake:</t>

<figure title="DTLS Retransmission Example." anchor="dtls-retransmission"><artwork><![CDATA[
         Client                                   Server
         ------                                   ------
         ClientHello           ------>

                                 X<-- HelloRetryRequest
                                                  (lost)

         [Timer Expires]

         ClientHello           ------>
         (retransmit)
]]></artwork></figure>

<t>Once the client has transmitted the ClientHello message, it expects
   to see a HelloRetryRequest from the server.  However, if the
   server’s message is lost, the client knows that either the
   ClientHello or the HelloRetryRequest has been lost and retransmits.
   When the server receives the retransmission, it knows to retransmit.</t>

<t>The server also maintains a retransmission timer and retransmits when
   that timer expires.</t>

<t>Note that timeout and retransmission do not apply to the
   HelloRetryRequest since this would require creating state on the
   server.  The HelloRetryRequest is designed to be small enough that
   it will not itself be fragmented, thus avoiding concerns about
   interleaving multiple HelloRetryRequests.</t>

<section anchor="reordering" title="Reordering">

<t>In DTLS, each handshake message is assigned a specific sequence
   number within that handshake.  When a peer receives a handshake
   message, it can quickly determine whether that message is the next
   message it expects.  If it is, then it processes it.  If not, it
   queues it for future handling once all previous messages have been
   received.</t>

</section>
<section anchor="message-size" title="Message Size">

<t>TLS and DTLS handshake messages can be quite large (in theory up to
   2^24-1 bytes, in practice many kilobytes).  By contrast, UDP
   datagrams are often limited to &lt;1500 bytes if IP fragmentation is not
   desired.  In order to compensate for this limitation, each DTLS
   handshake message may be fragmented over several DTLS records, each
   of which is intended to fit in a single IP datagram.  Each DTLS
   handshake message contains both a fragment offset and a fragment
   length.  Thus, a recipient in possession of all bytes of a handshake
   message can reassemble the original unfragmented message.</t>

</section>
</section>
<section anchor="replay-detection" title="Replay Detection">

<t>DTLS optionally supports record replay detection.  The technique used
   is the same as in IPsec AH/ESP, by maintaining a bitmap window of
   received records.  Records that are too old to fit in the window and
   records that have previously been received are silently discarded.
   The replay detection feature is optional, since packet duplication is
   not always malicious, but can also occur due to routing errors.
   Applications may conceivably detect duplicate packets and accordingly
   modify their data transmission strategy.</t>

</section>
</section>
<section anchor="the-dtls-record-layer" title="The DTLS Record Layer">

<t>The DTLS record layer is extremely similar to that of TLS 1.3.  The
only change is the inclusion of an explicit epoch and sequence number 
in the record.  This sequence number allows the recipient to correctly
verify the TLS MAC.  The DTLS record format is shown below:</t>

<figure><artwork><![CDATA[
  struct {
       ContentType type;
       ProtocolVersion version = { 254, 253 };
       uint16 epoch;                         // DTLS-related field
       uint48 sequence_number;               // DTLS-related field
       uint16 length;
       opaque fragment[DTLSPlaintext.length];
     } DTLSPlaintext;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='type'>
  Identical to the type field in a TLS 1.3 record.</t>
  <t hangText='version'>
  This specification re-uses the DTLS version 1.2 version number, namely
{ 254, 253 }. This field is deprecated and MUST be ignored for all purposes.</t>
  <t hangText='epoch'>
  A counter value that is incremented on every cipher state change.</t>
  <t hangText='sequence_number'>
  The sequence number for this record.</t>
  <t hangText='length'>
  Identical to the length field in a TLS 1.3 record.</t>
  <t hangText='fragment'>
  Identical to the fragment field in a TLS 1.3 record.

DTLS uses an explicit sequence number, rather than an implicit one,
 carried in the sequence_number field of the record.  Sequence numbers
 are maintained separately for each epoch, with each sequence_number
 initially being 0 for each epoch.  For instance, if a handshake
 message from epoch 0 is retransmitted, it might have a sequence
 number after a message from epoch 1, even if the message from epoch 1
 was transmitted first.  Note that some care needs to be taken during
 the handshake to ensure that retransmitted messages use the right
 epoch and keying material.
If several handshakes are performed in close succession, there might
 be multiple records on the wire with the same sequence number but
 from different cipher states.  The epoch field allows recipients to
 distinguish such packets.  The epoch number is initially zero and is
 incremented each time keying material changes and a sender aims to rekey. 
 More details are provided in <xref target="dtls-epoch"/>. In order
 to ensure that any given sequence/epoch pair is unique,
 implementations MUST NOT allow the same epoch value to be reused
 within two times the TCP maximum segment lifetime.
Note that because DTLS records may be reordered, a record from epoch
 1 may be received after epoch 2 has begun.  In general,
 implementations SHOULD discard packets from earlier epochs, but if
 packet loss causes noticeable problems they MAY choose to retain
 keying material from previous epochs for up to the default MSL
 specified for TCP <xref target="TCP"/> to allow for packet reordering.  (Note that
 the intention here is that implementers use the current guidance from
 the IETF for MSL, not that they attempt to interrogate the MSL that
 the system TCP stack is using.)  Until the handshake has completed,
 implementations MUST accept packets from the old epoch.
Conversely, it is possible for records that are protected by the
 newly negotiated context to be received prior to the completion of a
 handshake.  For instance, the server may send its Finished message
 and then start transmitting data.  Implementations MAY either buffer
 or discard such packets, though when DTLS is used over reliable
 transports (e.g., SCTP), they SHOULD be buffered and processed once
 the handshake completes.  Note that TLS’s restrictions on when
 packets may be sent still apply, and the receiver treats the packets
 as if they were sent in the right order.  In particular, it is still
 impermissible to send data prior to completion of the first
 handshake.
As in TLS, implementations MUST either abandon an association or
 re-key using a KeyUpdate message prior to allowing the sequence 
 number to wrap.
Implementations MUST NOT allow the epoch to wrap, but
 instead MUST establish a new association, terminating the old
 association.</t>
</list></t>

<section anchor="transport-layer-mapping" title="Transport Layer Mapping">

<t>Each DTLS record MUST fit within a single datagram.  In order to
   avoid IP fragmentation, clients of the DTLS record layer SHOULD
   attempt to size records so that they fit within any PMTU estimates
   obtained from the record layer.</t>

<t>Note that unlike IPsec, DTLS records do not contain any association
   identifiers.  Applications must arrange to multiplex between
   associations.  With UDP, this is presumably done with the host/port
   number.</t>

<t>Multiple DTLS records may be placed in a single datagram.  They are
   simply encoded consecutively.  The DTLS record framing is sufficient
   to determine the boundaries.  Note, however, that the first byte of
   the datagram payload must be the beginning of a record.  Records may
   not span datagrams.</t>

<t>Some transports, such as DCCP <xref target="RFC4340"/> provide their own sequence
   numbers.  When carried over those transports, both the DTLS and the
   transport sequence numbers will be present.  Although this introduces
   a small amount of inefficiency, the transport layer and DTLS sequence
   numbers serve different purposes; therefore, for conceptual
   simplicity, it is superior to use both sequence numbers.</t>

<t>Some transports provide congestion control for traffic
   carried over them.  If the congestion window is sufficiently narrow,
   DTLS handshake retransmissions may be held rather than transmitted
   immediately, potentially leading to timeouts and spurious
   retransmission.  When DTLS is used over such transports, care should
   be taken not to overrun the likely congestion window. <xref target="RFC5238"/>
   defines a mapping of DTLS to DCCP that takes these issues into
   account.</t>

</section>
<section anchor="pmtu-issues" title="PMTU Issues">

<t>In general, DTLS’s philosophy is to leave PMTU discovery to the
   application.  However, DTLS cannot completely ignore PMTU for three
   reasons:</t>

<t><list style="symbols">
  <t>The DTLS record framing expands the datagram size, thus lowering
the effective PMTU from the application’s perspective.</t>
  <t>In some implementations, the application may not directly talk to
the network, in which case the DTLS stack may absorb ICMP
<xref target="RFC1191"/> “Datagram Too Big” indications or ICMPv6 <xref target="RFC4443"/>
“Packet Too Big” indications.</t>
  <t>The DTLS handshake messages can exceed the PMTU.  <vspace blankLines='1'/>
In order to deal with the first two issues, the DTLS record layer 
SHOULD behave as described below.  <vspace blankLines='1'/>
If PMTU estimates are available from the underlying transport
protocol, they should be made available to upper layer protocols.  In
particular:</t>
  <t>For DTLS over UDP, the upper layer protocol SHOULD be allowed to
obtain the PMTU estimate maintained in the IP layer.</t>
  <t>For DTLS over DCCP, the upper layer protocol SHOULD be allowed to
obtain the current estimate of the PMTU.</t>
  <t>For DTLS over TCP or SCTP, which automatically fragment and
reassemble datagrams, there is no PMTU limitation.  However, the
upper layer protocol MUST NOT write any record that exceeds the
maximum record size of 2^14 bytes.  <vspace blankLines='1'/>
The DTLS record layer SHOULD allow the upper layer protocol to
discover the amount of record expansion expected by the DTLS
processing.  <vspace blankLines='1'/>
If there is a transport protocol indication (either via ICMP or via a
refusal to send the datagram as in Section 14 of <xref target="RFC4340"/>), then the
DTLS record layer MUST inform the upper layer protocol of the error.  <vspace blankLines='1'/>
The DTLS record layer SHOULD NOT interfere with upper layer protocols
performing PMTU discovery, whether via <xref target="RFC1191"/> or <xref target="RFC4821"/>
mechanisms.  In particular:</t>
  <t>Where allowed by the underlying transport protocol, the upper
layer protocol SHOULD be allowed to set the state of the DF bit
(in IPv4) or prohibit local fragmentation (in IPv6).</t>
  <t>If the underlying transport protocol allows the application to
request PMTU probing (e.g., DCCP), the DTLS record layer should
honor this request.  <vspace blankLines='1'/>
The final issue is the DTLS handshake protocol.  From the perspective
of the DTLS record layer, this is merely another upper layer
protocol.  However, DTLS handshakes occur infrequently and involve
only a few round trips; therefore, the handshake protocol PMTU
handling places a premium on rapid completion over accurate PMTU
discovery.  In order to allow connections under these circumstances,
DTLS implementations SHOULD follow the following rules:</t>
  <t>If the DTLS record layer informs the DTLS handshake layer that a
message is too big, it SHOULD immediately attempt to fragment it,
using any existing information about the PMTU.</t>
  <t>If repeated retransmissions do not result in a response, and the
PMTU is unknown, subsequent retransmissions SHOULD back off to a
smaller record size, fragmenting the handshake message as
appropriate.  This standard does not specify an exact number of
retransmits to attempt before backing off, but 2-3 seems
appropriate.</t>
</list></t>

</section>
<section anchor="record-payload-protection" title="Record Payload Protection">

<t>Like TLS, DTLS transmits data as a series of protected records.  The
   rest of this section describes the details of that format.</t>

<section anchor="anti-replay" title="Anti-Replay">

<t>DTLS records contain a sequence number to provide replay protection.
   Sequence number verification SHOULD be performed using the following
   sliding window procedure, borrowed from Section 3.4.3 of <xref target="RFC4303"/>.</t>

<t>The receiver packet counter for this session MUST be initialized to
   zero when the session is established.  For each received record, the
   receiver MUST verify that the record contains a sequence number that
   does not duplicate the sequence number of any other record received
   during the life of this session.  This SHOULD be the first check
   applied to a packet after it has been matched to a session, to speed
   rejection of duplicate records.</t>

<t>Duplicates are rejected through the use of a sliding receive window.
   (How the window is implemented is a local matter, but the following
   text describes the functionality that the implementation must
   exhibit.)  A minimum window size of 32 MUST be supported, but a
   window size of 64 is preferred and SHOULD be employed as the default.
   Another window size (larger than the minimum) MAY be chosen by the
   receiver.  (The receiver does not notify the sender of the window
   size.)</t>

<t>The “right” edge of the window represents the highest validated
   sequence number value received on this session.  Records that contain
   sequence numbers lower than the “left” edge of the window are
   rejected.  Packets falling within the window are checked against a
   list of received packets within the window.  An efficient means for
   performing this check, based on the use of a bit mask, is described
   in Section 3.4.3 of <xref target="RFC4303"/>.</t>

<t>If the received record falls within the window and is new, or if the
   packet is to the right of the window, then the receiver proceeds to
   MAC verification.  If the MAC validation fails, the receiver MUST
   discard the received record as invalid.  The receive window is
   updated only if the MAC verification succeeds.</t>

</section>
<section anchor="handling-invalid-records" title="Handling Invalid Records">

<t>Unlike TLS, DTLS is resilient in the face of invalid records (e.g.,
   invalid formatting, length, MAC, etc.).  In general, invalid records
   SHOULD be silently discarded, thus preserving the association;
   however, an error MAY be logged for diagnostic purposes.
   Implementations which choose to generate an alert instead, MUST
   generate fatal level alerts to avoid attacks where the attacker
   repeatedly probes the implementation to see how it responds to
   various types of error.  Note that if DTLS is run over UDP, then any
   implementation which does this will be extremely susceptible to
   denial-of-service (DoS) attacks because UDP forgery is so easy.
   Thus, this practice is NOT RECOMMENDED for such transports.</t>

<t>If DTLS is being carried over a transport that is resistant to
   forgery (e.g., SCTP with SCTP-AUTH), then it is safer to send alerts
   because an attacker will have difficulty forging a datagram that will
   not be rejected by the transport layer.</t>

</section>
</section>
</section>
<section anchor="dtls" title="The DTLS Handshake Protocol">

<t>DTLS 1.3 re-uses the TLS 1.3 handshake messages and flows, with
the following changes:</t>

<t><list style="numbers">
  <t>Modifications to the handshake header to handle message loss,
reordering, and DTLS message fragmentation (in order to avoid
IP fragmentation). Additionally, a new ACK message is introduced.</t>
  <t>Retransmission timers to handle message loss.</t>
  <t>The TLS 1.3 KeyUpdate message is not used in DTLS 1.3 for re-keying.</t>
</list></t>

<t>Note that TLS 1.3 already supports a cookie extension, which used to 
prevent denial-of-service attacks. This DoS prevention mechanism is
described in more detail below since it is more dangerous than with 
a connection-oriented transport like TCP that performs return-routability
checks as part of the connection establishment.</t>

<t>With these exceptions, the DTLS message formats, flows, and logic are
the same as those of TLS 1.3.</t>

<section anchor="denial-of-service-countermeasures" title="Denial-of-Service Countermeasures">

<t>Datagram security protocols are extremely susceptible to a variety of
DoS attacks.  Two attacks are of particular concern:</t>

<t><list style="numbers">
  <t>An attacker can consume excessive resources on the server by
transmitting a series of handshake initiation requests, causing
the server to allocate state and potentially to perform
expensive cryptographic operations.</t>
  <t>An attacker can use the server as an amplifier by sending
connection initiation messages with a forged source of the
victim.  The server then sends its next message (in DTLS, a
Certificate message, which can be quite large) to the victim
machine, thus flooding it.  <vspace blankLines='1'/>
In order to counter both of these attacks, DTLS borrows the stateless
cookie technique used by Photuris <xref target="RFC2522"/> and IKE <xref target="RFC5996"/>.  When
the client sends its ClientHello message to the server, the server
MAY respond with a HelloRetryRequest message. The HelloRetryRequest message 
as well as the cookie extension is defined in TLS 1.3. The 
HelloRetryRequest message contains
a stateless cookie generated using the technique of <xref target="RFC2522"/>. The
client MUST retransmit the ClientHello with the cookie added as an extension.  The
server then verifies the cookie and proceeds with the handshake only
if it is valid.  This mechanism forces the attacker/client to be able
to receive the cookie, which makes DoS attacks with spoofed IP
addresses difficult.  This mechanism does not provide any defence
against DoS attacks mounted from valid IP addresses.  <vspace blankLines='1'/>
The exchange is shown in <xref target="dtls-cookie-exchange"/>. Note that 
the figure focuses on the cookie exchange; all other extensions 
are omitted.</t>
</list></t>

<figure title="DTLS Exchange with HelloRetryRequest contain the Cookie Extension" anchor="dtls-cookie-exchange"><artwork><![CDATA[
      Client                                   Server
      ------                                   ------
      ClientHello           ------>

                            <----- HelloRetryRequest
                                    + cookie

      ClientHello           ------>
       + cookie

      [Rest of handshake]
]]></artwork></figure>

<t>The cookie extension is defined in Section 4.2.1 of <xref target="TLS13"/>. When sending the 
first ClientHello, the client does not have a cookie yet. In this case, 
the cookie extension is omitted and the legacy_cookie field in the ClientHello 
message SHOULD be set as a zero length vector (i.e., a single zero byte length field) 
and MUST be ignored by a server negotiating DTLS 1.3.</t>

<t>When responding to a HelloRetryRequest, the client MUST use the same
   parameter values (version, random, cipher_suites) as it 
   did in the original ClientHello.</t>

<t>The
   server SHOULD use those values to generate its cookie and verify that
   they are correct upon cookie receipt.  The server MUST use the same
   version number in the HelloRetryRequest that it would use when
   sending a ServerHello.  Upon receipt of the ServerHello, the client
   MUST verify that the server version values match.  In order to avoid
   sequence number duplication in case of multiple HelloRetryRequests,
   the server MUST use the record sequence number in the ClientHello as
   the record sequence number in the HelloRetryRequest.</t>

<t>When the second ClientHello is received, the server can verify that
   the Cookie is valid and that the client can receive packets at the
   given IP address.  In order to avoid sequence number duplication in
   case of multiple cookie exchanges, the server MUST use the record
   sequence number in the ClientHello as the record sequence number in
   its initial ServerHello.  Subsequent ServerHellos will only be sent
   after the server has created state and MUST increment normally.</t>

<t>One potential attack on this scheme is for the attacker to collect a
   number of cookies from different addresses and then reuse them to
   attack the server.  The server can defend against this attack by
   changing the Secret value frequently, thus invalidating those
   cookies.  If the server wishes that legitimate clients be able to
   handshake through the transition (e.g., they received a cookie with
   Secret 1 and then sent the second ClientHello after the server has
   changed to Secret 2), the server can have a limited window during
   which it accepts both secrets.  <xref target="RFC5996"/> suggests adding a version
   number to cookies to detect this case.  An alternative approach is
   simply to try verifying with both secrets.</t>

<t>DTLS servers SHOULD perform a cookie exchange whenever a new
   handshake is being performed.  If the server is being operated in an
   environment where amplification is not a problem, the server MAY be
   configured not to perform a cookie exchange.  The default SHOULD be
   that the exchange is performed, however.  In addition, the server MAY
   choose not to do a cookie exchange when a session is resumed.
   Clients MUST be prepared to do a cookie exchange with every
   handshake.</t>

<t>If the HelloRetryRequest message is used, the initial ClientHello and
   the HelloRetryRequest are included in the calculation of the
   handshake_messages (for the CertificateVerify message) and
   verify_data (for the Finished message).</t>

<t>If a server receives a ClientHello with an invalid cookie, it SHOULD
   treat it the same as a ClientHello with no cookie.  This avoids
   race/deadlock conditions if the client somehow gets a bad cookie
   (e.g., because the server changes its cookie signing key).</t>

<t>Note to implementers: This may result in clients receiving multiple
   HelloRetryRequest messages with different cookies.  Clients SHOULD
   handle this by sending a new ClientHello with a cookie in response to
   the new HelloRetryRequest.</t>

</section>
<section anchor="dtls-handshake-message-format" title="DTLS Handshake Message Format">

<t>In order to support message loss, reordering, and message
   fragmentation, DTLS modifies the TLS 1.3 handshake header:</t>

<figure><artwork><![CDATA[
       enum {
           hello_request_RESERVED(0),
           client_hello(1),
           server_hello(2),
           hello_verify_request_RESERVED(3),
           new_session_ticket(4),
           hello_retry_request(6),
           encrypted_extensions(8),
           certificate(11),
           server_key_exchange_RESERVED(12),
           certificate_request(13),
           server_hello_done_RESERVED(14),
           certificate_verify(15),
           client_key_exchange_RESERVED(16),
           finished(20),
           key_update_RESERVED(24),
           (255)
       } HandshakeType;

       struct {
           HandshakeType msg_type;    /* handshake type */
           uint24 length;             /* bytes in message */
           uint16 message_seq;        /* DTLS-required field */
           uint24 fragment_offset;    /* DTLS-required field */
           uint24 fragment_length;    /* DTLS-required field */           
           select (HandshakeType) {
               case client_hello:          ClientHello;
               case server_hello:          ServerHello;
               case hello_retry_request:   HelloRetryRequest;
               case encrypted_extensions:  EncryptedExtensions;
               case certificate_request:   CertificateRequest;
               case certificate:           Certificate;
               case certificate_verify:    CertificateVerify;
               case finished:              Finished;
               case new_session_ticket:    NewSessionTicket;
               case key_update:            KeyUpdate; /* reserved */
               case ack:                   ACK; /* DTLS-required field */
           } body;
       } Handshake;
]]></artwork></figure>

<t>In addition to the handshake messages that are deprecated by the TLS 1.3
specification DTLS 1.3 furthermore deprecates the HelloVerifyRequest message
originally defined in DTLS 1.0. DTLS 1.3-compliant implements MUST NOT 
use the HelloVerifyRequest to execute a return-routability check. A 
dual-stack DTLS 1.2/DTLS 1.3 client must, however, be prepared to 
interact with a DTLS 1.2 server.</t>

<t>A DTLS 1.3 MUST NOT use the KeyUpdate message to change keying material 
used for the protection of traffic data. Instead the epoch field is used, 
which is explained in <xref target="dtls-epoch"/>.</t>

<t>The format of the ClientHello used by a DTLS 1.3 client differs from the 
TLS 1.3 ClientHello format as shown below.</t>

<figure><artwork><![CDATA[
  struct {
       ProtocolVersion client_version = { 254,252 };    /* DTLS v1.3 */
       Random random;
       opaque legacy_session_id<0..32>;
       opaque legacy_cookie<0..2^8-1>;                  // DTLS       
       CipherSuite cipher_suites<2..2^16-2>;
       opaque legacy_compression_methods<1..2^8-1>;
       Extension extensions<0..2^16-1>;
   } ClientHello;
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='client_version'>
  The version of the DTLS protocol by which the client wishes to 
communicate during this session. This SHOULD be the latest (highest 
valued) version supported by the client. For the DTLS 1.3 version of the 
specification, the version will be { 254,252 }.</t>
  <t hangText='random'>
  Same as for TLS 1.3</t>
  <t hangText='legacy_session_id'>
  Same as for TLS 1.3</t>
  <t hangText='legacy_cookie'>
  A DTLS 1.3-only client MUST set the legacy_cookie field to zero length.</t>
  <t hangText='cipher_suites'>
  Same as for TLS 1.3</t>
  <t hangText='legacy_compression_methods'>
  Same as for TLS 1.3</t>
  <t hangText='extensions'>
  Same as for TLS 1.3</t>
</list></t>

<t>The first message each side transmits in each handshake always has
   message_seq = 0.  Whenever each new message is generated, the
   message_seq value is incremented by one.  Note that in the case of a
   rehandshake, this implies that the HelloRequest will have message_seq
   = 0 and the ServerHello will have message_seq = 1.  When a message is
   retransmitted, the same message_seq value is used.</t>

<t>Here is an example:</t>

<figure title="Example DTLS Exchange illustrating Message Loss" anchor="dtls-msg-loss"><artwork><![CDATA[
         Client                             Server
         ------                             ------
         ClientHello (seq=0)  ------>

                                 X<-- HelloRetryRequest (seq=0)
                                                 (lost)

         [Timer Expires]

         ClientHello (seq=0)  ------>
         (retransmit)

                              <------ HelloRetryRequest (seq=0)

         ClientHello (seq=1)  ------>
         (with cookie)

                              <------        ServerHello (seq=1)

                          [Rest of handshake]
]]></artwork></figure>

<t>Note, however, that from the perspective of the DTLS record layer,
   the retransmission is a new record.  This record will have a new
   DTLSPlaintext.sequence_number value.</t>

<t>DTLS implementations maintain (at least notionally) a
   next_receive_seq counter.  This counter is initially set to zero.
   When a message is received, if its sequence number matches
   next_receive_seq, next_receive_seq is incremented and the message is
   processed.  If the sequence number is less than next_receive_seq, the
   message MUST be discarded.  If the sequence number is greater than
   next_receive_seq, the implementation SHOULD queue the message but MAY
   discard it.  (This is a simple space/bandwidth tradeoff).</t>

</section>
<section anchor="handshake-message-fragmentation-and-reassembly" title="Handshake Message Fragmentation and Reassembly">

<t>Each DTLS message MUST fit within a single
   transport layer datagram.  However, handshake messages are
   potentially bigger than the maximum record size.  Therefore, DTLS
   provides a mechanism for fragmenting a handshake message over a
   number of records, each of which can be transmitted separately, thus
   avoiding IP fragmentation.</t>

<t>When transmitting the handshake message, the sender divides the
   message into a series of N contiguous data ranges.  These ranges MUST
   NOT be larger than the maximum handshake fragment size and MUST
   jointly contain the entire handshake message.  The ranges SHOULD NOT
   overlap.  The sender then creates N handshake messages, all with the
   same message_seq value as the original handshake message.  Each new
   message is labeled with the fragment_offset (the number of bytes
   contained in previous fragments) and the fragment_length (the length
   of this fragment).  The length field in all messages is the same as
   the length field of the original message.  An unfragmented message is
   a degenerate case with fragment_offset=0 and fragment_length=length.</t>

<t>When a DTLS implementation receives a handshake message fragment, it
   MUST buffer it until it has the entire handshake message.  DTLS
   implementations MUST be able to handle overlapping fragment ranges.
   This allows senders to retransmit handshake messages with smaller
   fragment sizes if the PMTU estimate changes.</t>

<t>Note that as with TLS, multiple handshake messages may be placed in
   the same DTLS record, provided that there is room and that they are
   part of the same flight.  Thus, there are two acceptable ways to pack
   two DTLS messages into the same datagram: in the same record or in
   separate records.</t>

</section>
<section anchor="timeout-and-retransmission" title="Timeout and Retransmission">

<t>DTLS messages are grouped into a series of message flights, according
   to the diagrams below.  Although each flight of messages may consist
   of a number of messages, they should be viewed as monolithic for the
   purpose of timeout and retransmission.</t>

<figure title="Message Flights for full DTLS Handshake (with Cookie Exchange)" anchor="dtls-full"><artwork><![CDATA[
Client                                             Server

ClientHello                                                 +----------+
 + key_share*                                               | Flight 1 |
 + pre_shared_key*      -------->                           +----------+

                                                            +----------+
                        <--------        HelloRetryRequest  | Flight 2 |
                                          + cookie          +----------+


ClientHello                                                 +----------+
 + key_share*                                               | Flight 3 |
 + pre_shared_key*      -------->                           +----------+
 + cookie

                                               ServerHello
                                              + key_share*
                                         + pre_shared_key*  +----------+
                                     {EncryptedExtensions}  | Flight 4 |
                                     {CertificateRequest*}  +----------+
                                            {Certificate*}
                                      {CertificateVerify*}
                        <--------               {Finished}


 {Certificate*}                                             +----------+
 {CertificateVerify*}                                       | Flight 5 |
 {Finished}             -------->                           +----------+
]]></artwork></figure>

<figure title="Message Flights for Resumption and PSK Handshake (without Cookie Exchange)" anchor="dtls-psk"><artwork><![CDATA[
ClientHello                                               +----------+
  + pre_shared_key                                        | Flight 1 |
  + key_share*         -------->                          +----------+


                                             ServerHello
                                        + pre_shared_key  +----------+
                                            + key_share*  | Flight 2 |
                                   {EncryptedExtensions}  +----------+
                       <--------              {Finished}

                                                          +----------+
{Finished}             -------->                          | Flight 3 |
                                                          +----------+
]]></artwork></figure>

<figure title="Message Flights for a zero round trip handshake" anchor="dtls-zero-rtt"><artwork><![CDATA[
Client                                            Server

ClientHello
  + early_data
  + pre_shared_key                                        +----------+
  + key_share*                                            | Flight 1 |
(EncryptedExtensions)                                     +----------+
(Finished)
(Application Data*)
(end_of_early_data)     -------->

                                             ServerHello
                                            + early_data
                                        + pre_shared_key  +----------+
                                            + key_share*  | Flight 2 |
                                   {EncryptedExtensions}  +----------+
                                   {CertificateRequest*}
                       <--------              {Finished}

{Certificate*}                                            +----------+
{CertificateVerify*}                                      | Flight 3 |
{Finished}             -------->                          +----------+
]]></artwork></figure>

<t>Note: The application data sent by the client is not included in the 
timeout and retransmission calculation.</t>

<section anchor="state-machine" title="State Machine">

<t>DTLS uses a simple timeout and retransmission scheme with the
   state machine shown in {{dtls-timeout-state-machine}. 
   Because DTLS clients send the first message
   (ClientHello), they start in the PREPARING state.  DTLS servers start
   in the WAITING state, but with empty buffers and no retransmit timer.</t>

<figure title="DTLS Timeout and Retransmission State Machine" anchor="dtls-timeout-state-machine"><artwork><![CDATA[
                      +-----------+
                      | PREPARING |
                +---> |           | <--------------------+
                |     |           |                      |
                |     +-----------+                      |
                |           |                            |
                |           | Buffer next flight         |
                |           |                            |
                |          \|/                           |
                |     +-----------+                      |
                |     |           |                      |
                |     |  SENDING  |<------------------+  |
                |     |           |                   |  | Send
                |     +-----------+                   |  | HelloRequest
        Receive |           |                         |  |
           next |           | Send flight             |  | or
         flight |  +--------+                         |  |
                |  |        | Set retransmit timer    |  | Receive
                |  |       \|/                        |  | HelloRequest
                |  |  +-----------+                   |  | Send
                |  |  |           |                   |  | ClientHello
                +--)--|  WAITING  |-------------------+  |
                |  |  |           |   Timer expires   |  |
                |  |  +-----------+                   |  |
                |  |         |                        |  |
                |  |         |                        |  |
                |  |         +------------------------+  |
                |  |                Read retransmit      |
        Receive |  |                                     |
           last |  |                                     |
         flight |  |                                     |
                |  |                                     |
               \|/\|/                                    |
                                                         |
            +-----------+                                |
            |           |                                |
            | FINISHED  | -------------------------------+
            |           |
            +-----------+
                 |  /|\
                 |   |
                 |   |
                 +---+

              Read retransmit
           Retransmit last flight
]]></artwork></figure>

<t>The state machine has three basic states.</t>

<t>In the PREPARING state, the implementation does whatever computations
   are necessary to prepare the next flight of messages.  It then
   buffers them up for transmission (emptying the buffer first) and
   enters the SENDING state.</t>

<t>In the SENDING state, the implementation transmits the buffered
   flight of messages.  Once the messages have been sent, the
   implementation then enters the FINISHED state if this is the last
   flight in the handshake.  Or, if the implementation expects to
   receive more messages, it sets a retransmit timer and then enters the
   WAITING state.</t>

<t>There are three ways to exit the WAITING state:</t>

<t><list style="numbers">
  <t>The retransmit timer expires: the implementation transitions to
the SENDING state, where it retransmits the flight, resets the
retransmit timer, and returns to the WAITING state.</t>
  <t>The implementation reads a retransmitted flight from the peer: the
implementation transitions to the SENDING state, where it
retransmits the flight, resets the retransmit timer, and returns
to the WAITING state.  The rationale here is that the receipt of a
duplicate message is the likely result of timer expiry on the peer
and therefore suggests that part of one’s previous flight was
lost.</t>
  <t>The implementation receives the next flight of messages: if this
is the final flight of messages, the implementation transitions to
FINISHED.  If the implementation needs to send a new flight, it
transitions to the PREPARING state.  Partial reads (whether
partial messages or only some of the messages in the flight) do
not cause state transitions or timer resets.  <vspace blankLines='1'/>
Because DTLS clients send the first message (ClientHello), they start
in the PREPARING state.  DTLS servers start in the WAITING state, but
with empty buffers and no retransmit timer.  <vspace blankLines='1'/>
When the server desires a rehandshake, it transitions from the
FINISHED state to the PREPARING state to transmit the HelloRequest.
When the client receives a HelloRequest, it transitions from FINISHED
to PREPARING to transmit the ClientHello.  <vspace blankLines='1'/>
In addition, for at least twice the default Maximum Segment Lifetime 
(MSL) defined for <xref target="TCP"/>,
when in the FINISHED state, the node that transmits the last flight
(the server in an ordinary handshake or the client in a resumed
handshake) MUST respond to a retransmit of the peer’s last flight
with a retransmit of the last flight.  This avoids deadlock
conditions if the last flight gets lost.  To see why
this is necessary, consider what happens in an ordinary handshake if
the server’s Finished message is lost: the server believes the
handshake is complete but it actually is not.  As the client is
waiting for the Finished message, the client’s retransmit timer will
fire and it will retransmit the client’s Finished message.  This will
cause the server to respond with its own Finished message, completing
the handshake.  The same logic applies on the server side for the
resumed handshake.  <vspace blankLines='1'/>
Note that because of packet loss, it is possible for one side to be
sending application data even though the other side has not received
the first side’s Finished message.  Implementations MUST either
discard or buffer all application data packets for the new epoch
until they have received the Finished message for that epoch.
Implementations MAY treat receipt of application data with a new
epoch prior to receipt of the corresponding Finished message as
evidence of reordering or packet loss and retransmit their final
flight immediately, shortcutting the retransmission timer.</t>
</list></t>

</section>
<section anchor="timer-values" title="Timer Values">

<t>Though timer values are the choice of the implementation, mishandling
   of the timer can lead to serious congestion problems; for example, if
   many instances of a DTLS time out early and retransmit too quickly on
   a congested link.  Implementations SHOULD use an initial timer value
   of 1 second (the minimum defined in RFC 6298 <xref target="RFC6298"/>) and double
   the value at each retransmission, up to no less than the RFC 6298
   maximum of 60 seconds.  Note that we recommend a 1-second timer
   rather than the 3-second RFC 6298 default in order to improve latency
   for time-sensitive applications.  Because DTLS only uses
   retransmission for handshake and not dataflow, the effect on
   congestion should be minimal.</t>

<t>Implementations SHOULD retain the current timer value until a
   transmission without loss occurs, at which time the value may be
   reset to the initial value.  After a long period of idleness, no less
   than 10 times the current timer value, implementations may reset the
   timer to the initial value.  One situation where this might occur is
   when a rehandshake is used after substantial data transfer.</t>

</section>
</section>
<section anchor="certificateverify-and-finished-messages" title="CertificateVerify and Finished Messages">

<t>CertificateVerify and Finished messages have the same format as in
   TLS.  Hash calculations include entire handshake messages, including
   DTLS-specific fields: message_seq, fragment_offset, and
   fragment_length.  However, in order to remove sensitivity to
   handshake message fragmentation, the Finished MAC MUST be computed as
   if each handshake message had been sent as a single fragment.</t>

</section>
<section anchor="alert-messages" title="Alert Messages">

<t>Note that Alert messages are not retransmitted at all, even when they
   occur in the context of a handshake.  However, a DTLS implementation
   which would ordinarily issue an alert SHOULD generate a new alert
   message if the offending record is received again (e.g., as a
   retransmitted handshake message).  Implementations SHOULD detect when
   a peer is persistently sending bad messages and terminate the local
   connection state after such misbehavior is detected.</t>

</section>
<section anchor="establishing-new-associations-with-existing-parameters" title="Establishing New Associations with Existing Parameters">

<t>If a DTLS client-server pair is configured in such a way that
   repeated connections happen on the same host/port quartet, then it is
   possible that a client will silently abandon one connection and then
   initiate another with the same parameters (e.g., after a reboot).
   This will appear to the server as a new handshake with epoch=0.  In
   cases where a server believes it has an existing association on a
   given host/port quartet and it receives an epoch=0 ClientHello, it
   SHOULD proceed with a new handshake but MUST NOT destroy the existing
   association until the client has demonstrated reachability either by
   completing a cookie exchange or by completing a complete handshake
   including delivering a verifiable Finished message.  After a correct
   Finished message is received, the server MUST abandon the previous
   association to avoid confusion between two valid associations with
   overlapping epochs.  The reachability requirement prevents
   off-path/blind attackers from destroying associations merely by
   sending forged ClientHellos.</t>

</section>
<section anchor="dtls-epoch" title="Epoch Values and Rekeying">

<t>A recipient of a DTLS message needs to select the correct keying material
in order to process an incoming message. With the possibility of message
 loss and re-order an identifier is needed to determine which cipher state 
has been used to protect the record payload. The epoch value fulfills this 
role in DTLS. In addition to the key derivation steps described in 
Section 7 of <xref target="TLS13"/> triggered by the states during the handshake
a sender may want to rekey at any time during 
the lifetime of the connection and has to have a way to indicate that it is 
updating its sending cryptographic keys.</t>

<t>The following epoch values are reserved and correspond to phases in the handshake and allow
identification of the correct cipher state:</t>

<t><list style="symbols">
  <t>epoch value (0) for use with unencrypted messages, namely ClientHello, 
ServerHello, and HelloRetryRequest.</t>
  <t>epoch value (1) for the Finished message protected using the 0-RTT 
handshake key.</t>
  <t>epoch value (2) for 0-RTT ‘Application Data’ protected using keys derived from the<vspace />
early_traffic_secret.</t>
  <t>epoch value (3) for messages protected using keys derived from the 
handshake_traffic_secret, namely the EncryptedExtensions to the Finished message sent by the client).</t>
  <t>epoch value (4) for application data payloads protected using keys derived from the initial traffic_secret_0.</t>
  <t>epoch value (5 to 2^16-1) for application data payloads protected using keys from the traffic_secret_N (N&gt;0).</t>
</list></t>

<t>Using these reserved epoch values a receiver knows what cipher state has been used to encrypt and integrity protect a message. Implementations that receive a payload with an epoch value for which no corresponding cipher state can be determined MUST generate a fatal “unexpected_message” alert. For example, client incorrectly uses epoch value 5 when sending application data in a 0-RTT exchange with the first message. A server will not be able to compute the appropriate keys and will therefore have to respond with a fatal alert.</t>

<t>Increasing the epoch value by a sender (starting with value 5 upwards) corresponds semantically to rekeying using the KeyUpdate message in TLS 1.3. Instead of utilizing an dedicated message in DTLS 1.3 the sender uses an increase in the epoch value to signal rekeying. Hence, a sender that decides to increment the epoch value (with value starting at 5) MUST send all its traffic using the next generation of keys, computed as described in Section 7.2 of <xref target="TLS13"/>. Upon receiving a payload with such a new epoch value, the receiver MUST update their receiving keys and if they have not already updated their sending state up to or past the then current receiving generation MUST send messages with the new epoch value prior to sending any other messages. For epoch values lower than 5 the key schedule described in Section 7.1 of <xref target="TLS13"/> is applicable.</t>

<t>Note that epoch values do not wrap. If a DTLS implementation would need to wrap the epoch value, it MUST terminate the connection.</t>

<t>The traffic key calculation is described in Section 7.3 of <xref target="TLS13"/>.</t>

</section>
</section>
<section anchor="application-data-protocol" title="Application Data Protocol">

<t>Application data messages are carried by the record layer and are fragmented
and encrypted based on the current connection state. The messages
are treated as transparent data to the record layer.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>Security issues are discussed primarily in <xref target="TLS13"/>.</t>

<t>The primary additional security consideration raised by DTLS is that
   of denial of service.  DTLS includes a cookie exchange designed to
   protect against denial of service.  However, implementations that do
   not use this cookie exchange are still vulnerable to DoS.  In
   particular, DTLS servers that do not use the cookie exchange may be
   used as attack amplifiers even if they themselves are not
   experiencing DoS.  Therefore, DTLS servers SHOULD use the cookie
   exchange unless there is good reason to believe that amplification is
   not a threat in their environment.  Clients MUST be prepared to do a
   cookie exchange with every handshake.</t>

<t>Unlike TLS implementations, DTLS implementations SHOULD NOT respond
   to invalid records by terminating the connection.</t>

</section>
<section anchor="changes-to-dtls-12" title="Changes to DTLS 1.2">

<t>Since TLS 1.3 introduce a large number of changes to TLS 1.2, the list of changes from DTLS 1.2 to DTLS 1.3 is equally large. For this reason this section focuses on the most important changes only.</t>

<t><list style="symbols">
  <t>New handshake pattern, which leads to a shorter message exchange</t>
  <t>Support for AEAD-only ciphers</t>
  <t>HelloRetryRequest of TLS 1.3 used instead of HelloVerifyRequest</t>
  <t>More flexible ciphersuite negotiation</t>
  <t>New session resumption mechanism</t>
  <t>PSK authentication redefined</t>
  <t>New key derivation hierarchy utilizing the HKDF construct</t>
  <t>Removed support for weaker and older cryptographic algorithms</t>
</list></t>

</section>
<section anchor="open-issues" title="Open Issues">

<t><list style="symbols">
  <t>Add description for ACK message</t>
  <t>More description for the retransmission behavior regarding 
Post-Handshake messages, such as CertificateRequest, and NewSessionTicket, is needed.</t>
  <t>Do we need the HelloRequest message in DTLS 1.3?</t>
  <t>The cookie computation for the HelloRetryRequest may need more description since it has a secondary purpose (besides DoS protection) where the server can tell the client that the provided KeyShare did not contain an acceptable offer. Hence, it may be useful to indicate what parameters the client has to re-send as it did in the original ClientHello.</t>
  <t>Update text in the appendix regarding backwards compatibility.</t>
</list></t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>[[Editor’s Note: Add extension for ACK message]]</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC2104' target='http://www.rfc-editor.org/info/rfc2104'>
<front>
<title>HMAC: Keyed-Hashing for Message Authentication</title>
<author initials='H.' surname='Krawczyk' fullname='H. Krawczyk'><organization /></author>
<author initials='M.' surname='Bellare' fullname='M. Bellare'><organization /></author>
<author initials='R.' surname='Canetti' fullname='R. Canetti'><organization /></author>
<date year='1997' month='February' />
<abstract><t>This document describes HMAC, a mechanism for message authentication using cryptographic hash functions. HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key.  The cryptographic strength of HMAC depends on the properties of the underlying hash function.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind</t></abstract>
</front>
<seriesInfo name='RFC' value='2104'/>
<seriesInfo name='DOI' value='10.17487/RFC2104'/>
</reference>



<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC2434' target='http://www.rfc-editor.org/info/rfc2434'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'><organization /></author>
<date year='1998' month='October' />
<abstract><t>This document discusses issues that should be considered in formulating a policy for assigning values to a name space and provides guidelines to document authors on the specific text that must be included in documents that place demands on the IANA.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='RFC' value='2434'/>
<seriesInfo name='DOI' value='10.17487/RFC2434'/>
</reference>



<reference  anchor='RFC3447' target='http://www.rfc-editor.org/info/rfc3447'>
<front>
<title>Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</title>
<author initials='J.' surname='Jonsson' fullname='J. Jonsson'><organization /></author>
<author initials='B.' surname='Kaliski' fullname='B. Kaliski'><organization /></author>
<date year='2003' month='February' />
<abstract><t>This memo represents a republication of PKCS #1 v2.1 from RSA Laboratories' Public-Key Cryptography Standards (PKCS) series, and change control is retained within the PKCS process.  The body of this document is taken directly from the PKCS #1 v2.1 document, with certain corrections made during the publication process.  This memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='3447'/>
<seriesInfo name='DOI' value='10.17487/RFC3447'/>
</reference>



<reference  anchor='RFC5280' target='http://www.rfc-editor.org/info/rfc5280'>
<front>
<title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
<author initials='D.' surname='Cooper' fullname='D. Cooper'><organization /></author>
<author initials='S.' surname='Santesson' fullname='S. Santesson'><organization /></author>
<author initials='S.' surname='Farrell' fullname='S. Farrell'><organization /></author>
<author initials='S.' surname='Boeyen' fullname='S. Boeyen'><organization /></author>
<author initials='R.' surname='Housley' fullname='R. Housley'><organization /></author>
<author initials='W.' surname='Polk' fullname='W. Polk'><organization /></author>
<date year='2008' month='May' />
<abstract><t>This memo profiles the X.509 v3 certificate and X.509 v2 certificate revocation list (CRL) for use in the Internet.  An overview of this approach and model is provided as an introduction.  The X.509 v3 certificate format is described in detail, with additional information regarding the format and semantics of Internet name forms.  Standard certificate extensions are described and two Internet-specific extensions are defined.  A set of required certificate extensions is specified.  The X.509 v2 CRL format is described in detail along with standard and Internet-specific extensions.  An algorithm for X.509 certification path validation is described.  An ASN.1 module and examples are provided in the appendices.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5280'/>
<seriesInfo name='DOI' value='10.17487/RFC5280'/>
</reference>



<reference  anchor='RFC5288' target='http://www.rfc-editor.org/info/rfc5288'>
<front>
<title>AES Galois Counter Mode (GCM) Cipher Suites for TLS</title>
<author initials='J.' surname='Salowey' fullname='J. Salowey'><organization /></author>
<author initials='A.' surname='Choudhury' fullname='A. Choudhury'><organization /></author>
<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This memo describes the use of the Advanced Encryption Standard (AES) in Galois/Counter Mode (GCM) as a Transport Layer Security (TLS) authenticated encryption operation.  GCM provides both confidentiality and data origin authentication, can be efficiently implemented in hardware for speeds of 10 gigabits per second and above, and is also well-suited to software implementations.  This memo defines TLS cipher suites that use AES-GCM with RSA, DSA, and Diffie-Hellman-based key exchange mechanisms.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5288'/>
<seriesInfo name='DOI' value='10.17487/RFC5288'/>
</reference>



<reference  anchor='RFC5289' target='http://www.rfc-editor.org/info/rfc5289'>
<front>
<title>TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>RFC 4492 describes elliptic curve cipher suites for Transport Layer Security (TLS).  However, all those cipher suites use HMAC-SHA-1 as their Message Authentication Code (MAC) algorithm.  This document describes sixteen new cipher suites for TLS that specify stronger MAC algorithms.  Eight use Hashed Message Authentication Code (HMAC) with SHA-256 or SHA-384, and eight use AES in Galois Counter Mode (GCM).   This memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='5289'/>
<seriesInfo name='DOI' value='10.17487/RFC5289'/>
</reference>



<reference  anchor='RFC5487' target='http://www.rfc-editor.org/info/rfc5487'>
<front>
<title>Pre-Shared Key Cipher Suites for TLS with SHA-256/384 and AES Galois Counter Mode</title>
<author initials='M.' surname='Badra' fullname='M. Badra'><organization /></author>
<date year='2009' month='March' />
<abstract><t>RFC 4279 and RFC 4785 describe pre-shared key cipher suites for Transport Layer Security (TLS).  However, all those cipher suites use SHA-1 in their Message Authentication Code (MAC) algorithm.  This document describes a set of pre-shared key cipher suites for TLS that uses stronger digest algorithms (i.e., SHA-256 or SHA-384) and another set that uses the Advanced Encryption Standard (AES) in Galois Counter Mode (GCM).  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5487'/>
<seriesInfo name='DOI' value='10.17487/RFC5487'/>
</reference>



<reference  anchor='RFC5869' target='http://www.rfc-editor.org/info/rfc5869'>
<front>
<title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
<author initials='H.' surname='Krawczyk' fullname='H. Krawczyk'><organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'><organization /></author>
<date year='2010' month='May' />
<abstract><t>This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications.  The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions.  This document is not an Internet  Standards Track specification; it is published for informational  purposes.</t></abstract>
</front>
<seriesInfo name='RFC' value='5869'/>
<seriesInfo name='DOI' value='10.17487/RFC5869'/>
</reference>



<reference  anchor='RFC6066' target='http://www.rfc-editor.org/info/rfc6066'>
<front>
<title>Transport Layer Security (TLS) Extensions: Extension Definitions</title>
<author initials='D.' surname='Eastlake 3rd' fullname='D. Eastlake 3rd'><organization /></author>
<date year='2011' month='January' />
<abstract><t>This document provides specifications for existing TLS extensions.  It is a companion document for RFC 5246, &quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot;.  The extensions specified are server_name, max_fragment_length, client_certificate_url, trusted_ca_keys, truncated_hmac, and status_request.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6066'/>
<seriesInfo name='DOI' value='10.17487/RFC6066'/>
</reference>



<reference  anchor='RFC6655' target='http://www.rfc-editor.org/info/rfc6655'>
<front>
<title>AES-CCM Cipher Suites for Transport Layer Security (TLS)</title>
<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
<author initials='D.' surname='Bailey' fullname='D. Bailey'><organization /></author>
<date year='2012' month='July' />
<abstract><t>This memo describes the use of the Advanced Encryption Standard (AES) in the Counter with Cipher Block Chaining - Message Authentication Code (CBC-MAC) Mode (CCM) of operation within Transport Layer Security (TLS) and Datagram TLS (DTLS) to provide confidentiality and data origin authentication.  The AES-CCM algorithm is amenable to compact implementations, making it suitable for constrained environments.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6655'/>
<seriesInfo name='DOI' value='10.17487/RFC6655'/>
</reference>



<reference  anchor='RFC7748' target='http://www.rfc-editor.org/info/rfc7748'>
<front>
<title>Elliptic Curves for Security</title>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<author initials='M.' surname='Hamburg' fullname='M. Hamburg'><organization /></author>
<author initials='S.' surname='Turner' fullname='S. Turner'><organization /></author>
<date year='2016' month='January' />
<abstract><t>This memo specifies two elliptic curves over prime fields that offer a high level of practical security in cryptographic applications, including Transport Layer Security (TLS).  These curves are intended to operate at the ~128-bit and ~224-bit security level, respectively, and are generated deterministically based on a list of required properties.</t></abstract>
</front>
<seriesInfo name='RFC' value='7748'/>
<seriesInfo name='DOI' value='10.17487/RFC7748'/>
</reference>



<reference anchor='I-D.mattsson-tls-ecdhe-psk-aead'>
<front>
<title>ECDHE_PSK with AES-GCM and AES-CCM Cipher Suites for Transport Layer Security (TLS)</title>

<author initials='J' surname='Mattsson' fullname='John Mattsson'>
    <organization />
</author>

<author initials='D' surname='Migault' fullname='Daniel Migault'>
    <organization />
</author>

<date month='April' day='18' year='2016' />

<abstract><t>This document defines several new cipher suites for the Transport Layer Security (TLS) protocol.  The cipher suites are all based on the Ephemeral Elliptic Curve Diffie-Hellman with Pre-Shared Key (ECDHE_PSK) key exchange together with the Authenticated Encryption with Associated Data (AEAD) algorithms AES-GCM and AES-CCM.  PSK provides light and efficient authentication, ECDHE provides perfect forward secrecy, and AES-GCM and AES-CCM provides encryption and integrity protection.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-mattsson-tls-ecdhe-psk-aead-05' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-mattsson-tls-ecdhe-psk-aead-05.txt' />
</reference>



<reference anchor='I-D.ietf-tls-chacha20-poly1305'>
<front>
<title>ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS)</title>

<author initials='A' surname='Langley' fullname='Adam Langley'>
    <organization />
</author>

<author initials='W' surname='Chang' fullname='Wan-Teh Chang'>
    <organization />
</author>

<author initials='N' surname='Mavrogiannopoulos' fullname='Nikos Mavrogiannopoulos'>
    <organization />
</author>

<author initials='J' surname='Strombergson' fullname='Joachim Strombergson'>
    <organization />
</author>

<author initials='S' surname='Josefsson' fullname='Simon Josefsson'>
    <organization />
</author>

<date month='December' day='16' year='2015' />

<abstract><t>This document describes the use of the ChaCha stream cipher and Poly1305 authenticator in the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-tls-chacha20-poly1305-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-tls-chacha20-poly1305-04.txt' />
</reference>



<reference anchor='I-D.irtf-cfrg-eddsa'>
<front>
<title>Edwards-curve Digital Signature Algorithm (EdDSA)</title>

<author initials='S' surname='Josefsson' fullname='Simon Josefsson'>
    <organization />
</author>

<author initials='I' surname='Liusvaara' fullname='Ilari Liusvaara'>
    <organization />
</author>

<date month='August' day='10' year='2016' />

<abstract><t>The elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA) is described.  The algorithm is instantiated with recommended parameters for the edwards25519 and edwards448 curves. An example implementation and test vectors are provided.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-irtf-cfrg-eddsa-06' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-irtf-cfrg-eddsa-06.txt' />
</reference>



<reference  anchor='RFC4443' target='http://www.rfc-editor.org/info/rfc4443'>
<front>
<title>Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</title>
<author initials='A.' surname='Conta' fullname='A. Conta'><organization /></author>
<author initials='S.' surname='Deering' fullname='S. Deering'><organization /></author>
<author initials='M.' surname='Gupta' fullname='M. Gupta' role='editor'><organization /></author>
<date year='2006' month='March' />
<abstract><t>This document describes the format of a set of control messages used in ICMPv6 (Internet Control Message Protocol).  ICMPv6 is the Internet Control Message Protocol for Internet Protocol version 6 (IPv6).  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4443'/>
<seriesInfo name='DOI' value='10.17487/RFC4443'/>
</reference>



<reference  anchor='RFC4821' target='http://www.rfc-editor.org/info/rfc4821'>
<front>
<title>Packetization Layer Path MTU Discovery</title>
<author initials='M.' surname='Mathis' fullname='M. Mathis'><organization /></author>
<author initials='J.' surname='Heffner' fullname='J. Heffner'><organization /></author>
<date year='2007' month='March' />
<abstract><t>This document describes a robust method for Path MTU Discovery (PMTUD) that relies on TCP or some other Packetization Layer to probe an Internet path with progressively larger packets.  This method is described as an extension to RFC 1191 and RFC 1981, which specify ICMP-based Path MTU Discovery for IP versions 4 and 6, respectively.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4821'/>
<seriesInfo name='DOI' value='10.17487/RFC4821'/>
</reference>



<reference  anchor='RFC6298' target='http://www.rfc-editor.org/info/rfc6298'>
<front>
<title>Computing TCP's Retransmission Timer</title>
<author initials='V.' surname='Paxson' fullname='V. Paxson'><organization /></author>
<author initials='M.' surname='Allman' fullname='M. Allman'><organization /></author>
<author initials='J.' surname='Chu' fullname='J. Chu'><organization /></author>
<author initials='M.' surname='Sargent' fullname='M. Sargent'><organization /></author>
<date year='2011' month='June' />
<abstract><t>This document defines the standard algorithm that Transmission Control Protocol (TCP) senders are required to use to compute and manage their retransmission timer.  It expands on the discussion in Section 4.2.3.1 of RFC 1122 and upgrades the requirement of supporting the algorithm from a SHOULD to a MUST.  This document obsoletes RFC 2988.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6298'/>
<seriesInfo name='DOI' value='10.17487/RFC6298'/>
</reference>



<reference  anchor='RFC1191' target='http://www.rfc-editor.org/info/rfc1191'>
<front>
<title>Path MTU discovery</title>
<author initials='J.C.' surname='Mogul' fullname='J.C. Mogul'><organization /></author>
<author initials='S.E.' surname='Deering' fullname='S.E. Deering'><organization /></author>
<date year='1990' month='November' />
<abstract><t>This memo describes a technique for dynamically discovering the maximum transmission unit (MTU) of an arbitrary internet path.  It specifies a small change to the way routers generate one type of ICMP message.  For a path that passes through a router that has not been so changed, this technique might not discover the correct Path MTU, but it will always choose a Path MTU as accurate as, and in many cases more accurate than, the Path MTU that would be chosen by current practice.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='1191'/>
<seriesInfo name='DOI' value='10.17487/RFC1191'/>
</reference>



<reference  anchor='RFC6347' target='http://www.rfc-editor.org/info/rfc6347'>
<front>
<title>Datagram Transport Layer Security Version 1.2</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='N.' surname='Modadugu' fullname='N. Modadugu'><organization /></author>
<date year='2012' month='January' />
<abstract><t>This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6347'/>
<seriesInfo name='DOI' value='10.17487/RFC6347'/>
</reference>


<reference anchor="TCP" >
  <front>
    <title>Transmission Control Protocol (TCP)</title>
    <author initials="J." surname="Postel">
      <organization></organization>
    </author>
    <date year="1981" month="September"/>
  </front>
  <seriesInfo name="IETF" value="RFC 793"/>
</reference>
<reference anchor="AES" >
  <front>
    <title>Specification for the Advanced Encryption Standard (AES)</title>
    <author >
      <organization>National Institute of Standards and Technology</organization>
    </author>
    <date year="2001" month="November" day="26"/>
  </front>
  <seriesInfo name="NIST" value="FIPS 197"/>
</reference>
<reference anchor="SHS" >
  <front>
    <title>Secure Hash Standard</title>
    <author >
      <organization>National Institute of Standards and Technology, U.S. Department of Commerce</organization>
    </author>
    <date year="2012" month="March"/>
  </front>
  <seriesInfo name="NIST" value="FIPS PUB 180-4"/>
</reference>
<reference anchor="X690" >
  <front>
    <title>Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
    <author >
      <organization>ITU-T</organization>
    </author>
    <date year="2002"/>
  </front>
  <seriesInfo name="ISO/IEC" value="8825-1:2002"/>
</reference>
<reference anchor="X962" >
  <front>
    <title>Public Key Cryptography For The Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
    <author >
      <organization>ANSI</organization>
    </author>
    <date year="1998"/>
  </front>
  <seriesInfo name="ANSI" value="X9.62"/>
</reference>
<reference anchor="DH" >
  <front>
    <title>New Directions in Cryptography</title>
    <author initials="W." surname="Diffie">
      <organization></organization>
    </author>
    <author initials="M." surname="Hellman">
      <organization></organization>
    </author>
    <date year="1977" month="June"/>
  </front>
  <seriesInfo name="IEEE Transactions on Information Theory, V.IT-22 n.6" value=""/>
</reference>


    </references>

    <references title='Informative References'>





<reference  anchor='RFC0793' target='http://www.rfc-editor.org/info/rfc793'>
<front>
<title>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'><organization /></author>
<date year='1981' month='September' />
</front>
<seriesInfo name='STD' value='7'/>
<seriesInfo name='RFC' value='793'/>
<seriesInfo name='DOI' value='10.17487/RFC0793'/>
</reference>



<reference  anchor='RFC1948' target='http://www.rfc-editor.org/info/rfc1948'>
<front>
<title>Defending Against Sequence Number Attacks</title>
<author initials='S.' surname='Bellovin' fullname='S. Bellovin'><organization /></author>
<date year='1996' month='May' />
<abstract><t>IP spoofing attacks based on sequence number spoofing have become a serious threat on the Internet (CERT Advisory CA-95:01).  While ubiquitous crypgraphic authentication is the right answer, we propose a simple modification to TCP implementations that should be a very substantial block to the current wave of attacks.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind.</t></abstract>
</front>
<seriesInfo name='RFC' value='1948'/>
<seriesInfo name='DOI' value='10.17487/RFC1948'/>
</reference>



<reference  anchor='RFC4086' target='http://www.rfc-editor.org/info/rfc4086'>
<front>
<title>Randomness Requirements for Security</title>
<author initials='D.' surname='Eastlake 3rd' fullname='D. Eastlake 3rd'><organization /></author>
<author initials='J.' surname='Schiller' fullname='J. Schiller'><organization /></author>
<author initials='S.' surname='Crocker' fullname='S. Crocker'><organization /></author>
<date year='2005' month='June' />
<abstract><t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts.  However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t><t>Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='106'/>
<seriesInfo name='RFC' value='4086'/>
<seriesInfo name='DOI' value='10.17487/RFC4086'/>
</reference>



<reference  anchor='RFC4279' target='http://www.rfc-editor.org/info/rfc4279'>
<front>
<title>Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)</title>
<author initials='P.' surname='Eronen' fullname='P. Eronen' role='editor'><organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig' role='editor'><organization /></author>
<date year='2005' month='December' />
<abstract><t>This document specifies three sets of new ciphersuites for the Transport Layer Security (TLS) protocol to support authentication based on pre-shared keys (PSKs).  These pre-shared keys are symmetric keys, shared in advance among the communicating parties.  The first set of ciphersuites uses only symmetric key operations for authentication. The second set uses a Diffie-Hellman exchange authenticated with a pre-shared key, and the third set combines public key authentication of the server with pre-shared key authentication of the client.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4279'/>
<seriesInfo name='DOI' value='10.17487/RFC4279'/>
</reference>



<reference  anchor='RFC4302' target='http://www.rfc-editor.org/info/rfc4302'>
<front>
<title>IP Authentication Header</title>
<author initials='S.' surname='Kent' fullname='S. Kent'><organization /></author>
<date year='2005' month='December' />
<abstract><t>This document describes an updated version of the IP Authentication Header (AH), which is designed to provide authentication services in IPv4 and IPv6.  This document obsoletes RFC 2402 (November 1998).  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4302'/>
<seriesInfo name='DOI' value='10.17487/RFC4302'/>
</reference>



<reference  anchor='RFC4303' target='http://www.rfc-editor.org/info/rfc4303'>
<front>
<title>IP Encapsulating Security Payload (ESP)</title>
<author initials='S.' surname='Kent' fullname='S. Kent'><organization /></author>
<date year='2005' month='December' />
<abstract><t>This document describes an updated version of the Encapsulating Security Payload (ESP) protocol, which is designed to provide a mix of security services in IPv4 and IPv6.  ESP is used to provide confidentiality, data origin authentication, connectionless integrity, an anti-replay service (a form of partial sequence integrity), and limited traffic flow confidentiality.  This document obsoletes RFC 2406 (November 1998).  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4303'/>
<seriesInfo name='DOI' value='10.17487/RFC4303'/>
</reference>



<reference  anchor='RFC4346' target='http://www.rfc-editor.org/info/rfc4346'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.1</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2006' month='April' />
<abstract><t>This document specifies Version 1.1 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4346'/>
<seriesInfo name='DOI' value='10.17487/RFC4346'/>
</reference>



<reference  anchor='RFC4366' target='http://www.rfc-editor.org/info/rfc4366'>
<front>
<title>Transport Layer Security (TLS) Extensions</title>
<author initials='S.' surname='Blake-Wilson' fullname='S. Blake-Wilson'><organization /></author>
<author initials='M.' surname='Nystrom' fullname='M. Nystrom'><organization /></author>
<author initials='D.' surname='Hopwood' fullname='D. Hopwood'><organization /></author>
<author initials='J.' surname='Mikkelsen' fullname='J. Mikkelsen'><organization /></author>
<author initials='T.' surname='Wright' fullname='T. Wright'><organization /></author>
<date year='2006' month='April' />
<abstract><t>This document describes extensions that may be used to add functionality to Transport Layer Security (TLS).  It provides both generic extension mechanisms for the TLS handshake client and server hellos, and specific extensions using these generic mechanisms.</t><t>The extensions may be used by TLS clients and servers.  The extensions are backwards compatible: communication is possible between TLS clients that support the extensions and TLS servers that do not support the extensions, and vice versa.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4366'/>
<seriesInfo name='DOI' value='10.17487/RFC4366'/>
</reference>



<reference  anchor='RFC4492' target='http://www.rfc-editor.org/info/rfc4492'>
<front>
<title>Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</title>
<author initials='S.' surname='Blake-Wilson' fullname='S. Blake-Wilson'><organization /></author>
<author initials='N.' surname='Bolyard' fullname='N. Bolyard'><organization /></author>
<author initials='V.' surname='Gupta' fullname='V. Gupta'><organization /></author>
<author initials='C.' surname='Hawk' fullname='C. Hawk'><organization /></author>
<author initials='B.' surname='Moeller' fullname='B. Moeller'><organization /></author>
<date year='2006' month='May' />
<abstract><t>This document describes new key exchange algorithms based on Elliptic Curve Cryptography (ECC) for the Transport Layer Security (TLS) protocol.  In particular, it specifies the use of Elliptic Curve Diffie-Hellman (ECDH) key agreement in a TLS handshake and the use of Elliptic Curve Digital Signature Algorithm (ECDSA) as a new authentication mechanism.  This memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='4492'/>
<seriesInfo name='DOI' value='10.17487/RFC4492'/>
</reference>



<reference  anchor='RFC4506' target='http://www.rfc-editor.org/info/rfc4506'>
<front>
<title>XDR: External Data Representation Standard</title>
<author initials='M.' surname='Eisler' fullname='M. Eisler' role='editor'><organization /></author>
<date year='2006' month='May' />
<abstract><t>This document describes the External Data Representation Standard (XDR) protocol as it is currently deployed and accepted.  This document obsoletes RFC 1832.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='67'/>
<seriesInfo name='RFC' value='4506'/>
<seriesInfo name='DOI' value='10.17487/RFC4506'/>
</reference>



<reference  anchor='RFC4507' target='http://www.rfc-editor.org/info/rfc4507'>
<front>
<title>Transport Layer Security (TLS) Session Resumption without Server-Side State</title>
<author initials='J.' surname='Salowey' fullname='J. Salowey'><organization /></author>
<author initials='H.' surname='Zhou' fullname='H. Zhou'><organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'><organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'><organization /></author>
<date year='2006' month='May' />
<abstract><t>This document describes a mechanism that enables the Transport Layer Security (TLS) server to resume sessions and avoid keeping \%per-client session state.  The TLS server encapsulates the session state into a ticket and forwards it to the client.  The client can subsequently resume a session using the obtained ticket.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4507'/>
<seriesInfo name='DOI' value='10.17487/RFC4507'/>
</reference>



<reference  anchor='RFC4681' target='http://www.rfc-editor.org/info/rfc4681'>
<front>
<title>TLS User Mapping Extension</title>
<author initials='S.' surname='Santesson' fullname='S. Santesson'><organization /></author>
<author initials='A.' surname='Medvinsky' fullname='A. Medvinsky'><organization /></author>
<author initials='J.' surname='Ball' fullname='J. Ball'><organization /></author>
<date year='2006' month='October' />
<abstract><t>This document specifies a TLS extension that enables clients to send generic user mapping hints in a supplemental data handshake message defined in RFC 4680.  One such mapping hint is defined in an informative section, the UpnDomainHint, which may be used by a server to locate a user in a directory database.  Other mapping hints may be defined in other documents in the future.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4681'/>
<seriesInfo name='DOI' value='10.17487/RFC4681'/>
</reference>



<reference  anchor='RFC5054' target='http://www.rfc-editor.org/info/rfc5054'>
<front>
<title>Using the Secure Remote Password (SRP) Protocol for TLS Authentication</title>
<author initials='D.' surname='Taylor' fullname='D. Taylor'><organization /></author>
<author initials='T.' surname='Wu' fullname='T. Wu'><organization /></author>
<author initials='N.' surname='Mavrogiannopoulos' fullname='N. Mavrogiannopoulos'><organization /></author>
<author initials='T.' surname='Perrin' fullname='T. Perrin'><organization /></author>
<date year='2007' month='November' />
<abstract><t>This memo presents a technique for using the Secure Remote Password protocol as an authentication method for the Transport Layer Security protocol.  This memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='5054'/>
<seriesInfo name='DOI' value='10.17487/RFC5054'/>
</reference>



<reference  anchor='RFC5077' target='http://www.rfc-editor.org/info/rfc5077'>
<front>
<title>Transport Layer Security (TLS) Session Resumption without Server-Side State</title>
<author initials='J.' surname='Salowey' fullname='J. Salowey'><organization /></author>
<author initials='H.' surname='Zhou' fullname='H. Zhou'><organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'><organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'><organization /></author>
<date year='2008' month='January' />
<abstract><t>This document describes a mechanism that enables the Transport Layer Security (TLS) server to resume sessions and avoid keeping per-client session state.  The TLS server encapsulates the session state into a ticket and forwards it to the client.  The client can subsequently resume a session using the obtained ticket.  This document obsoletes RFC 4507.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5077'/>
<seriesInfo name='DOI' value='10.17487/RFC5077'/>
</reference>



<reference  anchor='RFC5081' target='http://www.rfc-editor.org/info/rfc5081'>
<front>
<title>Using OpenPGP Keys for Transport Layer Security (TLS) Authentication</title>
<author initials='N.' surname='Mavrogiannopoulos' fullname='N. Mavrogiannopoulos'><organization /></author>
<date year='2007' month='November' />
<abstract><t>This memo proposes extensions to the Transport Layer Security (TLS) protocol to support the OpenPGP key format.  The extensions discussed here include a certificate type negotiation mechanism, and the required modifications to the TLS Handshake Protocol.  This memo defines an Experimental Protocol for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='5081'/>
<seriesInfo name='DOI' value='10.17487/RFC5081'/>
</reference>



<reference  anchor='RFC5116' target='http://www.rfc-editor.org/info/rfc5116'>
<front>
<title>An Interface and Algorithms for Authenticated Encryption</title>
<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
<date year='2008' month='January' />
<abstract><t>This document defines algorithms for Authenticated Encryption with Associated Data (AEAD), and defines a uniform interface and a registry for such algorithms.  The interface and registry can be used as an application-independent set of cryptoalgorithm suites.  This approach provides advantages in efficiency and security, and promotes the reuse of crypto implementations.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5116'/>
<seriesInfo name='DOI' value='10.17487/RFC5116'/>
</reference>



<reference  anchor='RFC5246' target='http://www.rfc-editor.org/info/rfc5246'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5246'/>
<seriesInfo name='DOI' value='10.17487/RFC5246'/>
</reference>



<reference  anchor='RFC5746' target='http://www.rfc-editor.org/info/rfc5746'>
<front>
<title>Transport Layer Security (TLS) Renegotiation Indication Extension</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='M.' surname='Ray' fullname='M. Ray'><organization /></author>
<author initials='S.' surname='Dispensa' fullname='S. Dispensa'><organization /></author>
<author initials='N.' surname='Oskov' fullname='N. Oskov'><organization /></author>
<date year='2010' month='February' />
<abstract><t>Secure Socket Layer (SSL) and Transport Layer Security (TLS) renegotiation are vulnerable to an attack in which the attacker forms a TLS connection with the target server, injects content of his choice, and then splices in a new TLS connection from a client.  The server treats the client's initial TLS handshake as a renegotiation and thus believes that the initial data transmitted by the attacker is from the same entity as the subsequent client data.  This specification defines a TLS extension to cryptographically tie renegotiations to the TLS connections they are being performed over, thus preventing this attack.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5746'/>
<seriesInfo name='DOI' value='10.17487/RFC5746'/>
</reference>



<reference  anchor='RFC5764' target='http://www.rfc-editor.org/info/rfc5764'>
<front>
<title>Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)</title>
<author initials='D.' surname='McGrew' fullname='D. McGrew'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2010' month='May' />
<abstract><t>This document describes a Datagram Transport Layer Security (DTLS) extension to establish keys for Secure RTP (SRTP) and Secure RTP Control Protocol (SRTCP) flows.  DTLS keying happens on the media path, independent of any out-of-band signalling channel present. [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5764'/>
<seriesInfo name='DOI' value='10.17487/RFC5764'/>
</reference>



<reference  anchor='RFC5878' target='http://www.rfc-editor.org/info/rfc5878'>
<front>
<title>Transport Layer Security (TLS) Authorization Extensions</title>
<author initials='M.' surname='Brown' fullname='M. Brown'><organization /></author>
<author initials='R.' surname='Housley' fullname='R. Housley'><organization /></author>
<date year='2010' month='May' />
<abstract><t>This document specifies authorization extensions to the Transport Layer Security (TLS) Handshake Protocol.  Extensions are carried in the client and server hello messages to confirm that both parties support the desired authorization data types.  Then, if supported by both the client and the server, authorization information, such as attribute certificates (ACs) or Security Assertion Markup Language (SAML)  assertions, is exchanged in the supplemental data handshake message. This document defines an Experimental Protocol for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='5878'/>
<seriesInfo name='DOI' value='10.17487/RFC5878'/>
</reference>



<reference  anchor='RFC5929' target='http://www.rfc-editor.org/info/rfc5929'>
<front>
<title>Channel Bindings for TLS</title>
<author initials='J.' surname='Altman' fullname='J. Altman'><organization /></author>
<author initials='N.' surname='Williams' fullname='N. Williams'><organization /></author>
<author initials='L.' surname='Zhu' fullname='L. Zhu'><organization /></author>
<date year='2010' month='July' />
<abstract><t>This document defines three channel binding types for Transport Layer Security (TLS), tls-unique, tls-server-end-point, and tls-unique-for-telnet, in accordance with RFC 5056 (On Channel Binding).</t><t>Note that based on implementation experience, this document changes the original definition of 'tls-unique' channel binding type in the channel binding type IANA registry.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5929'/>
<seriesInfo name='DOI' value='10.17487/RFC5929'/>
</reference>



<reference  anchor='RFC6176' target='http://www.rfc-editor.org/info/rfc6176'>
<front>
<title>Prohibiting Secure Sockets Layer (SSL) Version 2.0</title>
<author initials='S.' surname='Turner' fullname='S. Turner'><organization /></author>
<author initials='T.' surname='Polk' fullname='T. Polk'><organization /></author>
<date year='2011' month='March' />
<abstract><t>This document requires that when Transport Layer Security (TLS) clients and servers establish connections, they never negotiate the use of  Secure Sockets Layer (SSL) version 2.0.  This document updates the  backward compatibility sections found in the Transport Layer Security (TLS). [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6176'/>
<seriesInfo name='DOI' value='10.17487/RFC6176'/>
</reference>



<reference  anchor='RFC6091' target='http://www.rfc-editor.org/info/rfc6091'>
<front>
<title>Using OpenPGP Keys for Transport Layer Security (TLS) Authentication</title>
<author initials='N.' surname='Mavrogiannopoulos' fullname='N. Mavrogiannopoulos'><organization /></author>
<author initials='D.' surname='Gillmor' fullname='D. Gillmor'><organization /></author>
<date year='2011' month='February' />
<abstract><t>This memo defines Transport Layer Security (TLS) extensions and associated semantics that allow clients and servers to negotiate the use of OpenPGP certificates for a TLS session, and specifies how to transport OpenPGP certificates via TLS.  It also defines the registry for non-X.509 certificate types.  This document is not an Internet  Standards Track specification; it is published for informational purposes.</t></abstract>
</front>
<seriesInfo name='RFC' value='6091'/>
<seriesInfo name='DOI' value='10.17487/RFC6091'/>
</reference>



<reference  anchor='RFC6520' target='http://www.rfc-editor.org/info/rfc6520'>
<front>
<title>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension</title>
<author initials='R.' surname='Seggelmann' fullname='R. Seggelmann'><organization /></author>
<author initials='M.' surname='Tuexen' fullname='M. Tuexen'><organization /></author>
<author initials='M.' surname='Williams' fullname='M. Williams'><organization /></author>
<date year='2012' month='February' />
<abstract><t>This document describes the Heartbeat Extension for the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols.</t><t>The Heartbeat Extension provides a new protocol for TLS/DTLS allowing the usage of keep-alive functionality without performing a renegotiation and a basis for path MTU (PMTU) discovery for DTLS.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6520'/>
<seriesInfo name='DOI' value='10.17487/RFC6520'/>
</reference>



<reference  anchor='RFC7301' target='http://www.rfc-editor.org/info/rfc7301'>
<front>
<title>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</title>
<author initials='S.' surname='Friedl' fullname='S. Friedl'><organization /></author>
<author initials='A.' surname='Popov' fullname='A. Popov'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<author initials='E.' surname='Stephan' fullname='E. Stephan'><organization /></author>
<date year='2014' month='July' />
<abstract><t>This document describes a Transport Layer Security (TLS) extension for application-layer protocol negotiation within the TLS handshake. For instances in which multiple application protocols are supported on the same TCP or UDP port, this extension allows the application layer to negotiate which protocol will be used within the TLS connection.</t></abstract>
</front>
<seriesInfo name='RFC' value='7301'/>
<seriesInfo name='DOI' value='10.17487/RFC7301'/>
</reference>



<reference  anchor='RFC7230' target='http://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor='RFC7250' target='http://www.rfc-editor.org/info/rfc7250'>
<front>
<title>Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
<author initials='P.' surname='Wouters' fullname='P. Wouters' role='editor'><organization /></author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig' role='editor'><organization /></author>
<author initials='J.' surname='Gilmore' fullname='J. Gilmore'><organization /></author>
<author initials='S.' surname='Weiler' fullname='S. Weiler'><organization /></author>
<author initials='T.' surname='Kivinen' fullname='T. Kivinen'><organization /></author>
<date year='2014' month='June' />
<abstract><t>This document specifies a new certificate type and two TLS extensions for exchanging raw public keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS).  The new certificate type allows raw public keys to be used for authentication.</t></abstract>
</front>
<seriesInfo name='RFC' value='7250'/>
<seriesInfo name='DOI' value='10.17487/RFC7250'/>
</reference>



<reference  anchor='RFC7366' target='http://www.rfc-editor.org/info/rfc7366'>
<front>
<title>Encrypt-then-MAC for Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
<author initials='P.' surname='Gutmann' fullname='P. Gutmann'><organization /></author>
<date year='2014' month='September' />
<abstract><t>This document describes a means of negotiating the use of the encrypt-then-MAC security mechanism in place of the existing MAC-then-encrypt mechanism in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS).  The MAC-then-encrypt mechanism has been the subject of a number of security vulnerabilities over a period of many years.</t></abstract>
</front>
<seriesInfo name='RFC' value='7366'/>
<seriesInfo name='DOI' value='10.17487/RFC7366'/>
</reference>



<reference  anchor='RFC7465' target='http://www.rfc-editor.org/info/rfc7465'>
<front>
<title>Prohibiting RC4 Cipher Suites</title>
<author initials='A.' surname='Popov' fullname='A. Popov'><organization /></author>
<date year='2015' month='February' />
<abstract><t>This document requires that Transport Layer Security (TLS) clients and servers never negotiate the use of RC4 cipher suites when they establish connections.  This applies to all TLS versions.  This document updates RFCs 5246, 4346, and 2246.</t></abstract>
</front>
<seriesInfo name='RFC' value='7465'/>
<seriesInfo name='DOI' value='10.17487/RFC7465'/>
</reference>



<reference  anchor='RFC7568' target='http://www.rfc-editor.org/info/rfc7568'>
<front>
<title>Deprecating Secure Sockets Layer Version 3.0</title>
<author initials='R.' surname='Barnes' fullname='R. Barnes'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson'><organization /></author>
<author initials='A.' surname='Pironti' fullname='A. Pironti'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<date year='2015' month='June' />
<abstract><t>The Secure Sockets Layer version 3.0 (SSLv3), as specified in RFC 6101, is not sufficiently secure.  This document requires that SSLv3 not be used.  The replacement versions, in particular, Transport Layer Security (TLS) 1.2 (RFC 5246), are considerably more secure and capable protocols.</t><t>This document updates the backward compatibility section of RFC 5246 and its predecessors to prohibit fallback to SSLv3.</t></abstract>
</front>
<seriesInfo name='RFC' value='7568'/>
<seriesInfo name='DOI' value='10.17487/RFC7568'/>
</reference>



<reference  anchor='RFC7627' target='http://www.rfc-editor.org/info/rfc7627'>
<front>
<title>Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension</title>
<author initials='K.' surname='Bhargavan' fullname='K. Bhargavan' role='editor'><organization /></author>
<author initials='A.' surname='Delignat-Lavaud' fullname='A. Delignat-Lavaud'><organization /></author>
<author initials='A.' surname='Pironti' fullname='A. Pironti'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<author initials='M.' surname='Ray' fullname='M. Ray'><organization /></author>
<date year='2015' month='September' />
<abstract><t>The Transport Layer Security (TLS) master secret is not cryptographically bound to important session parameters such as the server certificate.  Consequently, it is possible for an active attacker to set up two sessions, one with a client and another with a server, such that the master secrets on the two sessions are the same.  Thereafter, any mechanism that relies on the master secret for authentication, including session resumption, becomes vulnerable to a man-in-the-middle attack, where the attacker can simply forward messages back and forth between the client and server.  This specification defines a TLS extension that contextually binds the master secret to a log of the full handshake that computes it, thus preventing such attacks.</t></abstract>
</front>
<seriesInfo name='RFC' value='7627'/>
<seriesInfo name='DOI' value='10.17487/RFC7627'/>
</reference>



<reference  anchor='RFC7685' target='http://www.rfc-editor.org/info/rfc7685'>
<front>
<title>A Transport Layer Security (TLS) ClientHello Padding Extension</title>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<date year='2015' month='October' />
<abstract><t>This memo describes a Transport Layer Security (TLS) extension that can be used to pad ClientHello messages to a desired size.</t></abstract>
</front>
<seriesInfo name='RFC' value='7685'/>
<seriesInfo name='DOI' value='10.17487/RFC7685'/>
</reference>



<reference  anchor='RFC5996' target='http://www.rfc-editor.org/info/rfc5996'>
<front>
<title>Internet Key Exchange Protocol Version 2 (IKEv2)</title>
<author initials='C.' surname='Kaufman' fullname='C. Kaufman'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<author initials='Y.' surname='Nir' fullname='Y. Nir'><organization /></author>
<author initials='P.' surname='Eronen' fullname='P. Eronen'><organization /></author>
<date year='2010' month='September' />
<abstract><t>This document describes version 2 of the Internet Key Exchange (IKE) protocol.  IKE is a component of IPsec used for performing mutual authentication and establishing and maintaining Security Associations (SAs).  This document replaces and updates RFC 4306, and includes all of the clarifications from RFC 4718.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5996'/>
<seriesInfo name='DOI' value='10.17487/RFC5996'/>
</reference>



<reference  anchor='RFC2522' target='http://www.rfc-editor.org/info/rfc2522'>
<front>
<title>Photuris: Session-Key Management Protocol</title>
<author initials='P.' surname='Karn' fullname='P. Karn'><organization /></author>
<author initials='W.' surname='Simpson' fullname='W. Simpson'><organization /></author>
<date year='1999' month='March' />
<abstract><t>This document defines the basic protocol mechanisms. This document defines an Experimental Protocol for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='2522'/>
<seriesInfo name='DOI' value='10.17487/RFC2522'/>
</reference>



<reference  anchor='RFC4340' target='http://www.rfc-editor.org/info/rfc4340'>
<front>
<title>Datagram Congestion Control Protocol (DCCP)</title>
<author initials='E.' surname='Kohler' fullname='E. Kohler'><organization /></author>
<author initials='M.' surname='Handley' fullname='M. Handley'><organization /></author>
<author initials='S.' surname='Floyd' fullname='S. Floyd'><organization /></author>
<date year='2006' month='March' />
<abstract><t>The Datagram Congestion Control Protocol (DCCP) is a transport protocol that provides bidirectional unicast connections of congestion-controlled unreliable datagrams.  DCCP is suitable for applications that transfer fairly large amounts of data and that can benefit from control over the tradeoff between timeliness and reliability.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4340'/>
<seriesInfo name='DOI' value='10.17487/RFC4340'/>
</reference>



<reference  anchor='RFC5238' target='http://www.rfc-editor.org/info/rfc5238'>
<front>
<title>Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP)</title>
<author initials='T.' surname='Phelan' fullname='T. Phelan'><organization /></author>
<date year='2008' month='May' />
<abstract><t>This document specifies the use of Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP).  DTLS provides communications privacy for applications that use datagram transport protocols and allows client/server applications to communicate in a way that is designed to prevent eavesdropping and detect tampering or message forgery.  DCCP is a transport protocol that provides a congestion-controlled unreliable datagram service.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5238'/>
<seriesInfo name='DOI' value='10.17487/RFC5238'/>
</reference>



<reference  anchor='RFC7525' target='http://www.rfc-editor.org/info/rfc7525'>
<front>
<title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
<author initials='Y.' surname='Sheffer' fullname='Y. Sheffer'><organization /></author>
<author initials='R.' surname='Holz' fullname='R. Holz'><organization /></author>
<author initials='P.' surname='Saint-Andre' fullname='P. Saint-Andre'><organization /></author>
<date year='2015' month='May' />
<abstract><t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are widely used to protect data exchanged over application protocols such as HTTP, SMTP, IMAP, POP, SIP, and XMPP.  Over the last few years, several serious attacks on TLS have emerged, including attacks on its most commonly used cipher suites and their modes of operation.  This document provides recommendations for improving the security of deployed services that use TLS and DTLS. The recommendations are applicable to the majority of use cases.</t></abstract>
</front>
<seriesInfo name='BCP' value='195'/>
<seriesInfo name='RFC' value='7525'/>
<seriesInfo name='DOI' value='10.17487/RFC7525'/>
</reference>



<reference anchor='I-D.ietf-tls-negotiated-ff-dhe'>
<front>
<title>Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for TLS</title>

<author initials='D' surname='Gillmor' fullname='Daniel Kahn Gillmor'>
    <organization />
</author>

<date month='June' day='1' year='2015' />

<abstract><t>Traditional finite-field-based Diffie-Hellman (DH) key exchange during the TLS handshake suffers from a number of security, interoperability, and efficiency shortcomings.  These shortcomings arise from lack of clarity about which DH group parameters TLS servers should offer and clients should accept.  This document offers a solution to these shortcomings for compatible peers by using a section of the TLS "EC Named Curve Registry" to establish common finite-field DH parameters with known structure and a mechanism for peers to negotiate support for these groups.  This draft updates TLS versions 1.0 [RFC2246], 1.1 [RFC4346], and 1.2 [RFC5246], as well as the TLS ECC extensions [RFC4492].</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-tls-negotiated-ff-dhe-10' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-tls-negotiated-ff-dhe-10.txt' />
</reference>


<reference anchor="DSS" >
  <front>
    <title>Digital Signature Standard, version 4</title>
    <author >
      <organization>National Institute of Standards and Technology, U.S. Department of Commerce</organization>
    </author>
    <date year="2013"/>
  </front>
  <seriesInfo name="NIST" value="FIPS PUB 186-4"/>
</reference>
<reference anchor="ECDSA" >
  <front>
    <title>Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
    <author >
      <organization>American National Standards Institute</organization>
    </author>
    <date year="2005" month="November"/>
  </front>
  <seriesInfo name="ANSI" value="ANS X9.62-2005"/>
</reference>
<reference anchor="FI06" target="https://www.ietf.org/mail-archive/web/openpgp/current/msg00999.html">
  <front>
    <title>Bleichenbacher's RSA signature forgery based on implementation error</title>
    <author initials="H." surname="Finney" fullname="Hal Finney">
      <organization></organization>
    </author>
    <date year="2006" month="August" day="27"/>
  </front>
</reference>
<reference anchor="GCM" >
  <front>
    <title>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</title>
    <author initials="M." surname="Dworkin">
      <organization></organization>
    </author>
    <date year="2007" month="November"/>
  </front>
  <seriesInfo name="NIST" value="Special Publication 800-38D"/>
</reference>
<reference anchor="PKCS6" >
  <front>
    <title>PKCS #6: RSA Extended Certificate Syntax Standard, version 1.5</title>
    <author >
      <organization>RSA Laboratories</organization>
    </author>
    <date year="1993" month="November"/>
  </front>
</reference>
<reference anchor="PKCS7" >
  <front>
    <title>PKCS #7: RSA Cryptographic Message Syntax Standard, version 1.5</title>
    <author >
      <organization>RSA Laboratories</organization>
    </author>
    <date year="1993" month="November"/>
  </front>
</reference>
<reference anchor="RSA" >
  <front>
    <title>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</title>
    <author initials="R." surname="Rivest">
      <organization></organization>
    </author>
    <author initials="A." surname="Shamir">
      <organization></organization>
    </author>
    <author initials="L.M." surname="Adleman">
      <organization></organization>
    </author>
    <date year="1978" month="February"/>
  </front>
  <seriesInfo name="Communications of the ACM" value="v. 21, n. 2, pp. 120-126."/>
</reference>
<reference anchor="SSL2" >
  <front>
    <title>The SSL Protocol</title>
    <author initials="K." surname="Hickman" fullname="Kipp Hickman">
      <organization>Netscape Communications Corp.</organization>
    </author>
    <date year="1995" month="February" day="09"/>
  </front>
</reference>
<reference anchor="SSL3" >
  <front>
    <title>The SSL 3.0 Protocol</title>
    <author initials="A." surname="Freier">
      <organization>Netscape Communications Corp.</organization>
    </author>
    <author initials="P." surname="Karlton">
      <organization>Netscape Communications Corp.</organization>
    </author>
    <author initials="P." surname="Kocher">
      <organization>Netscape Communications Corp.</organization>
    </author>
    <date year="1996" month="November" day="18"/>
  </front>
</reference>
<reference anchor="TIMING" >
  <front>
    <title>Remote timing attacks are practical</title>
    <author initials="D." surname="Boneh">
      <organization></organization>
    </author>
    <author initials="D." surname="Brumley">
      <organization></organization>
    </author>
    <date year="2003"/>
  </front>
  <seriesInfo name="USENIX" value="Security Symposium"/>
</reference>
<reference anchor="X501" >
  <front>
    <title>Information Technology - Open Systems Interconnection - The Directory: Models</title>
    <author >
      <organization></organization>
    </author>
    <date year="1993"/>
  </front>
  <seriesInfo name="ITU-T" value="X.501"/>
</reference>
<reference anchor="IEEE1363" >
  <front>
    <title>Standard Specifications for Public Key Cryptography</title>
    <author >
      <organization>IEEE</organization>
    </author>
    <date year="2000"/>
  </front>
  <seriesInfo name="IEEE 1363" value=""/>
</reference>
<reference anchor="PSK-FINISHED" target="https://www.ietf.org/mail-archive/web/tls/current/msg18215.html">
  <front>
    <title>Revision 10: possible attack if client authentication is allowed during PSK</title>
    <author initials="C." surname="Cremers">
      <organization></organization>
    </author>
    <author initials="M." surname="Horvat">
      <organization></organization>
    </author>
    <author initials="T." surname="van der Merwe">
      <organization></organization>
    </author>
    <author initials="S." surname="Scott">
      <organization></organization>
    </author>
    <date year="2015"/>
  </front>
</reference>
<reference anchor="SLOTH" >
  <front>
    <title>Transcript Collision Attacks: Breaking Authentication in TLS, IKE, and SSH</title>
    <author initials="K." surname="Bhargavan">
      <organization></organization>
    </author>
    <author initials="G." surname="Leurent">
      <organization></organization>
    </author>
    <date year="2016"/>
  </front>
  <seriesInfo name="Network and Distributed System Security Symposium (NDSS 2016)" value=""/>
</reference>
<reference anchor="TLS13" >
  <front>
    <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
    <author initials="E." surname="Rescorla">
      <organization></organization>
    </author>
    <date year="2016" month="July" day="11"/>
  </front>
  <seriesInfo name="IETF" value="draft-ietf-tls-tls13-14"/>
</reference>


    </references>


<section anchor="history" title="History">

<t>RFC EDITOR: PLEASE REMOVE THE THIS SECTION</t>

<t>draft-00</t>

<t><list style="symbols">
  <t>Initial version using TLS 1.3 as a baseline.</t>
  <t>Use of epoch values instead of KeyUpdate message</t>
  <t>Use of cookie extension instead of cookie field in 
ClientHello and HelloVerifyRequest messages</t>
</list></t>

</section>
<section anchor="working-group-information" title="Working Group Information">

<t>The discussion list for the IETF TLS working group is located at the e-mail
address <eref target="mailto:tls@ietf.org">tls@ietf.org</eref>. Information on the group and information on how to
subscribe to the list is at <eref target="https://www1.ietf.org/mailman/listinfo/tls">https://www1.ietf.org/mailman/listinfo/tls</eref></t>

<t>Archives of the list can be found at:
<eref target="https://www.ietf.org/mail-archive/web/tls/current/index.html">https://www.ietf.org/mail-archive/web/tls/current/index.html</eref></t>

</section>
<section anchor="contributors" title="Contributors">

<t>Many people have contributed to previous DTLS versions and they are acknowledged
in prior versions of DTLS specifications.</t>

<t>For this version of the document we would like to thank:</t>

<t><list style="symbols">
  <t>Nagendra Modadugu (co-author of <xref target="RFC6347"/>)<vspace />
Google, Inc.<vspace />
nagendra@cs.stanford.edu</t>
  <t>Hannes Tschofenig<vspace />
ARM Limited<vspace />
hannes.tschofenig@arm.com</t>
</list></t>

</section>


  </back>
</rfc>

