<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.24 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="pre5378Trust200902" docName="draft-fossati-tls-attestation-00" category="std">
  <front>
    <title abbrev="Attestation in TLS/DTLS">Using Attestation in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>

    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Arm Limited</organization>
      <address>
        <email>hannes.tschofenig@arm.com</email>
      </address>
    </author>
    <author initials="T." surname="Fossati" fullname="Thomas Fossati">
      <organization>Arm Limited</organization>
      <address>
        <email>Thomas.Fossati@arm.com</email>
      </address>
    </author>
    <author initials="P." surname="Howard" fullname="Paul Howard">
      <organization>Arm Limited</organization>
      <address>
        <email>Paul.Howard@arm.com</email>
      </address>
    </author>
    <author initials="I." surname="Mihalcea" fullname="Ionut Mihalcea">
      <organization>Arm Limited</organization>
      <address>
        <email>Ionut.Mihalcea@arm.com</email>
      </address>
    </author>
    <author initials="Y." surname="Deshpande" fullname="Yogesh Deshpande">
      <organization>Arm Limited</organization>
      <address>
        <email>Yogesh.Deshpande@arm.com</email>
      </address>
    </author>

    <date year="2022" month="July" day="11"/>

    <area>Security</area>
    <workgroup>TLS</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>Various attestation technologies have been developed and formats have been standardized.
Examples include the Entity Attestation Token (EAT) and Trusted Platform Modules (TPMs).
Once attestation information has been produced on a device it needs to be communicated
to a relying party. This information exchange may happen at different layers in the 
protocol stack.</t>

<t>This specification provides a generic way of passing attestation information in the 
TLS handshake.</t>



    </abstract>



  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Attestation is the process by which an entity produces evidence about itself
that another party can use to evaluate the trustworthiness of that entity. 
One format of encoding evidence is standardized with the Entity Attestation 
Token (EAT) <xref target="I-D.ietf-rats-eat"/> but there are other formats, such as 
attestation produced by Trusted Platform Modules (TPMs) <xref target="TPM1.2"/> <xref target="TPM2.0"/>.</t>

<t>This specification defines how to convey attestation information in the 
TLS handshake with different encodings being supported. This specification
standardizes two attestation formats – EAT and TPM-based attestation.</t>

<t>Note: This initial version of the specification focuses on EAT-based attestation.
Future versions will also define TPM-based attestation.</t>

</section>
<section anchor="conventions-and-terminology" title="Conventions and Terminology">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

<t>The following terms are used in this document:</t>

<t><list style="symbols">
  <t>Root of Trust (RoT): A set of software and/or hardware components that need 
to be trusted to act as a security foundation required for accomplishing the
security goals. In our case, the RoT is expected to offer the functionality 
for attesting to the state of the platform.</t>
  <t>Attestation Key (AK): Cryptographic key belonging to the RoT that is only used
 to sign attestation tokens.</t>
  <t>Platform Attestation Key (PAK): An AK used specifically for signing attestation 
tokens relating to the state of the platform.</t>
  <t>Key Attestation Key (KAK): An AK used specifically for signing KATs. In some 
systems only a single AK is used. In that case the AK is used as a PAK and a KAK.</t>
  <t>TLS Identity Key (TIK): The KIK consists of a private and a public key. The private key is used in the CertificateVerify message during the TLS handshake. The public key is included in the Key Attestation Token.</t>
  <t>Attestation Token (AT): A collection of claims that a RoT assembles (and signs) with the purpose of informing - in a verifiable way - Relying Parties about the identity and state of the platform. Essentially a type of “Evidence” as per the RATS architecture terminology.</t>
  <t>Platform Attestation Token (PAT): An AT containing claims relating to the state of the software running on the platform. The process of generating a PAT typically involves gathering data during measured boot.</t>
  <t>Key Attestation Token (KAT, read as “Kate”): An AT containing a claim with a proof-of-possession (PoP) key. The KAT may also contain other claims, such as those indicating its validity. The KAT is signed by the KAK. The attestation 
service part of the RoT conceptually acts as a local certification authority since the KAT behaves like a certificate.</t>
  <t>Combined Attestation Bundle (CAB): A structure used to bundle a KAT and a PAT together for transport in the TLS handshake. If the KAT already includes a PAT, in form of a nested token, then it already corresponds to a CAB.</t>
</list></t>

</section>
<section anchor="overview" title="Overview">

<t>The Remote Attestation Procedures (RATS) architecture <xref target="I-D.ietf-rats-architecture"/>
defines two types of interaction models for attestation, 
namely the passport model and the background-check model. The subsections below
explain the difference in their interactions.</t>

<t>To simplify the description in this section we focus on the use case where the 
client is the attester and the server is the relying party. Hence, only the
client_attestation_type extension is discussed. The verifier is not shown in 
the diagrams. The described mechanism allows the roles to be reversed.</t>

<t>As typical with new features in TLS, the client indicates support for the new 
extension in the ClientHello. The client_attestation_type extension lists the
supported attestation formats. The server, if it supports the extension and one of the
attestation formats, it confirms the use of the feature.</t>

<t>Note: The newly introduced extension also allows nonces to be exchanged. Those
nonces are used for guaranteeing freshness of the generated attestation tokens.</t>

<t>When the attestation extension is successfully negotiated, the content of the
Certificate message is replaced with attestation information described in this
document.</t>

<t>A peer has to demonstrate possession of the private key via the CertificateVerify
message. While attestation information is signed by the attester, it typically
does not contain a public key (for example via a proof-of-possession key claim
<xref target="RFC8747"/>).</t>

<t>The attestation service on a device, which creates the attestation information, 
is unaware of the TLS exchange and the attestation service does not directly 
sign externally provided data, as it would be required to compute the CertificateVerify message.</t>

<t>Hence, the following steps happen:</t>

<t>The client generates the TIK, which are referred here as skT and pkT, for example
using the following API call:</t>

<figure><artwork><![CDATA[
key_id = GenerateKeyPair(alg_id)
]]></artwork></figure>

<t>The private key would be created and stored by the crypto hardware supported by
the device (rather than the TLS client in software).</t>

<t>Next, the attestation service needs to be triggered to create a Platform
Attestation Token (PAT) and the Key Attestation Token (KAT). The Key Attestation 
Token (KAT) includes a claim containing the
public key of the TIK (pkT). The KAT is then signed with the Key Attestation
Key (KAK).</t>

<t>To ensure freshness of the PAT and the KAT a nonce is provided by the relying 
party / verifier. Here is the symbolic API call to request a KAT and a PAT, which 
are concatinated together as the CAB.</t>

<figure><artwork><![CDATA[
cab = createCAB(key_id, nonce)
]]></artwork></figure>

<t>Once the Certificate message containing the CAB has been sent, the CertificateVerify
has to be created and it requires access to the private key. The signature operation
uses the private key of the TIK (skT).</t>

<t>The recipient of the Certificate and the CertificateVerify messages first extracts 
the PAT and the KAT from the Certificate message. The PAT and the KAT need to be 
conveyed to the verification service, whereby the following checks are made:</t>

<t><list style="symbols">
  <t>The signature protecting the PAT passes verification when using available trust anchor(s).</t>
  <t>The PAT has not been replayed, which can be checked by comparing the nonce included
in one of the claims and matching it against the nonce provided to the attester.</t>
  <t>The claims in the PAT are matched against stored reference values.</t>
  <t>The signature protecting the KAT passes verification.</t>
  <t>The claims in the KAT are validated, if needed.</t>
</list></t>

<t>Once all these steps are completed, the verifier produces the attestation result and
includes (if needed) the TIK public key.</t>

<t>In the subsections we will look at how the two message pattern fit align with the 
TLS exchange.</t>

<section anchor="attestation-within-the-passport-model" title="Attestation within the Passport Model">

<t>The passport model is described in Section 5.1 of <xref target="I-D.ietf-rats-architecture"/>. A key feature 
of this model is that the attester interacts with the verification service before initiating 
the TLS exchange. It sends evidence to the verification service, which then returns the 
attestation result (including the TIK public key).</t>

<t>The example exchange in <xref target="_figure-passport-model"/> shows how a client
provides attestation to the server by utilizing EAT tokens <xref target="I-D.ietf-rats-eat"/>.
With the ClientHello the TLS client needs to indicate that it supports the EAT-based
attestation format. The TLS server acknowledges support for this attestation type in
the EncryptedExtensions message. </t>

<t>In the Certificate message the TLS client transmits the attestation result to the TLS 
server, in form a CAB (i.e. a concatinated PAT and KAT).</t>

<t>The TLS client then creates the CertificateVerify message by asking the crypto 
service to sign the TLS handshake message transcript with the TIK private key. 
The TLS server then verifies this message by utilizing the TIK public key.</t>

<figure title="Example Exchange with the Passport Model." anchor="_figure-passport-model"><artwork><![CDATA[
    Client                                           Server

Key  ^ ClientHello
Exch | + client_attestation_type(eat)
     |
     |
     v                         -------->
                                                  ServerHello ^ KeyExch
                                        {EncryptedExtensions} ^ Server
                               + client_attestation_type(eat) |
                                         {CertificateRequest} v Params
                                                {Certificate} ^
                                          {CertificateVerify} | Auth
                                                   {Finished} v
                               <--------  [Application Data*]
     ^ {Certificate}
Auth | {CertificateVerify}
     v {Finished}              -------->
       [Application Data]      <------->  [Application Data]
]]></artwork></figure>

</section>
<section anchor="attestation-within-the-background-check-model" title="Attestation within the Background Check Model">

<t>The background check model is described in Section 5.2 of <xref target="I-D.ietf-rats-architecture"/>.</t>

<t>The message exchange of the background check model differs from the passport 
model because the TLS server needs to provide a nonce in the ServerHello to the 
TLS client so that the attestation service can feed the nonce into the generation
of the PAT. The TLS server, when receiving the CAB, will have to contact the 
verification service.</t>

<figure title="Example Exchange with the Background Check Model." anchor="_figure-background-check-model"><artwork><![CDATA[
       Client                                           Server

Key  ^ ClientHello
Exch | + client_attestation_type(eat)
     |
     |
     v                         -------->
                                                  ServerHello  ^ Key
                                 client_attestation_type(eat)  | Exch
                                                      + nonce  v
                                        {EncryptedExtensions}  ^  Server
                                         {CertificateRequest}  v  Params
                                                {Certificate}  ^
                                          {CertificateVerify}  | Auth
                                                   {Finished}  v
                               <--------  [Application Data*]
     ^ {Certificate}
Auth | {CertificateVerify}
     v {Finished}              -------->
       [Application Data]      <------->  [Application Data]
]]></artwork></figure>

</section>
</section>
<section anchor="tls-attestation-type-extension" title="TLS Attestation Type Extension">

<t>This document defines a new extension to carry the assertion types.
The extension is conceptually similiar to the ‘server_certificate_type’
and the ‘server_certificate_type’ defined by <xref target="RFC7250"/>.</t>

<figure title="AssertionTypeExtension Structure." anchor="_figure-assertion-type"><artwork><![CDATA[
   struct {
           select(ClientOrServerExtension) {
               case client:
                 CertificateType client_assertion_types<1..2^8-1>;
                 opaque nonce<0..2^16-1>;
                 
               case server:
                 CertificateType client_assertion_type;
                 opaque nonce<0..2^16-1>;                 
           }
   } ClientAssertionTypeExtension;

   struct {
           select(ClientOrServerExtension) {
               case client:
                 CertificateType server_assertion_types<1..2^8-1>;
                 opaque nonce<0..2^16-1>;                 

               case server:
                 CertificateType server_assertion_type;
                 opaque nonce<0..2^16-1>;                                  
           }
   } ServerAssertionTypeExtension;
]]></artwork></figure>

<t>The Certificate payload is used as a container, as shown in 
<xref target="_figure-certificate"/>.  The shown Certificate structure is
an adaptation of <xref target="RFC8446"/>.</t>

<figure title="Certificate Message." anchor="_figure-certificate"><artwork><![CDATA[
      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

                /* assertion type defined in this document */
              case EAT:
                opaque cab<1..2^24-1>;
              
                /* assertion type defined in a future version */
              case TPM:
                opaque tpmStmtFormat<1..2^24-1>;
              
              case X509:
                opaque cert_data<1..2^24-1>;
          };
          Extension extensions<0..2^16-1>;
      } CertificateEntry;

      struct {
          opaque certificate_request_context<0..2^8-1>;
          CertificateEntry certificate_list<0..2^24-1>;
      } Certificate;
]]></artwork></figure>

<t>To simplify parsing of an EAT-based attestation payload,
the PAT and the KAT are typed.</t>

</section>
<section anchor="behavior" title="TLS Client and Server Handshake Behavior">

<t>This specification extends the ClientHello and the EncryptedExtensions
   messages, according to <xref target="RFC8446"/>.</t>

<t>The high-level message exchange in <xref target="_figure-overview"/> shows the
   client_assertion_type and server_assertion_type extensions added
   to the ClientHello and the EncryptedExtensions messages.</t>

<figure title="Attestation Message Overview." anchor="_figure-overview"><artwork><![CDATA[
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     | + pre_shared_key*
     | + client_assertion_type
     v + server_assertion_type
     -------->
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                      + client_assertion_type  |
                                      + server_assertion_type                                        
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               <--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              -------->
       [Application Data]      <------->  [Application Data]
]]></artwork></figure>

<section anchor="client-hello" title="Client Hello">

<t>In order to indicate the support of attestation types, clients include
   the client_attestation_type and/or the server_attestation_type
   extensions in the ClientHello.</t>

<t>The client_attestation_type extension in the ClientHello indicates
   the attestation types the client is able to provide to the server,
   when requested using a CertificateRequest message.</t>

<t>The server_attestation_type extension in the ClientHello indicates
   the types of attestation types the client is able to process when 
   provided by the server in a subsequent Certificate payload.</t>

<t>The client_attestation_type and server_attestation_type extensions
   sent in the ClientHello each carry a list of supported attestation
   types, sorted by client preference.  When the client supports only
   one attestation type, it is a list containing a single element.</t>

<t>The TLS client MUST omit attestation types from the
   client_attestation_type extension in the ClientHello if it is not
   equipped with the corresponding attestation functionality, or if 
   it is not configured to use it with the given TLS
   server.  If the client has no attestation types to send in
   the ClientHello it MUST omit the client_attestation_type extension 
   in the ClientHello.</t>

<t>The TLS client MUST omit attestation types from the
   server_attestation_type extension in the ClientHello if it is not
   equipped with the attestation verification functionality.  If the 
   client has no attestation types to send in the ClientHello it
   MUST omit the entire server_attestation_type extension from the
   ClientHello.</t>

</section>
<section anchor="server-hello" title="Server Hello">

<t>If the server receives a ClientHello that contains the
   client_attestation_type extension and/or the server_attestation_type
   extension, then three outcomes are possible:</t>

<t><list style="symbols">
  <t>The server does not support the extension defined in this
 document.  In this case, the server returns the EncryptedExtensions
 without the extensions defined in this document.</t>
  <t>The server supports the extension defined in this document, but
 it does not have any attestation type in common with the client.
 Then, the server terminates the session with a fatal alert of
 type “unsupported_certificate”.</t>
  <t>The server supports the extensions defined in this document and
 has at least one attestation type in common with the client.  In
 this case, the processing rules described below are followed.</t>
</list></t>

<t>The client_attestation_type extension in the ClientHello indicates
   the attestation types the client is able to provide to the server,
   when requested using a certificate_request message.  If the TLS
   server wants to request a certificate from the client (via the
   certificate_request message), it MUST include the
   client_attestation_type extension in the EncryptedExtensions.  This
   client_attestation_type extension in the EncryptedExtensions then indicates
   the content the client is requested to provide in a
   subsequent Certificate payload.  The value conveyed in the
   client_attestation_type extension MUST be selected from one of the
   values provided in the client_attestation_type extension sent in the
   client hello.  The server MUST also include a certificate_request
   payload in the EncryptedExtensions message.</t>

<t>If the server does not send a certificate_request payload (for
   example, because client authentication happens at the application
   layer or no client authentication is required) or none of the
   attestation types supported by the client (as indicated in the
   client_attestation_type extension in the ClientHello) match the
   server-supported attestation types, then the client_attestation_type
   payload in the ServerHello MUST be omitted.</t>

<t>The server_attestation_type extension in the ClientHello indicates
   the types of attestation types the client is able to process when provided
   by the server in a subsequent Certificate message. With the
   server_attestation_type extension in the EncryptedExtensions, the TLS server
   indicates the attestation type carried in the Certificate payload.
   Note that only a single value is permitted in the 
   server_attestation_type extension when carried in the EncryptedExtensions
   message.</t>

</section>
</section>
<section anchor="sec-cons" title="Security and Privacy Considerations">

<t>TBD.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TBD: Create new registry for attestation types.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8446' target='https://www.rfc-editor.org/info/rfc8446'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
<author fullname='E. Rescorla' initials='E.' surname='Rescorla'><organization/></author>
<date month='August' year='2018'/>
<abstract><t>This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t><t>This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='8446'/>
<seriesInfo name='DOI' value='10.17487/RFC8446'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor='RFC8747' target='https://www.rfc-editor.org/info/rfc8747'>
<front>
<title>Proof-of-Possession Key Semantics for CBOR Web Tokens (CWTs)</title>
<author fullname='M. Jones' initials='M.' surname='Jones'><organization/></author>
<author fullname='L. Seitz' initials='L.' surname='Seitz'><organization/></author>
<author fullname='G. Selander' initials='G.' surname='Selander'><organization/></author>
<author fullname='S. Erdtman' initials='S.' surname='Erdtman'><organization/></author>
<author fullname='H. Tschofenig' initials='H.' surname='Tschofenig'><organization/></author>
<date month='March' year='2020'/>
<abstract><t>This specification describes how to declare in a CBOR Web Token (CWT) (which is defined by RFC 8392) that the presenter of the CWT possesses a particular proof-of-possession key. Being able to prove possession of a key is also sometimes described as being the holder-of-key. This specification provides equivalent functionality to &quot;Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)&quot; (RFC 7800) but using Concise Binary Object Representation (CBOR) and CWTs rather than JavaScript Object Notation (JSON) and JSON Web Tokens (JWTs).</t></abstract>
</front>
<seriesInfo name='RFC' value='8747'/>
<seriesInfo name='DOI' value='10.17487/RFC8747'/>
</reference>



<reference anchor='RFC7250' target='https://www.rfc-editor.org/info/rfc7250'>
<front>
<title>Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
<author fullname='P. Wouters' initials='P.' role='editor' surname='Wouters'><organization/></author>
<author fullname='H. Tschofenig' initials='H.' role='editor' surname='Tschofenig'><organization/></author>
<author fullname='J. Gilmore' initials='J.' surname='Gilmore'><organization/></author>
<author fullname='S. Weiler' initials='S.' surname='Weiler'><organization/></author>
<author fullname='T. Kivinen' initials='T.' surname='Kivinen'><organization/></author>
<date month='June' year='2014'/>
<abstract><t>This document specifies a new certificate type and two TLS extensions for exchanging raw public keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS).  The new certificate type allows raw public keys to be used for authentication.</t></abstract>
</front>
<seriesInfo name='RFC' value='7250'/>
<seriesInfo name='DOI' value='10.17487/RFC7250'/>
</reference>


<reference anchor='I-D.ietf-rats-architecture'>
   <front>
      <title>Remote Attestation Procedures Architecture</title>
      <author fullname='Henk Birkholz'>
	 <organization>Fraunhofer SIT</organization>
      </author>
      <author fullname='Dave Thaler'>
	 <organization>Microsoft</organization>
      </author>
      <author fullname='Michael Richardson'>
	 <organization>Sandelman Software Works</organization>
      </author>
      <author fullname='Ned Smith'>
	 <organization>Intel Corporation</organization>
      </author>
      <author fullname='Wei Pan'>
	 <organization>Huawei Technologies</organization>
      </author>
      <date day='14' month='June' year='2022'/>
      <abstract>
	 <t>   In network protocol exchanges it is often useful for one end of a
   communication to know whether the other end is in an intended
   operating state.  This document provides an architectural overview of
   the entities involved that make such tests possible through the
   process of generating, conveying, and evaluating evidentiary claims.
   An attempt is made to provide for a model that is neutral toward
   processor architectures, the content of claims, and protocols.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-rats-architecture-18'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-rats-architecture-18.txt' type='TXT'/>
</reference>


<reference anchor='I-D.ietf-rats-eat'>
   <front>
      <title>The Entity Attestation Token (EAT)</title>
      <author fullname='Laurence Lundblade'>
	 <organization>Security Theory LLC</organization>
      </author>
      <author fullname='Giridhar Mandyam'>
	 <organization>Qualcomm Technologies Inc.</organization>
      </author>
      <author fullname='Jeremy O&#39;Donoghue'>
	 <organization>Qualcomm Technologies Inc.</organization>
      </author>
      <date day='10' month='July' year='2022'/>
      <abstract>
	 <t>   An Entity Attestation Token (EAT) provides an attested claims set
   that describes state and characteristics of an entity, a device like
   a phone, IoT device, network equipment or such.  This claims set is
   used by a relying party, server or service to determine how much it
   wishes to trust the entity.

   An EAT is either a CBOR Web Token (CWT) or JSON Web Token (JWT) with
   attestation-oriented claims.  To a large degree, all this document
   does is extend CWT and JWT.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-rats-eat-14'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-rats-eat-14.txt' type='TXT'/>
</reference>


<reference anchor="TPM1.2" target="https://trustedcomputinggroup.org/resource/tpm-main-specification/">
  <front>
    <title>TPM Main Specification Level 2 Version 1.2, Revision 116</title>
    <author >
      <organization>Trusted Computing Group</organization>
    </author>
    <date year="2011" month="March"/>
  </front>
</reference>
<reference anchor="TPM2.0" target="https://trustedcomputinggroup.org/resource/tpm-library-specification/">
  <front>
    <title>Trusted Platform Module Library Specification, Family "2.0", Level 00, Revision 01.59</title>
    <author >
      <organization>Trusted Computing Group</organization>
    </author>
    <date year="2019" month="November"/>
  </front>
</reference>


    </references>


<section anchor="history" title="History">

<t>RFC EDITOR: PLEASE REMOVE THE THIS SECTION</t>

<t><list style="symbols">
  <t>Initial version</t>
</list></t>

</section>
<section anchor="working-group-information" title="Working Group Information">

<t>The discussion list for the IETF TLS working group is located at the e-mail
address <eref target="mailto:tls@ietf.org">tls@ietf.org</eref>. Information on the group and information on how to
subscribe to the list is at <eref target="https://www1.ietf.org/mailman/listinfo/tls">https://www1.ietf.org/mailman/listinfo/tls</eref></t>

<t>Archives of the list can be found at:
<eref target="https://www.ietf.org/mail-archive/web/tls/current/index.html">https://www.ietf.org/mail-archive/web/tls/current/index.html</eref></t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAPpHzGIAA+1c63LbRpb+ryq9Q5f8YyRHpCRvrpqMaxRbHqts2VqJSTa1
NXY1gSbZKxDgoEHRjKN5ljxLnmzOrRsNEJQpO6md2lqVUyEJ4PTpc/3O6W70
er3trcpWmTlW3zubj9VJVRlX6coWubK5GpQ6d7OirNRLvTSlujLJvLTVUu0O
Xl7tKZ2n6qmu9LjU0zvufYo3b2/p4bA0N8crY7y8OsA7trfSIsn1FHhJSz2q
eqPCObirV2Wup+tneoeH21uJrsy4KJfHylXp9tb2lp2Vx2pWmi/+46uvB+Xc
VY8OD785fASjlkYfB2a2txZFeT0ui/nsWNGg12YJP6XH6iyvTJmbqvcUR0ea
MGCevtVZkQNPS+O2t2b2eHtLqXKUmNRVy8z/rlRVJPFnm6cmr8IvDsRSmpGr
f1hOm9+r0ib1/UkxncLz9XWbZzaPRjPvql5mXdUDQsMigxt7xcPP8BIIcapn
M1BmuBuEMK8mRYm89/AH+rM5PPW8rwYumRQjk9txuMRaeK7z3Liu60U51rn9
mdQB+iyn6qWd2sqk4Q4z1TY7VhMi0a8Cib/qctqH2aF427wM+uoZq7zFyGBS
TLVbubgxF/x8X56/i4WLvnpeLHSZtji40POsfWXj4fHhPj9819hnfXVuJzpL
jG6Nflbk82r14sYM0PN9//xdPPzUV0+Nm8zA7k2LiZ+KMVzpuLwxG0yhHyjE
jGxv5UU5BRo3hjzs8tmTR0dH3/jPX3/++Zfw2eaj9l1ff/X5V/7zV4++OKTP
Z72nfWuqUa/UFcSOMpkAP0k1L03HZaMr+nVwcX7Uf3TMXFe6HBvwx0lVzdzx
wUGFIcWkwO1sXoFvUQTpw9QPSuOKeZmYg2o27cFE856bmcSObEISORB6HGRh
DHUO96ir+B710tyYTD1SP5jS4XfgY19dmhvL346+ZCK1F9NfrTvUARBnHtUT
z6T6G3LJd6UQMI9hbJCFenR4dCQzftQ//LQZZ3ZY6nJ556SFr4tMV6g/dV6k
88yAmdCjTVnsq2d6arOl2gHWdvZFNIeHkTwOj/pffPN7SeRVcWOmQ0hXIJRv
0A57vZ7SQ4jHOqEk8IMubTF3KspAEH6TSV5kxdhCfJzoG6OGxuQqRV6LGQyI
iZFNNb5O+QSigP3ZpP3trdN3ejrLgILNk2yeGlVNjDrNK8yZcY4cFNfw8O7p
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
9V1/Uk0zGuhfxui7qDFXAAA=

-->

</rfc>

