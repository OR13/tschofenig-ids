<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.4 (Ruby 3.0.2) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>

<?rfc rfcedstyle="yes"?>
<?rfc tocindent="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-tschofenig-tls-extended-key-update-01" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="Extended Key Update for TLS">Extended Key Update for Transport Layer Security (TLS) 1.3</title>

    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Siemens</organization>
      <address>
        <email>hannes.tschofenig@gmx.net</email>
      </address>
    </author>
    <author initials="M." surname="Tüxen" fullname="Michael Tüxen">
      <organization>Münster Univ. of Applied Sciences</organization>
      <address>
        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>
    <author initials="T." surname="Reddy" fullname="Tirumaleswar Reddy">
      <organization>Nokia</organization>
      <address>
        <email>kondtir@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Fries" fullname="Steffen Fries">
      <organization>Siemens</organization>
      <address>
        <email>steffen.fries@siemens.com</email>
      </address>
    </author>

    <date year="2024" month="February" day="08"/>

    <area>Security</area>
    <workgroup>TLS</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<?line 72?>

<t>The Transport Layer Security (TLS) 1.3 specification offers a dedicated
message to update cryptographic keys during the lifetime of an ongoing session.
The traffic secret and the initialization vector are updated directionally
but the sender may trigger the recipient, via the request_update field,
to transmit a key update message in the reverse direction.</t>

<t>In environments where sessions are long-lived, such as industrial IoT or
telecommunication networks, this key update alone is insufficient since
forward secrecy is not offered via this mechanism. Earlier versions
of TLS allowed the two peers to perform renegotiation, which is a handshake
that establishes new cryptographic parameters for an existing session.
When a security vulnerability with the renegotiation mechanism was discovered,
RFC 5746 was developed as a fix. Renegotiation has, however, been removed from
version 1.3 leaving a gap in the feature set of TLS.</t>

<t>This specification defines an extended key update that supports forward secrecy.</t>



    </abstract>



  </front>

  <middle>


<?line 91?>

<section anchor="introduction"><name>Introduction</name>

<t>The features of TLS and DTLS have changed over the years and while newer versions
optimized the protocol and at the same time enhanced features (often with the help
of extensions) some functionality was removed without replacement. The ability to
update keys and initialization vectors has been added in TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/>
using the KeyUpdate message and it intended to (partially) replace renegotiation from earlier
TLS versions. The renegotiation feature, while complex, offered additional
functionality that is not supported with TLS 1.3 anymore, including the update
keys with a Diffie-Hellman exchange during the lifetime of a session. If a traffic
secret (referred as application_traffic_secret_N) has been compromised, an attacker
can passively eavesdrop on all future data sent on the connection, including data
encrypted with application_traffic_secret_N+1, application_traffic_secret_N+2, etc.</t>

<t>While such a feature is less relevant in environments with shorter-lived sessions,
such as transactions on the web, there are uses of TLS and DTLS where long-lived
sessions are common. In those environments, such as industrial IoT and
telecommunication networks, availability is important and an interruption of the
communication due to periodic session resumptions is not an option. Re-running a
handshake with (EC)DHE and switching from the old to the new session may be a solution
for some applications but introduces complexity, impacts performance and may lead to
service interruption as well.</t>

<t>Some deployments have used IPsec in the past to secure their communication protocol
and have now decided to switch to TLS or DTLS instead. The requirement for updates of
cryptographic keys for an existing session has become a requirement. For IPsec, NIST,
BSI, and ANSSI recommend to re-run Diffie-Hellman exchanges frequently to provide forward
secrecy and force attackers to perform a dynamic key extraction <xref target="RFC7624"/>. ANSSI
writes "It is recommended to force the periodic renewal of the keys, e.g., every
hour and every 100 GB of data, in order to limit the impact of a key compromise."
<xref target="ANSSI-DAT-NT-003"/>. While IPsec/IKEv2 <xref target="RFC7296"/> offers the desired functionality,
developers often decide to use TLS/DTLS to simplify integration with cloud-based
environments.</t>

<t>This specification defines a new key update mechanism supporting forward
secrecy. It does so by re-using the design approach introduced by the "Exported Authenticators"
specification <xref target="RFC9261"/>, which uses the application layer protocol to exchange post-handshake
messages. This approach minimizes the impact on the TLS state machine but places more
burden on application layer protocol designer. To achieve interoperability the payloads
exchanged via the application layer are specified in this document and we make use of
Hybrid Public Key Encryption (HPKE) <xref target="RFC9180"/>, which offers an easy migration path
for the integration of post quantum cryptography with its key encapsulation construction
(KEM). Since HPKE requires the sender to possess the recipient's public key, those public
keys need to be exchanged upfront. This specification is silent about
when and how often these public keys are exchanged by the application layer protocol.
Note: To accomplish forward secrecy the public key of the recipient can be only used once.</t>

<t>To leave the exchange of the public keys up to the application is an intentional design decision
to offer flexibility for developers and there is experience with such an approach already from
secure end-to-end messaging protocols. To synchronize the switch to the new traffic secret,
the key updates are directional and accomplished with a new key update message. The trigger
to switch to the new traffic secrets is necessary since the TLS record layer conveys no key
identifier like an epoch or a Connection Identifier (CID).</t>

<t>The support for the functionality described in this specification is signaled using the
TLS extension mechanism. Using the extended key update message frequently forces an attacker
to perform dynamic key exfiltration.</t>

<t>This specification is applicable to both TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/> and
DTLS 1.3 <xref target="RFC9147"/>. Throughout the specification we do not distinguish between
these two protocols unless necessary for better understanding.</t>

</section>
<section anchor="terminology-and-requirements-language"><name>Terminology and Requirements Language</name>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

<t>To distinguish the key update procedure defined in <xref target="I-D.ietf-tls-rfc8446bis"/>
from the key update procedure specified in this document, we use the terms
"key update" and "extended key update", respectively.</t>

<t>This document re-uses the Key Encapsulation Mechanism (KEM) terminology
from RFC 9180 <xref target="RFC9180"/>.</t>

<t>The following abbreviations are used in this document:</t>

<t><list style="symbols">
  <t>KDF: Key Derivation Function</t>
  <t>AEAD: Authenticated Encryption with Associated Data</t>
  <t>HPKE: Hybrid Public Key Encryption</t>
</list></t>

</section>
<section anchor="negotiating-the-extended-key-update"><name>Negotiating the Extended Key Update</name>

<t>The "extended_key_update" extension is used by the client and the
server to negotiate an HPKE ciphersuite to use, which refers to the
combination of a KEM, KDF, AEAD combination. These HPKE ciphersuites
are communicated in the ClientHello and EncryptedExtensions messages.
The values for the KEM, the KDF, and the AEAD algorithms are taken from
the IANA registry created by <xref target="RFC9180"/>.</t>

<t>This extension is only supported with TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/>
and newer; if TLS 1.2 <xref target="RFC5246"/> or earlier is negotiated, the peers MUST ignore
this extension.</t>

<t>This document defines a new extension type, the extended_key_update(TBD1), as
shown in <xref target="extension-fig"/>, which can be used to signal the supported
HPKE ciphersuites for the extended key update message to the peer.</t>

<figure title="ExtensionType Structure." anchor="extension-fig"><artwork><![CDATA[
   enum {
       extended_key_update(TBD1), (65535)
   } ExtensionType;
]]></artwork></figure>

<t>This new extension is populated with the structure shown in <xref target="ciphersuite-fig"/>.</t>

<figure title="HpkeCipherSuites Structure." anchor="ciphersuite-fig"><artwork><![CDATA[
struct {
    uint16 kdf_id;
    uint16 aead_id;
    uint16 kem_id;
} HpkeCipherSuite;

struct {
    HpkeCipherSuite cipher_suites<4..2^16-4>;
} HpkeCipherSuites;
]]></artwork></figure>

<t>Whenever it is sent by the client as a ClientHello message extension
(<xref target="I-D.ietf-tls-rfc8446bis"/>, Section 4.1.2), it indicates what HPKE
ciphersuites it supports.</t>

<t>A server that supports and wants to use the extended key update feature
MUST send the "extended_key_update" extension in the EncryptedExtensions
message indicating what HPKE ciphersuites it prefers to use. The
extension, shown in <xref target="ciphersuite-fig"/>, contains a list of supported
ciphersuites in preference order, with the most preferred version first.</t>

<t>The server MUST select one of the ciphersuites from the list offered
by the client. If no suitable ciphersuite is found, the server MUST NOT
return an "extended_key_update" extension to the client.</t>

<t>If this extension is not present, as with any TLS extensions, servers
ignore any the functionality specified in this document and applications
have to rely on the features offered by the TLS 1.3-specified KeyUpdate
instead.</t>

</section>
<section anchor="using-hpke"><name>Using HPKE</name>

<t>To support interoperability between the two peers, the following payload
structure is defined.</t>

<figure title="HPKE_Payload Structure." anchor="hpke-payload-fig"><artwork><![CDATA[
struct {
    opaque enc<0..2^16-1>;
    opaque ct<32..2^8-1>;
} HPKE_Payload;
]]></artwork></figure>

<t>The fields have the following meaning:</t>

<t><list style="symbols">
  <t>enc: The HPKE encapsulated key, used by the peers to decrypt the
corresponding payload field.</t>
  <t>ct: The ciphertext, which is the result of encrypting a random value,
RAND, with HPKE, as described in <xref target="RFC9180"/> using the HPKE SealBase()
operation. RAND MUST be at least 32 bytes long but the maximum length
MUST NOT exceed 255 bytes. This RAND value is input to the
application_traffic_secret generation, as described in <xref target="key_update"/>.</t>
</list></t>

<t>This specification MUST use the HPKE Base mode; authenticated modes
are not supported.</t>

<t>The SealBase() operation requires four inputs, namely</t>

<t><list style="symbols">
  <t>the public key of the recipient,</t>
  <t>context information (info),</t>
  <t>associated data (aad), and</t>
  <t>plaintext.</t>
</list></t>

<t>SealBase() will return two outputs, "enc" and "ct", which will
be stored in the HPKE_Payload structure.</t>

<t>Two input values for the SealBase() operation require further
explanation:</t>

<t><list style="symbols">
  <t>The info value MUST be set to the empty string.</t>
  <t>The aad value MUST be populated with the TLS exporter secret.
The exporter interface is described in Section 7.5 of
<xref target="I-D.ietf-tls-rfc8446bis"/>. For (D)TLS 1.3, the
exporter_master_secret MUST be used, not the
early_exporter_master_secret.</t>
</list></t>

<t>The exporter value is computed as:</t>

<figure><artwork><![CDATA[
   TLS-Exporter(label, context_value, key_length) =
       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                         "exporter", Hash(context_value), key_length)
]]></artwork></figure>

<t>The following values are used for the TLS-Exporter function:</t>

<t><list style="symbols">
  <t>the label is set to "extended key update client" and
"extended key update server" for extended key updates sent by the
client or server, respectively</t>
  <t>the context_value is set to a zero length value.</t>
  <t>the length of the exported value is equal to the length of
the output of the hash function associated with the selected
ciphersuite.</t>
</list></t>

<t>The recipient will use the OpenBase() operation with the "enc"
and the "ct" parameters received from the sender.  The
"aad" and the "info" parameters are constructed as previously
described for SealBase().</t>

<t>The OpenBase function will, if successful, decrypt "ct".  When
decrypted, the result will either return the random value or an
error.</t>

</section>
<section anchor="ext-key-update"><name>Extended Key Update Message</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate that the sender
is updating its sending cryptographic keys.  This message can be sent
by either peer after it has sent a Finished message and exchanged the
necessary public key(s) and HPKE payload(s) by the application layer
protocol. Implementations that receive a ExtendedKeyUpdate message prior
to receiving a Finished message or prior to the exchange of the needed
application layer payloads (public key and HPKE) MUST terminate the
connection with an "unexpected_message" alert.</t>

<t>After sending the ExtendedKeyUpdate message, the sender MUST send all
its traffic using the next generation of keys, computed as described
in <xref target="key_update"/>. Upon receiving an ExtendedKeyUpdate message, the
receiver MUST update its receiving traffic keys.</t>

<figure title="ExtendedKeyUpdate Structure." anchor="extended-key-update-fig"><artwork><![CDATA[
enum {
    update_not_requested(0), update_requested(1), (255)
} KeyUpdateRequest;

struct {
    KeyUpdateRequest request_update;
} ExtendedKeyUpdate;
]]></artwork></figure>

<t>The request_update field indicates whether the recipient of the
ExtendedKeyUpdate should respond with its own ExtendedKeyUpdate.
If an implementation receives any other value, it MUST terminate
the connection with an "illegal_parameter" alert.</t>

<t>If the request_update field is set to "update_requested", the
receiver MUST send an ExtendedKeyUpdate of its own with request_update set to
"update_not_requested" prior to sending its next Application Data
record.  This mechanism allows either side to force an update to the
entire connection, but causes an implementation which receives
multiple ExtendedKeyUpdates while it is silent to respond with a single
update.  Note that implementations may receive an arbitrary number of
messages between sending a ExtendedKeyUpdate with request_update set to
"update_requested" and receiving the peer's ExtendedKeyUpdate, because those
messages may already be in flight.</t>

<t>If implementations independently send their own ExtendedKeyUpdate with
request_update set to "update_requested", and they cross in flight,
then each side will also send a response, with the result that each
side increments by two generations.</t>

<t>The sender MUST encrypt ExtendedKeyUpdate messages with the old keys
and the receiver MUST decrypt ExtendedKeyUpdate messages with the old
keys. Senders MUST enforce that ExtendedKeyUpdate encrypted with the
old key is received before accepting any messages encrypted with the
new key.</t>

<t>If a sending implementation receives a ExtendedKeyUpdate with request_update
set to "update_requested", it MUST NOT send its own ExtendedKeyUpdate if
that would cause it to exceed these limits and SHOULD instead ignore the
"update_requested" flag.</t>

<t>The ExtendedKeyUpdate and the KeyUpdates MAY be used in combination.</t>

</section>
<section anchor="key_update"><name>Updating Traffic Secrets</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate that
the sender is updating its sending cryptographic keys.  This message can
be sent by either peer after three conditions are met:</t>

<t><list style="symbols">
  <t>The peer has sent a Finished message.</t>
  <t>The peer is configured with a public key of the recipient. The process
for exchanging and updating these public keys is application-specific.</t>
  <t>The peer has successfully sent the HPKE payload at the application
layer to the peer. HPKE is used to securely exchange a random number
using a KEM.</t>
</list></t>

<t>The next generation of traffic keys is computed by generating
client_/server_application_traffic_secret_N+1 from
client_/server_application_traffic_secret_N as described in this
section and then re-deriving the traffic keys as described in
Section 7.3 of <xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<t>There are two changes to the application_traffic_secret computation
described in <xref target="I-D.ietf-tls-rfc8446bis"/>, namely</t>

<t><list style="symbols">
  <t>the label is adjusted to distinguish it from the regular KeyUpdate
message, and</t>
  <t>the hash of the random value encrypted with HPKE is included as a
context value making the next generation of the application
traffic secret dependent on the HPKE-encrypted random value.</t>
</list></t>

<t>The next generation application_traffic_secret is computed as:</t>

<figure><artwork><![CDATA[
application_traffic_secret_N+1 =
    HKDF-Expand-Label(application_traffic_secret_N,
                      "traffic up2", Hash(RAND), Hash.length)
]]></artwork></figure>

<t>Once client_/server_application_traffic_secret_N+1 and its associated
traffic keys have been computed, implementations SHOULD delete
client_/server_application_traffic_secret_N and its associated
traffic keys.</t>

</section>
<section anchor="example"><name>Example</name>

<t><xref target="fig-key-update"/> shows the interaction between a TLS 1.3 client
and server graphically. This section shows an example message exchange
where a client updates its sending keys.</t>

<t>There are three phases worthwhile to highlight:</t>

<t><list style="numbers">
  <t>First, the support for the functionality in this specification
is negotiated in the ClientHello and the EncryptedExtensions
messages. As a result, the two peers have a shared understanding
of the negotiated HPKE ciphersuite, which includes a KEM, a KDF,
and an AEAD.</t>
  <t>Once the initial handshake is completed, application layer
payloads can be exchanged. The two peers exchange public keys
suitable for use with the HPKE KEM and subsequently an HPKE-
encrypted random value.</t>
  <t>When a key update needs to be triggered by the application,
it instructs the (D)TLS stack to transmit an ExtendedKeyUpdate
message.</t>
</list></t>

<t><xref target="fig-key-update"/> provides an overview of the exchange starting
with the initial negotiation followed by the key update, which
involves the application layer interaction.</t>

<figure title="Extended Key Update Message Exchange." anchor="fig-key-update"><artwork><![CDATA[
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share
     | + signature_algorithms
     v + extended_key_update   -------->
                                                  ServerHello  ^ Key
                                                  + key_share  | Exch
                                                               v
                                        {EncryptedExtensions   ^ Server
                                       + extended_key_update}  | Params
                                         {CertificateRequest}  v
                                                {Certificate}  ^
                                          {CertificateVerify}  | Auth
                                                   {Finished}  v
                               <--------           
     ^ {Certificate
Auth | {CertificateVerify}
     v {Finished}              -------->
                                  ...
                              some time later
                                  ...
  +---------------- Application Layer Exchange --------------+
  |                                                          |
  |     (a)  Sender sends public key to the client           |
  |                                                          |
  |     (b)  Client uses HPKE to generate enc, and ct        |
  |                                                          |
  |     (c)  Client sents enc, and ct to the server          |
  |                                                          |
  |     (d)  Client triggers the extended key update         |
  |          at the TLS layer                                |
  |                                                          |
  +---------------- Application Layer Exchange --------------+

       [ExtendedKeyUpdate]     -------->
                               <--------  [ExtendedKeyUpdate]
]]></artwork></figure>

<t>For the server to generate and transmit a public key it is
necessary to determine whether the extended key update extension
has been negotiated success and what HPKE ciphersuite was
selected. This information can be obtained by the application
by using the "Get HPKE Ciphersuite" API.</t>

<t>Once the public key has been sent to the client, it can use the
"Encapsulate" API with SealBase(pk, info, aad, rand) to produce
enc, and ct. A random value has to be passed into the API call.</t>

<t>The client transmit the enc, and ct values to the server, which
performs the reverse operation using the "Decapsulate" API with
OpenBase(enc, skR, info, aad, ct) returning the random value.</t>

<t>The server uses the "Update-Prepare" API to get the (D)TLS stack
ready for a key update.</t>

<t>When the client wants to switch to the new sending key it uses the
"Update-Trigger" API to inform the (D)TLS library to trigger the
transmission of the ExtendedKeyUpdate message.</t>

</section>
<section anchor="api-considerations"><name>API Considerations</name>

<t>The creation and processing of the extended key update messages SHOULD be
implemented inside the (D)TLS library even if it is possible to implement
it at the application layer. (D)TLS implementations supporting the use of
the extended key update SHOULD provide application programming interfaces
by which clients and server may request and process the extended key update
messages.</t>

<t>It is also possible to implement this API outside of the (D)TLS library.
This may be preferable in cases where the application does not have
access to a TLS library with these APIs or when TLS is handled independently
of the application-layer protocol.</t>

<t>All APIs MUST fail if the connection uses a (D)TLS version of 1.2 or earlier.</t>

<t>The following sub-sections describe APIs that are considered necessary to
implement the extended key update functionality but the description is
informative only.</t>

<section anchor="the-get-hpke-ciphersuite-api"><name>The "Get HPKE Ciphersuite" API</name>

<t>This API allows the application to determine the negotiated HPKE ciphersuite
from the (D)TLS stack. This information is useful for the application since
it needs to exchange or present public keys to the stack.</t>

<t>It takes a reference to the initial connection as input and returns the
HpkeCipherSuite structure (if the extension was successfully negotiated)
or an empty payload otherwise.</t>

</section>
<section anchor="the-encapsulate-api"><name>The "Encapsulate" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
SealBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>public key of the recipient</t>
  <t>HPKE ciphersuite</t>
  <t>Random value</t>
</list></t>

<t>It returns the <xref target="hpke-payload-fig"/> payload.</t>

</section>
<section anchor="the-decapsulate-api"><name>The "Decapsulate" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
OpenBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>a reference to the secret key corresponding to the previously exchanged public key</t>
  <t>the <xref target="hpke-payload-fig"/> payload</t>
</list></t>

<t>It returns the random value, in case of success.</t>

</section>
<section anchor="the-update-prepare-api"><name>The "Update-Prepare" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
OpenBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>the random value obtained from the "Decapsulate" API call</t>
</list></t>

<t>It returns the success or failure.</t>

</section>
<section anchor="the-update-trigger-api"><name>The "Update-Trigger" API</name>

<t>This API allows the application to request the (D)TLS stack to initiate
an extended key update using the message defined in <xref target="ext-key-update"/>.</t>

<t>It takes no input values and returns success or failure.</t>

</section>
</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t><xref target="RFC9325"/> provides a good summary of what (perfect) forward secrecy
is and how it relates to the TLS protocol. In summary, it says:</t>

<t>"Forward secrecy (also called "perfect forward secrecy" or "PFS") is a
defense against an attacker who records encrypted conversations where
the session keys are only encrypted with the communicating parties'
long-term keys. Should the attacker be able to obtain these long-term
keys at some point later in time, the session keys and thus the entire
conversation could be decrypted."</t>

<t>Appendix F of <xref target="I-D.ietf-tls-rfc8446bis"/> goes into details of
explaining the security properties of the TLS 1.3 protocol and notes
"... forward secrecy without rerunning (EC)DHE does not stop an attacker
from doing static key exfiltration." It concludes with a recommendation
by saying: "Frequently rerunning (EC)DHE forces an attacker to do dynamic
key exfiltration (or content exfiltration)." (The term key exfiltration
is defined in <xref target="RFC7624"/>.)</t>

<t>This specification re-uses public key encryption to update application
traffic secrets in one direction. Hence, updates of these application
traffic secrets in both directions requires two ExtendedKeyUpdate messages.</t>

<t>To perform public key encryption the sender needs to have access to the
public key of the recipient. This document makes the assumption that the
public key in the exchanged end-entity certificate can be used with the
HPKE KEM. The use of HPKE, and the recipients long-term public key, in
the ephemeral-static Diffie-Hellman exchange provides perfect forward
secrecy of the ongoing connection and demonstrates possession of the
long-term secret key.</t>

</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t>IANA is also requested to allocate a new value in the "TLS ExtensionType Values"
subregistry of the "Transport Layer Security (TLS) Extensions"
registry <xref target="TLS-Ext-Registry"/>, as follows:</t>

<t><list style="symbols">
  <t>Value: TBD1</t>
  <t>Extension Name: extended_key_update</t>
  <t>TLS 1.3: CH, EE</t>
  <t>DTLS-Only: N</t>
  <t>Recommended: Y</t>
  <t>Reference: [This document]</t>
</list></t>

<t>IANA is also requested to allocate a new value in the "TLS
HandshakeType" subregistry of the "Transport Layer Security (TLS)
Extensions" registry <xref target="TLS-Ext-Registry"/>, as follows:</t>

<t><list style="symbols">
  <t>Value: TBD2</t>
  <t>Description: ExtendedKeyUpdate</t>
  <t>DTLS-OK: Y</t>
  <t>Reference: [This document]</t>
</list></t>

</section>


  </middle>

  <back>


    <references title='Normative References' anchor="sec-normative-references">



<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="S. Bradner" initials="S." surname="Bradner"/>
    <date month="March" year="1997"/>
    <abstract>
      <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>


<reference anchor="I-D.ietf-tls-rfc8446bis">
   <front>
      <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
      <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
         <organization>Windy Hill Systems, LLC</organization>
      </author>
      <date day="7" month="July" year="2023"/>
      <abstract>
	 <t>   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

   This document updates RFCs 5705, 6066, 7627, and 8422 and obsoletes
   RFCs 5077, 5246, 6961, and 8446.  This document also specifies new
   requirements for TLS 1.2 implementations.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-rfc8446bis-09"/>
   
</reference>


<reference anchor="I-D.ietf-tls-esni">
   <front>
      <title>TLS Encrypted Client Hello</title>
      <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
         <organization>RTFM, Inc.</organization>
      </author>
      <author fullname="Kazuho Oku" initials="K." surname="Oku">
         <organization>Fastly</organization>
      </author>
      <author fullname="Nick Sullivan" initials="N." surname="Sullivan">
         <organization>Cloudflare</organization>
      </author>
      <author fullname="Christopher A. Wood" initials="C. A." surname="Wood">
         <organization>Cloudflare</organization>
      </author>
      <date day="9" month="October" year="2023"/>
      <abstract>
	 <t>   This document describes a mechanism in Transport Layer Security (TLS)
   for encrypting a ClientHello message under a server public key.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Source for this draft and an issue tracker can be found at
   https://github.com/tlswg/draft-ietf-tls-esni
   (https://github.com/tlswg/draft-ietf-tls-esni).

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-esni-17"/>
   
</reference>

<reference anchor="RFC9180">
  <front>
    <title>Hybrid Public Key Encryption</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="K. Bhargavan" initials="K." surname="Bhargavan"/>
    <author fullname="B. Lipp" initials="B." surname="Lipp"/>
    <author fullname="C. Wood" initials="C." surname="Wood"/>
    <date month="February" year="2022"/>
    <abstract>
      <t>This document describes a scheme for hybrid public key encryption (HPKE). This scheme provides a variant of public key encryption of arbitrary-sized plaintexts for a recipient public key. It also includes three authenticated variants, including one that authenticates possession of a pre-shared key and two optional ones that authenticate possession of a key encapsulation mechanism (KEM) private key. HPKE works for any combination of an asymmetric KEM, key derivation function (KDF), and authenticated encryption with additional data (AEAD) encryption function. Some authenticated variants may not be supported by all KEMs. We provide instantiations of the scheme using widely used and efficient primitives, such as Elliptic Curve Diffie-Hellman (ECDH) key agreement, HMAC-based key derivation function (HKDF), and SHA2.</t>
      <t>This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9180"/>
  <seriesInfo name="DOI" value="10.17487/RFC9180"/>
</reference>

<reference anchor="RFC9147">
  <front>
    <title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
    <author fullname="N. Modadugu" initials="N." surname="Modadugu"/>
    <date month="April" year="2022"/>
    <abstract>
      <t>This document specifies version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
      <t>The DTLS 1.3 protocol is based on the Transport Layer Security (TLS) 1.3 protocol and provides equivalent security guarantees with the exception of order protection / non-replayability. Datagram semantics of the underlying transport are preserved by the DTLS protocol.</t>
      <t>This document obsoletes RFC 6347.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9147"/>
  <seriesInfo name="DOI" value="10.17487/RFC9147"/>
</reference>




    </references>

    <references title='Informative References' anchor="sec-informative-references">



<reference anchor="RFC9325">
  <front>
    <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
    <author fullname="Y. Sheffer" initials="Y." surname="Sheffer"/>
    <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"/>
    <author fullname="T. Fossati" initials="T." surname="Fossati"/>
    <date month="November" year="2022"/>
    <abstract>
      <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are used to protect data exchanged over a wide range of application protocols and can also form the basis for secure transport protocols. Over the years, the industry has witnessed several serious attacks on TLS and DTLS, including attacks on the most commonly used cipher suites and their modes of operation. This document provides the latest recommendations for ensuring the security of deployed services that use TLS and DTLS. These recommendations are applicable to the majority of use cases.</t>
      <t>RFC 7525, an earlier version of the TLS recommendations, was published when the industry was transitioning to TLS 1.2. Years later, this transition is largely complete, and TLS 1.3 is widely available. This document updates the guidance given the new environment and obsoletes RFC 7525. In addition, this document updates RFCs 5288 and 6066 in view of recent attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="195"/>
  <seriesInfo name="RFC" value="9325"/>
  <seriesInfo name="DOI" value="10.17487/RFC9325"/>
</reference>

<reference anchor="RFC7296">
  <front>
    <title>Internet Key Exchange Protocol Version 2 (IKEv2)</title>
    <author fullname="C. Kaufman" initials="C." surname="Kaufman"/>
    <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
    <author fullname="Y. Nir" initials="Y." surname="Nir"/>
    <author fullname="P. Eronen" initials="P." surname="Eronen"/>
    <author fullname="T. Kivinen" initials="T." surname="Kivinen"/>
    <date month="October" year="2014"/>
    <abstract>
      <t>This document describes version 2 of the Internet Key Exchange (IKE) protocol. IKE is a component of IPsec used for performing mutual authentication and establishing and maintaining Security Associations (SAs). This document obsoletes RFC 5996, and includes all of the errata for it. It advances IKEv2 to be an Internet Standard.</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="79"/>
  <seriesInfo name="RFC" value="7296"/>
  <seriesInfo name="DOI" value="10.17487/RFC7296"/>
</reference>

<reference anchor="RFC9261">
  <front>
    <title>Exported Authenticators in TLS</title>
    <author fullname="N. Sullivan" initials="N." surname="Sullivan"/>
    <date month="July" year="2022"/>
    <abstract>
      <t>This document describes a mechanism that builds on Transport Layer Security (TLS) or Datagram Transport Layer Security (DTLS) and enables peers to provide proof of ownership of an identity, such as an X.509 certificate. This proof can be exported by one peer, transmitted out of band to the other peer, and verified by the receiving peer.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9261"/>
  <seriesInfo name="DOI" value="10.17487/RFC9261"/>
</reference>

<reference anchor="RFC5246">
  <front>
    <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
    <author fullname="T. Dierks" initials="T." surname="Dierks"/>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <date month="August" year="2008"/>
    <abstract>
      <t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="5246"/>
  <seriesInfo name="DOI" value="10.17487/RFC5246"/>
</reference>

<reference anchor="RFC7624">
  <front>
    <title>Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="B. Schneier" initials="B." surname="Schneier"/>
    <author fullname="C. Jennings" initials="C." surname="Jennings"/>
    <author fullname="T. Hardie" initials="T." surname="Hardie"/>
    <author fullname="B. Trammell" initials="B." surname="Trammell"/>
    <author fullname="C. Huitema" initials="C." surname="Huitema"/>
    <author fullname="D. Borkmann" initials="D." surname="Borkmann"/>
    <date month="August" year="2015"/>
    <abstract>
      <t>Since the initial revelations of pervasive surveillance in 2013, several classes of attacks on Internet communications have been discovered. In this document, we develop a threat model that describes these attacks on Internet confidentiality. We assume an attacker that is interested in undetected, indiscriminate eavesdropping. The threat model is based on published, verified attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="7624"/>
  <seriesInfo name="DOI" value="10.17487/RFC7624"/>
</reference>


<reference anchor="ANSSI-DAT-NT-003" target="https://www.ssi.gouv.fr/uploads/2015/09/NT_IPsec_EN.pdf">
  <front>
    <title>Recommendations for securing networks with IPsec, Technical Report</title>
    <author >
      <organization>ANSSI</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="TLS-Ext-Registry" target="https://www.iana.org/assignments/tls-extensiontype-values">
  <front>
    <title>Transport Layer Security (TLS) Extensions</title>
    <author >
      <organization>IANA</organization>
    </author>
    <date year="2023" month="November"/>
  </front>
</reference>


    </references>


<?line 630?>

<section anchor="acknowledgments"><name>Acknowledgments</name>

<t>We would like to thank the members of the "TSVWG DTLS for SCTP
Requirements Design Team" for their discussion. The members, in
no particular order, are:</t>

<t><list style="symbols">
  <t>Marcelo Ricardo Leitner</t>
  <t>Zaheduzzaman Sarker</t>
  <t>Magnus Westerlund</t>
  <t>John Mattsson</t>
  <t>Claudio Porfiri</t>
  <t>Xin Long</t>
  <t>Michael Tuexen</t>
</list></t>

<t>Additionally, we would like to thank the chairs of the
Transport and Services Working Group (tsvwg) Gorry Fairhurst and
Marten Seemann as well as the responsible area director Martin Duke.</t>

<t>Finally, we would like to thank Martin Thomson, Ilari Liusvaara,
Benjamin Kaduk, Scott Fluhrer, Dennis Jackson, David Benjamin,
and Thom Wiggers for a review of an initial version of this
specification.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAAAAAAAAA9VdW3Mbx5V+ZxX/Qxf8EDIGIIm62KadVGiRshhJlFak482m
YlYD0wA6HMwg0zOkYEb5ZXnLH9tz68sMBqRsZx9WDwkIzHSfPn0u37l0ezQa
7e7Uts7NoTr5UJsiM5l6Zdbq+1Wma6NmZaUuKl24VVnV6rVem0qdm2lT2Xqt
9i5en++rR+PHuzu7O3oyqcz1HaO8Pt/dycppoZcwV1bpWT2q3XRRzkxh56M6
dyMjr46uzHrU0Kujh492d6bwYV5W60Pl6gznsqvqUNVV4+qDhw+/engAs1dG
HwbKdnduyupqXpXN6pAnhhHhq+xQnRa1qQpTj46RAhzM1brILnVeFkDX2rjd
nZU93N1RqppNTebqde6/V6oup+lnC9QWdfjGAY8qM3Pxi/Wy/Xdd2Wl8flou
l/B+/N0WuS2S2YAho9y6egQDTcocHhyVv/0cfwJGLvVqZYu5PK2belFWSPcI
f8d/toAXXo7VReCy/4X34KUuCuN6fjZLbfNDtaDfx3GT/jBffhgD7/xzZQWz
n1sDi3AbE7+Bif/9rw+maE/6xk4X2uSd32TGujHw5R9mi9GygTFhp8aZac32
5t//ou/V94W9Hqtypo5Wq9yCuJ1PrSmmZpOQi7F6b7Js3abjwlbNUufG3eiq
/bvQclUWWW0rWDP8OYatatFxVl5ZrdTGZOdj9aKyvH1xsvPazICD7Z9kHse/
jWf42x8cc3NjvsDl3Z2irJa6tteGhPT9i+cHjx59RZ9PR8dja+oZKRNI75dP
njybWLf5m3GF9W9/9ejLh/Hzky/gsy1m3Tm+enzw1H/+4uCrZ+H7g2eP/Oen
B0/C9188O3hCn4/Ozs9h7qOL0dnF6OHDx4eyrCivKlkmPS3fiVV6b1hNwBrY
snBkSxzpeTFXIIyo6U7d2HqhTt/BD0N1YaaLwk51Du+i2fLj6WpuQPkWdb1y
hw8e3NzcjJ2z43nZXAP3HzSrvNSZe3Dw8NHTBw+/enB2cUkDXp6cjVfZTEZB
owR0NnMwPgofxe/BxIzA7o3emzloKxiqOxd5enR21F7jPRaWTKrD1d+xFKsL
PYbxH2hY1Lwgw/IgWFV8u16vzOha502QQV7MWXltlhOY9uDhAZny0Wik9AQW
oqdkIS8W5hOcgHIrM7UzYDxuFKjmzFROaQUGHb8zYLmXxjk9N2A6FZt3Na3W
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
IgdUSV5N2jdTADDe+V84AzR1BWkAAA==

-->

</rfc>

