<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.1 (Ruby 3.0.2) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>

<?rfc rfcedstyle="yes"?>
<?rfc tocindent="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-tschofenig-tls-extended-key-update-01" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="Extended Key Update for TLS">Extended Key Update for Transport Layer Security (TLS) 1.3</title>

    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Siemens</organization>
      <address>
        <email>hannes.tschofenig@gmx.net</email>
      </address>
    </author>
    <author initials="M." surname="Tüxen" fullname="Michael Tüxen">
      <organization>Münster Univ. of Applied Sciences</organization>
      <address>
        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>
    <author initials="T." surname="Reddy" fullname="Tirumaleswar Reddy">
      <organization>Nokia</organization>
      <address>
        <email>kondtir@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Fries" fullname="Steffen Fries">
      <organization>Siemens</organization>
      <address>
        <email>steffen.fries@siemens.com</email>
      </address>
    </author>

    <date year="2024" month="February" day="09"/>

    <area>Security</area>
    <workgroup>TLS</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<?line 72?>

<t>The Transport Layer Security (TLS) 1.3 specification offers a dedicated
message to update cryptographic keys during the lifetime of an ongoing session.
The traffic secret and the initialization vector are updated directionally
but the sender may trigger the recipient, via the request_update field,
to transmit a key update message in the reverse direction.</t>

<t>In environments where sessions are long-lived, such as industrial IoT or
telecommunication networks, this key update alone is insufficient since
forward secrecy is not offered via this mechanism. Earlier versions
of TLS allowed the two peers to perform renegotiation, which is a handshake
that establishes new cryptographic parameters for an existing session.
When a security vulnerability with the renegotiation mechanism was discovered,
RFC 5746 was developed as a fix. Renegotiation has, however, been removed from
version 1.3 leaving a gap in the feature set of TLS.</t>

<t>This specification defines an extended key update that supports forward secrecy.</t>



    </abstract>



  </front>

  <middle>


<?line 91?>

<section anchor="introduction"><name>Introduction</name>

<t>The features of TLS and DTLS have changed over the years and while newer versions
optimized the protocol and at the same time enhanced features (often with the help
of extensions) some functionality was removed without replacement. The ability to
update keys and initialization vectors has been added in TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/>
using the KeyUpdate message and it intended to (partially) replace renegotiation from earlier
TLS versions. The renegotiation feature, while complex, offered additional
functionality that is not supported with TLS 1.3 anymore, including the update
keys with a Diffie-Hellman exchange during the lifetime of a session. If a traffic
secret (referred as application_traffic_secret_N) has been compromised, an attacker
can passively eavesdrop on all future data sent on the connection, including data
encrypted with application_traffic_secret_N+1, application_traffic_secret_N+2, etc.</t>

<t>While such a feature is less relevant in environments with shorter-lived sessions,
such as transactions on the web, there are uses of TLS and DTLS where long-lived
sessions are common. In those environments, such as industrial IoT and
telecommunication networks, availability is important and an interruption of the
communication due to periodic session resumptions is not an option. Re-running a
handshake with (EC)DHE and switching from the old to the new session may be a solution
for some applications but introduces complexity, impacts performance and may lead to
service interruption as well.</t>

<t>Some deployments have used IPsec in the past to secure their communication protocol
and have now decided to switch to TLS or DTLS instead. The requirement for updates of
cryptographic keys for an existing session has become a requirement. For IPsec, NIST,
BSI, and ANSSI recommend to re-run Diffie-Hellman exchanges frequently to provide forward
secrecy and force attackers to perform a dynamic key extraction <xref target="RFC7624"/>. ANSSI
writes "It is recommended to force the periodic renewal of the keys, e.g., every
hour and every 100 GB of data, in order to limit the impact of a key compromise."
<xref target="ANSSI-DAT-NT-003"/>. While IPsec/IKEv2 <xref target="RFC7296"/> offers the desired functionality,
developers often decide to use TLS/DTLS to simplify integration with cloud-based
environments.</t>

<t>This specification defines a new key update mechanism supporting forward
secrecy. It does so by re-using the design approach introduced by the "Exported Authenticators"
specification <xref target="RFC9261"/>, which uses the application layer protocol to exchange post-handshake
messages. This approach minimizes the impact on the TLS state machine but places more
burden on application layer protocol designer. To achieve interoperability the payloads
exchanged via the application layer are specified in this document and we make use of
Hybrid Public Key Encryption (HPKE) <xref target="RFC9180"/>, which offers an easy migration path
for the integration of post quantum cryptography with its key encapsulation construction
(KEM). Since HPKE requires the sender to possess the recipient's public key, those public
keys need to be exchanged upfront. This specification is silent about
when and how often these public keys are exchanged by the application layer protocol.
Note: To accomplish forward secrecy the public key of the recipient can be only used once.</t>

<t>To leave the exchange of the public keys up to the application is an intentional design decision
to offer flexibility for developers and there is experience with such an approach already from
secure end-to-end messaging protocols. To synchronize the switch to the new traffic secret,
the key updates are directional and accomplished with a new key update message. The trigger
to switch to the new traffic secrets is necessary since the TLS record layer conveys no key
identifier like an epoch or a Connection Identifier (CID).</t>

<t>The support for the functionality described in this specification is signaled using the
TLS extension mechanism. Using the extended key update message frequently forces an attacker
to perform dynamic key exfiltration.</t>

<t>This specification is applicable to both TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/> and
DTLS 1.3 <xref target="RFC9147"/>. Throughout the specification we do not distinguish between
these two protocols unless necessary for better understanding.</t>

</section>
<section anchor="terminology-and-requirements-language"><name>Terminology and Requirements Language</name>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

<t>To distinguish the key update procedure defined in <xref target="I-D.ietf-tls-rfc8446bis"/>
from the key update procedure specified in this document, we use the terms
"key update" and "extended key update", respectively.</t>

<t>This document re-uses the Key Encapsulation Mechanism (KEM) terminology
from RFC 9180 <xref target="RFC9180"/>.</t>

<t>The following abbreviations are used in this document:</t>

<t><list style="symbols">
  <t>KDF: Key Derivation Function</t>
  <t>AEAD: Authenticated Encryption with Associated Data</t>
  <t>HPKE: Hybrid Public Key Encryption</t>
</list></t>

</section>
<section anchor="negotiating-the-extended-key-update"><name>Negotiating the Extended Key Update</name>

<t>The "extended_key_update" extension is used by the client and the
server to negotiate an HPKE ciphersuite to use, which refers to the
combination of a KEM, KDF, AEAD combination. These HPKE ciphersuites
are communicated in the ClientHello and EncryptedExtensions messages.
The values for the KEM, the KDF, and the AEAD algorithms are taken from
the IANA registry created by <xref target="RFC9180"/>.</t>

<t>This extension is only supported with TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/>
and newer; if TLS 1.2 <xref target="RFC5246"/> or earlier is negotiated, the peers MUST ignore
this extension.</t>

<t>This document defines a new extension type, the extended_key_update(TBD1), as
shown in <xref target="extension-fig"/>, which can be used to signal the supported
HPKE ciphersuites for the extended key update message to the peer.</t>

<figure title="ExtensionType Structure." anchor="extension-fig"><artwork><![CDATA[
   enum {
       extended_key_update(TBD1), (65535)
   } ExtensionType;
]]></artwork></figure>

<t>This new extension is populated with the structure shown in <xref target="ciphersuite-fig"/>.</t>

<figure title="HpkeCipherSuites Structure." anchor="ciphersuite-fig"><artwork><![CDATA[
struct {
    uint16 kdf_id;
    uint16 aead_id;
    uint16 kem_id;
} HpkeCipherSuite;

struct {
    HpkeCipherSuite cipher_suites<4..2^16-4>;
} HpkeCipherSuites;
]]></artwork></figure>

<t>Whenever it is sent by the client as a ClientHello message extension
(<xref target="I-D.ietf-tls-rfc8446bis"/>, Section 4.1.2), it indicates what HPKE
ciphersuites it supports.</t>

<t>A server that supports and wants to use the extended key update feature
MUST send the "extended_key_update" extension in the EncryptedExtensions
message indicating what HPKE ciphersuites it prefers to use. The
extension, shown in <xref target="ciphersuite-fig"/>, contains a list of supported
ciphersuites in preference order, with the most preferred version first.</t>

<t>The server MUST select one of the ciphersuites from the list offered
by the client. If no suitable ciphersuite is found, the server MUST NOT
return an "extended_key_update" extension to the client.</t>

<t>If this extension is not present, as with any TLS extensions, servers
ignore any the functionality specified in this document and applications
have to rely on the features offered by the TLS 1.3-specified KeyUpdate
instead.</t>

</section>
<section anchor="using-hpke"><name>Using HPKE</name>

<t>To support interoperability between the two peers, the following payload
structure is defined.</t>

<figure title="HPKE_Payload Structure." anchor="hpke-payload-fig"><artwork><![CDATA[
struct {
    opaque enc<0..2^16-1>;
    opaque ct<32..2^8-1>;
} HPKE_Payload;
]]></artwork></figure>

<t>The fields have the following meaning:</t>

<t><list style="symbols">
  <t>enc: The HPKE encapsulated key, used by the peers to decrypt the
corresponding payload field.</t>
  <t>ct: The ciphertext, which is the result of encrypting a random value,
RAND, with HPKE, as described in <xref target="RFC9180"/> using the HPKE SealBase()
operation. RAND MUST be at least 32 bytes long but the maximum length
MUST NOT exceed 255 bytes. This RAND value is input to the
application_traffic_secret generation, as described in <xref target="key_update"/>.</t>
</list></t>

<t>This specification MUST use the HPKE Base mode; authenticated modes
are not supported.</t>

<t>The SealBase() operation requires four inputs, namely</t>

<t><list style="symbols">
  <t>the public key of the recipient,</t>
  <t>context information (info),</t>
  <t>associated data (aad), and</t>
  <t>plaintext.</t>
</list></t>

<t>SealBase() will return two outputs, "enc" and "ct", which will
be stored in the HPKE_Payload structure.</t>

<t>Two input values for the SealBase() operation require further
explanation:</t>

<t><list style="symbols">
  <t>The info value MUST be set to the empty string.</t>
  <t>The aad value MUST be populated with the TLS exporter secret.
The exporter interface is described in Section 7.5 of
<xref target="I-D.ietf-tls-rfc8446bis"/>. For (D)TLS 1.3, the
exporter_master_secret MUST be used, not the
early_exporter_master_secret.</t>
</list></t>

<t>The exporter value is computed as:</t>

<figure><artwork><![CDATA[
   TLS-Exporter(label, context_value, key_length) =
       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                         "exporter", Hash(context_value), key_length)
]]></artwork></figure>

<t>The following values are used for the TLS-Exporter function:</t>

<t><list style="symbols">
  <t>the label is set to "extended key update client" and
"extended key update server" for extended key updates sent by the
client or server, respectively</t>
  <t>the context_value is set to a zero length value.</t>
  <t>the length of the exported value is equal to the length of
the output of the hash function associated with the selected
ciphersuite.</t>
</list></t>

<t>The recipient will use the OpenBase() operation with the "enc"
and the "ct" parameters received from the sender.  The
"aad" and the "info" parameters are constructed as previously
described for SealBase().</t>

<t>The OpenBase function will, if successful, decrypt "ct".  When
decrypted, the result will either return the random value or an
error.</t>

</section>
<section anchor="ext-key-update"><name>Extended Key Update Message</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate that the sender
is updating its sending cryptographic keys.  This message can be sent
by either peer after it has sent a Finished message and exchanged the
necessary public key(s) and HPKE payload(s) by the application layer
protocol. Implementations that receive a ExtendedKeyUpdate message prior
to receiving a Finished message or prior to the exchange of the needed
application layer payloads (public key and HPKE) MUST terminate the
connection with an "unexpected_message" alert.</t>

<t>After sending the ExtendedKeyUpdate message, the sender MUST send all
its traffic using the next generation of keys, computed as described
in <xref target="key_update"/>. Upon receiving an ExtendedKeyUpdate message, the
receiver MUST update its receiving traffic keys.</t>

<figure title="ExtendedKeyUpdate Structure." anchor="extended-key-update-fig"><artwork><![CDATA[
enum {
    update_not_requested(0), update_requested(1), (255)
} KeyUpdateRequest;

struct {
    KeyUpdateRequest request_update;
} ExtendedKeyUpdate;
]]></artwork></figure>

<t>The request_update field indicates whether the recipient of the
ExtendedKeyUpdate should respond with its own ExtendedKeyUpdate.
If an implementation receives any other value, it MUST terminate
the connection with an "illegal_parameter" alert.</t>

<t>If the request_update field is set to "update_requested", the
receiver MUST send an ExtendedKeyUpdate of its own with request_update set to
"update_not_requested" prior to sending its next Application Data
record.  This mechanism allows either side to force an update to the
entire connection, but causes an implementation which receives
multiple ExtendedKeyUpdates while it is silent to respond with a single
update.  Note that implementations may receive an arbitrary number of
messages between sending a ExtendedKeyUpdate with request_update set to
"update_requested" and receiving the peer's ExtendedKeyUpdate, because those
messages may already be in flight.</t>

<t>If implementations independently send their own ExtendedKeyUpdate with
request_update set to "update_requested", and they cross in flight,
then each side will also send a response, with the result that each
side increments by two generations.</t>

<t>The sender MUST encrypt ExtendedKeyUpdate messages with the old keys
and the receiver MUST decrypt ExtendedKeyUpdate messages with the old
keys. Senders MUST enforce that ExtendedKeyUpdate encrypted with the
old key is received before accepting any messages encrypted with the
new key.</t>

<t>If a sending implementation receives a ExtendedKeyUpdate with request_update
set to "update_requested", it MUST NOT send its own ExtendedKeyUpdate if
that would cause it to exceed these limits and SHOULD instead ignore the
"update_requested" flag.</t>

<t>The ExtendedKeyUpdate and the KeyUpdates MAY be used in combination.</t>

</section>
<section anchor="key_update"><name>Updating Traffic Secrets</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate that
the sender is updating its sending cryptographic keys.  This message can
be sent by either peer after three conditions are met:</t>

<t><list style="symbols">
  <t>The peer has sent a Finished message.</t>
  <t>The peer is configured with a public key of the recipient. The process
for exchanging and updating these public keys is application-specific.</t>
  <t>The peer has successfully sent the HPKE payload at the application
layer to the peer. HPKE is used to securely exchange a random number
using a KEM.</t>
</list></t>

<t>The next generation of traffic keys is computed by generating
client_/server_application_traffic_secret_N+1 from
client_/server_application_traffic_secret_N as described in this
section and then re-deriving the traffic keys as described in
Section 7.3 of <xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<t>There are two changes to the application_traffic_secret computation
described in <xref target="I-D.ietf-tls-rfc8446bis"/>, namely</t>

<t><list style="symbols">
  <t>the label is adjusted to distinguish it from the regular KeyUpdate
message, and</t>
  <t>the hash of the random value encrypted with HPKE is included as a
context value making the next generation of the application
traffic secret dependent on the HPKE-encrypted random value.</t>
</list></t>

<t>The next generation application_traffic_secret is computed as:</t>

<figure><artwork><![CDATA[
application_traffic_secret_N+1 =
    HKDF-Expand-Label(application_traffic_secret_N,
                      "traffic up2", Hash(RAND), Hash.length)
]]></artwork></figure>

<t>Once client_/server_application_traffic_secret_N+1 and its associated
traffic keys have been computed, implementations SHOULD delete
client_/server_application_traffic_secret_N and its associated
traffic keys.</t>

</section>
<section anchor="example"><name>Example</name>

<t><xref target="fig-key-update"/> shows the interaction between a TLS 1.3 client
and server graphically. This section shows an example message exchange
where a client updates its sending keys.</t>

<t>There are three phases worthwhile to highlight:</t>

<t><list style="numbers">
  <t>First, the support for the functionality in this specification
is negotiated in the ClientHello and the EncryptedExtensions
messages. As a result, the two peers have a shared understanding
of the negotiated HPKE ciphersuite, which includes a KEM, a KDF,
and an AEAD.</t>
  <t>Once the initial handshake is completed, application layer
payloads can be exchanged. The two peers exchange public keys
suitable for use with the HPKE KEM and subsequently an HPKE-
encrypted random value.</t>
  <t>When a key update needs to be triggered by the application,
it instructs the (D)TLS stack to transmit an ExtendedKeyUpdate
message.</t>
</list></t>

<t><xref target="fig-key-update"/> provides an overview of the exchange starting
with the initial negotiation followed by the key update, which
involves the application layer interaction.</t>

<figure title="Extended Key Update Message Exchange." anchor="fig-key-update"><artwork><![CDATA[
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share
     | + signature_algorithms
     v + extended_key_update   -------->
                                                  ServerHello  ^ Key
                                                  + key_share  | Exch
                                                               v
                                        {EncryptedExtensions   ^ Server
                                       + extended_key_update}  | Params
                                         {CertificateRequest}  v
                                                {Certificate}  ^
                                          {CertificateVerify}  | Auth
                                                   {Finished}  v
                               <--------           
     ^ {Certificate
Auth | {CertificateVerify}
     v {Finished}              -------->
                                  ...
                              some time later
                                  ...
  +---------------- Application Layer Exchange --------------+
  |                                                          |
  |     (a)  Sender sends public key to the client           |
  |                                                          |
  |     (b)  Client uses HPKE to generate enc, and ct        |
  |                                                          |
  |     (c)  Client sents enc, and ct to the server          |
  |                                                          |
  |     (d)  Client triggers the extended key update         |
  |          at the TLS layer                                |
  |                                                          |
  +---------------- Application Layer Exchange --------------+

       [ExtendedKeyUpdate]     -------->
                               <--------  [ExtendedKeyUpdate]
]]></artwork></figure>

<t>For the server to generate and transmit a public key it is
necessary to determine whether the extended key update extension
has been negotiated success and what HPKE ciphersuite was
selected. This information can be obtained by the application
by using the "Get HPKE Ciphersuite" API.</t>

<t>Once the public key has been sent to the client, it can use the
"Encapsulate" API with SealBase(pk, info, aad, rand) to produce
enc, and ct. A random value has to be passed into the API call.</t>

<t>The client transmit the enc, and ct values to the server, which
performs the reverse operation using the "Decapsulate" API with
OpenBase(enc, skR, info, aad, ct) returning the random value.</t>

<t>The server uses the "Update-Prepare" API to get the (D)TLS stack
ready for a key update.</t>

<t>When the client wants to switch to the new sending key it uses the
"Update-Trigger" API to inform the (D)TLS library to trigger the
transmission of the ExtendedKeyUpdate message.</t>

</section>
<section anchor="dtls-13-considerations"><name>DTLS 1.3 Considerations</name>

<t>As with other handshake messages with no built-in response, the
ExtendedKeyUpdate MUST be acknowledged.  In order to facilitate
epoch reconstruction implementations MUST NOT send records with
the new keys or send a new ExtendedKeyUpdate until the previous
ExtendedKeyUpdate has been acknowledged (this avoids having too
many epochs in active use).</t>

<t>Due to loss and/or reordering, DTLS 1.3 implementations may receive a
record with an older epoch than the current one (the requirements
above preclude receiving a newer record).  They SHOULD attempt to
process those records with that epoch but MAY opt to discard
such out-of-epoch records.</t>

<t>Due to the possibility of an ACK message for an ExtendedKeyUpdate
being lost and thereby preventing the sender of the ExtendedKeyUpdate
from updating its keying material, receivers MUST retain the
pre-update keying material until receipt and successful decryption
of a message using the new keys.</t>

</section>
<section anchor="api-considerations"><name>API Considerations</name>

<t>The creation and processing of the extended key update messages SHOULD be
implemented inside the (D)TLS library even if it is possible to implement
it at the application layer. (D)TLS implementations supporting the use of
the extended key update SHOULD provide application programming interfaces
by which clients and server may request and process the extended key update
messages.</t>

<t>It is also possible to implement this API outside of the (D)TLS library.
This may be preferable in cases where the application does not have
access to a TLS library with these APIs or when TLS is handled independently
of the application-layer protocol.</t>

<t>All APIs MUST fail if the connection uses a (D)TLS version of 1.2 or earlier.</t>

<t>The following sub-sections describe APIs that are considered necessary to
implement the extended key update functionality but the description is
informative only.</t>

<section anchor="the-get-hpke-ciphersuite-api"><name>The "Get HPKE Ciphersuite" API</name>

<t>This API allows the application to determine the negotiated HPKE ciphersuite
from the (D)TLS stack. This information is useful for the application since
it needs to exchange or present public keys to the stack.</t>

<t>It takes a reference to the initial connection as input and returns the
HpkeCipherSuite structure (if the extension was successfully negotiated)
or an empty payload otherwise.</t>

</section>
<section anchor="the-encapsulate-api"><name>The "Encapsulate" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
SealBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>public key of the recipient</t>
  <t>HPKE ciphersuite</t>
  <t>Random value</t>
</list></t>

<t>It returns the <xref target="hpke-payload-fig"/> payload.</t>

</section>
<section anchor="the-decapsulate-api"><name>The "Decapsulate" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
OpenBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>a reference to the secret key corresponding to the previously exchanged public key</t>
  <t>the <xref target="hpke-payload-fig"/> payload</t>
</list></t>

<t>It returns the random value, in case of success.</t>

</section>
<section anchor="the-update-prepare-api"><name>The "Update-Prepare" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
OpenBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>the random value obtained from the "Decapsulate" API call</t>
</list></t>

<t>It returns the success or failure.</t>

</section>
<section anchor="the-update-trigger-api"><name>The "Update-Trigger" API</name>

<t>This API allows the application to request the (D)TLS stack to initiate
an extended key update using the message defined in <xref target="ext-key-update"/>.</t>

<t>It takes no input values and returns success or failure.</t>

</section>
</section>
<section anchor="post-quantum-considerations"><name>Post-Quantum Considerations</name>

<t>Hybrid key exchange refers to using multiple key exchange algorithms
simultaneously and combining the result with the goal of providing
security even if all but one of the component algorithms is broken.
It is motivated by transition to post-quantum cryptography.  HPKE can
be extended to support hybrid post-quantum Key Encapsulation
Mechanisms (KEMs), as defined in <xref target="I-D.westerbaan-cfrg-hpke-xyber768d00"/></t>

</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t><xref target="RFC9325"/> provides a good summary of what (perfect) forward secrecy
is and how it relates to the TLS protocol. In summary, it says:</t>

<t>"Forward secrecy (also called "perfect forward secrecy" or "PFS") is a
defense against an attacker who records encrypted conversations where
the session keys are only encrypted with the communicating parties'
long-term keys. Should the attacker be able to obtain these long-term
keys at some point later in time, the session keys and thus the entire
conversation could be decrypted."</t>

<t>Appendix F of <xref target="I-D.ietf-tls-rfc8446bis"/> goes into details of
explaining the security properties of the TLS 1.3 protocol and notes
"... forward secrecy without rerunning (EC)DHE does not stop an attacker
from doing static key exfiltration." It concludes with a recommendation
by saying: "Frequently rerunning (EC)DHE forces an attacker to do dynamic
key exfiltration (or content exfiltration)." (The term key exfiltration
is defined in <xref target="RFC7624"/>.)</t>

<t>This specification re-uses public key encryption to update application
traffic secrets in one direction. Hence, updates of these application
traffic secrets in both directions requires two ExtendedKeyUpdate messages.</t>

<t>To perform public key encryption the sender needs to have access to the
public key of the recipient. This document makes the assumption that the
public key in the exchanged end-entity certificate can be used with the
HPKE KEM. The use of HPKE, and the recipients long-term public key, in
the ephemeral-static Diffie-Hellman exchange provides perfect forward
secrecy of the ongoing connection and demonstrates possession of the
long-term secret key.</t>

</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t>IANA is also requested to allocate a new value in the "TLS ExtensionType Values"
subregistry of the "Transport Layer Security (TLS) Extensions"
registry <xref target="TLS-Ext-Registry"/>, as follows:</t>

<t><list style="symbols">
  <t>Value: TBD1</t>
  <t>Extension Name: extended_key_update</t>
  <t>TLS 1.3: CH, EE</t>
  <t>DTLS-Only: N</t>
  <t>Recommended: Y</t>
  <t>Reference: [This document]</t>
</list></t>

<t>IANA is also requested to allocate a new value in the "TLS
HandshakeType" subregistry of the "Transport Layer Security (TLS)
Extensions" registry <xref target="TLS-Ext-Registry"/>, as follows:</t>

<t><list style="symbols">
  <t>Value: TBD2</t>
  <t>Description: ExtendedKeyUpdate</t>
  <t>DTLS-OK: Y</t>
  <t>Reference: [This document]</t>
</list></t>

</section>


  </middle>

  <back>


    <references title='Normative References' anchor="sec-normative-references">



<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="S. Bradner" initials="S." surname="Bradner"/>
    <date month="March" year="1997"/>
    <abstract>
      <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>


<reference anchor="I-D.ietf-tls-rfc8446bis">
   <front>
      <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
      <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
         <organization>Windy Hill Systems, LLC</organization>
      </author>
      <date day="7" month="July" year="2023"/>
      <abstract>
	 <t>   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

   This document updates RFCs 5705, 6066, 7627, and 8422 and obsoletes
   RFCs 5077, 5246, 6961, and 8446.  This document also specifies new
   requirements for TLS 1.2 implementations.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-rfc8446bis-09"/>
   
</reference>

<reference anchor="RFC9180">
  <front>
    <title>Hybrid Public Key Encryption</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="K. Bhargavan" initials="K." surname="Bhargavan"/>
    <author fullname="B. Lipp" initials="B." surname="Lipp"/>
    <author fullname="C. Wood" initials="C." surname="Wood"/>
    <date month="February" year="2022"/>
    <abstract>
      <t>This document describes a scheme for hybrid public key encryption (HPKE). This scheme provides a variant of public key encryption of arbitrary-sized plaintexts for a recipient public key. It also includes three authenticated variants, including one that authenticates possession of a pre-shared key and two optional ones that authenticate possession of a key encapsulation mechanism (KEM) private key. HPKE works for any combination of an asymmetric KEM, key derivation function (KDF), and authenticated encryption with additional data (AEAD) encryption function. Some authenticated variants may not be supported by all KEMs. We provide instantiations of the scheme using widely used and efficient primitives, such as Elliptic Curve Diffie-Hellman (ECDH) key agreement, HMAC-based key derivation function (HKDF), and SHA2.</t>
      <t>This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9180"/>
  <seriesInfo name="DOI" value="10.17487/RFC9180"/>
</reference>

<reference anchor="RFC9147">
  <front>
    <title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
    <author fullname="N. Modadugu" initials="N." surname="Modadugu"/>
    <date month="April" year="2022"/>
    <abstract>
      <t>This document specifies version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
      <t>The DTLS 1.3 protocol is based on the Transport Layer Security (TLS) 1.3 protocol and provides equivalent security guarantees with the exception of order protection / non-replayability. Datagram semantics of the underlying transport are preserved by the DTLS protocol.</t>
      <t>This document obsoletes RFC 6347.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9147"/>
  <seriesInfo name="DOI" value="10.17487/RFC9147"/>
</reference>




    </references>

    <references title='Informative References' anchor="sec-informative-references">



<reference anchor="RFC9325">
  <front>
    <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
    <author fullname="Y. Sheffer" initials="Y." surname="Sheffer"/>
    <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"/>
    <author fullname="T. Fossati" initials="T." surname="Fossati"/>
    <date month="November" year="2022"/>
    <abstract>
      <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are used to protect data exchanged over a wide range of application protocols and can also form the basis for secure transport protocols. Over the years, the industry has witnessed several serious attacks on TLS and DTLS, including attacks on the most commonly used cipher suites and their modes of operation. This document provides the latest recommendations for ensuring the security of deployed services that use TLS and DTLS. These recommendations are applicable to the majority of use cases.</t>
      <t>RFC 7525, an earlier version of the TLS recommendations, was published when the industry was transitioning to TLS 1.2. Years later, this transition is largely complete, and TLS 1.3 is widely available. This document updates the guidance given the new environment and obsoletes RFC 7525. In addition, this document updates RFCs 5288 and 6066 in view of recent attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="195"/>
  <seriesInfo name="RFC" value="9325"/>
  <seriesInfo name="DOI" value="10.17487/RFC9325"/>
</reference>

<reference anchor="RFC7296">
  <front>
    <title>Internet Key Exchange Protocol Version 2 (IKEv2)</title>
    <author fullname="C. Kaufman" initials="C." surname="Kaufman"/>
    <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
    <author fullname="Y. Nir" initials="Y." surname="Nir"/>
    <author fullname="P. Eronen" initials="P." surname="Eronen"/>
    <author fullname="T. Kivinen" initials="T." surname="Kivinen"/>
    <date month="October" year="2014"/>
    <abstract>
      <t>This document describes version 2 of the Internet Key Exchange (IKE) protocol. IKE is a component of IPsec used for performing mutual authentication and establishing and maintaining Security Associations (SAs). This document obsoletes RFC 5996, and includes all of the errata for it. It advances IKEv2 to be an Internet Standard.</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="79"/>
  <seriesInfo name="RFC" value="7296"/>
  <seriesInfo name="DOI" value="10.17487/RFC7296"/>
</reference>

<reference anchor="RFC9261">
  <front>
    <title>Exported Authenticators in TLS</title>
    <author fullname="N. Sullivan" initials="N." surname="Sullivan"/>
    <date month="July" year="2022"/>
    <abstract>
      <t>This document describes a mechanism that builds on Transport Layer Security (TLS) or Datagram Transport Layer Security (DTLS) and enables peers to provide proof of ownership of an identity, such as an X.509 certificate. This proof can be exported by one peer, transmitted out of band to the other peer, and verified by the receiving peer.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9261"/>
  <seriesInfo name="DOI" value="10.17487/RFC9261"/>
</reference>

<reference anchor="RFC5246">
  <front>
    <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
    <author fullname="T. Dierks" initials="T." surname="Dierks"/>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <date month="August" year="2008"/>
    <abstract>
      <t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="5246"/>
  <seriesInfo name="DOI" value="10.17487/RFC5246"/>
</reference>

<reference anchor="RFC7624">
  <front>
    <title>Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="B. Schneier" initials="B." surname="Schneier"/>
    <author fullname="C. Jennings" initials="C." surname="Jennings"/>
    <author fullname="T. Hardie" initials="T." surname="Hardie"/>
    <author fullname="B. Trammell" initials="B." surname="Trammell"/>
    <author fullname="C. Huitema" initials="C." surname="Huitema"/>
    <author fullname="D. Borkmann" initials="D." surname="Borkmann"/>
    <date month="August" year="2015"/>
    <abstract>
      <t>Since the initial revelations of pervasive surveillance in 2013, several classes of attacks on Internet communications have been discovered. In this document, we develop a threat model that describes these attacks on Internet confidentiality. We assume an attacker that is interested in undetected, indiscriminate eavesdropping. The threat model is based on published, verified attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="7624"/>
  <seriesInfo name="DOI" value="10.17487/RFC7624"/>
</reference>


<reference anchor="I-D.westerbaan-cfrg-hpke-xyber768d00">
   <front>
      <title>X25519Kyber768Draft00 hybrid post-quantum KEM for HPKE</title>
      <author fullname="Bas Westerbaan" initials="B." surname="Westerbaan">
         <organization>Cloudflare</organization>
      </author>
      <author fullname="Christopher A. Wood" initials="C. A." surname="Wood">
         <organization>Cloudflare</organization>
      </author>
      <date day="4" month="May" year="2023"/>
      <abstract>
	 <t>   This memo defines X25519Kyber768Draft00, a hybrid post-quantum KEM,
   for HPKE (RFC9180).  This KEM does not support the authenticated
   modes of HPKE.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-westerbaan-cfrg-hpke-xyber768d00-02"/>
   
</reference>


<reference anchor="ANSSI-DAT-NT-003" target="https://www.ssi.gouv.fr/uploads/2015/09/NT_IPsec_EN.pdf">
  <front>
    <title>Recommendations for securing networks with IPsec, Technical Report</title>
    <author >
      <organization>ANSSI</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="TLS-Ext-Registry" target="https://www.iana.org/assignments/tls-extensiontype-values">
  <front>
    <title>Transport Layer Security (TLS) Extensions</title>
    <author >
      <organization>IANA</organization>
    </author>
    <date year="2023" month="November"/>
  </front>
</reference>


    </references>


<?line 661?>

<section anchor="acknowledgments"><name>Acknowledgments</name>

<t>We would like to thank the members of the "TSVWG DTLS for SCTP
Requirements Design Team" for their discussion. The members, in
no particular order, are:</t>

<t><list style="symbols">
  <t>Marcelo Ricardo Leitner</t>
  <t>Zaheduzzaman Sarker</t>
  <t>Magnus Westerlund</t>
  <t>John Mattsson</t>
  <t>Claudio Porfiri</t>
  <t>Xin Long</t>
  <t>Michael Tuexen</t>
</list></t>

<t>Additionally, we would like to thank the chairs of the
Transport and Services Working Group (tsvwg) Gorry Fairhurst and
Marten Seemann as well as the responsible area director Martin Duke.</t>

<t>Finally, we would like to thank Martin Thomson, Ilari Liusvaara,
Benjamin Kaduk, Scott Fluhrer, Dennis Jackson, David Benjamin,
and Thom Wiggers for a review of an initial version of this
specification.</t>

</section>
<section anchor="alternative-design"><name>Alternative Design</name>

<t>The design presented in this document utilizes HPKE with the Seal/Open
API calls instead of utilizing Encap/Decap API calls directly. Available
HPKE libraries expose the former API calls and this simplifies the
implementation of the solution described in this document. As a
side-effect, context information can also be passed into these API calls.</t>

<t>The downside of using the currently documented approach is the need to
additionally encrypt plaintext, which in our case is a random value. It
may also introduce complexity with the integration of hybrid approach.</t>

<t>We would welcome feedback whether the re-use of existing HPKE libraries
outweighs the disadvantages.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAAAAAAAAA9VdW3Mbx5V+ZxX/Qxf8EDIBIIm62KadVBiRshhJlCLS8WZT
G1YD0wA6HMwg0zOkYIb5ZXnLH9tz68sMBqQcZx9WDzYJzHSfPn0u37l0czQa
7e7Uts7NoTr5VJsiM5l6Y9bq+1Wma6NmZaUuKl24VVnV6q1em0qdm2lT2Xqt
9i7enu+rJ+Onuzu7O3oyqcz1PaO8Pd/dycppoZcwV1bpWT2q3XRRzkxh56M6
dyMjr46uzHrU0Kujx092d6bww7ys1ofK1RnOZVfVoaqrxtUHjx9//fgAZq+M
PgyU7e7clNXVvCqb1SFPDCPCR9mhOi1qUxWmHh0jBTiYq3WRXeq8LICutXG7
Oyt7uLujVDWbmszV69x/rlRdTtOfLVBb1OETBzyqzMzFD9bL9u91Zafx+Wm5
XML78Xtb5LZIZgOGjHLr6hEMNClzeHBU/vJX+BUwcqlXK1vM5Wnd1IuyQrpH
+D3+swW88HqsLgKX/Te8B691URjX87VZapsfqgV9P46b9Nv58tMYeOefKyuY
/dwaWITbmPgdTPyvf34yRXvSd3a60CbvfCcz1o2BD387W4yWDYwJOzXOTGu2
d//6J32uvi/s9ViVM3W0WuUWxO18ak0xNZuEXIzVR5Nl6zYdF7Zqljo37kZX
7e+FlquyyGpbwZrh1zFsVYuOs/LKaqU2Jjsfq1eV5e2Lk53XZgYcbH8l8zj+
bjzD737rmJsb8wUu7+4UZbXUtb02JKQfX708ePLka/r5dHQ8tqaekTKB9H71
7NmLiXX+ua+ffPU4/vzsS/jZFrPuaF8/PXjuf/7y4OsX4fODF0/8z88PnoXP
v3xx8CzMfmNwcyZaF6PprJqPFqsrM/q0npjqyxdfZY95+qOz83N4+OhidHYx
evz46aGsNIqwSlZOT8tnYqg+GtYcMBC2LByZF0eqX8wVyCcqv1M3tl6o0w/w
xVBdmOmisFOdw7toyfx4upob0MdFXa/c4aNHNzc3Y+fseF4217Ahj5pVXurM
PTp4/OT5o8dfPzq7uKQBL0/OxqtsJqOgnQI6mznYI4WP4udgdUZgCkcfzRwU
GGzXvYs8PTo7aq/xAaNLVtbh6u9ZitWFHsP4jzQsal6QrXkUDC2+Xa9XZnSt
8yaIJS/mrLw2S9g1WM4BWffRaKT0BBaip2Q0LxbmM/yCcisztTNgPG4UaOvM
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
nR+MnC6gGynJlOjiSsA59ma7yI3zP/7wHWfw6Vzvy4sPuzut6wuP+aLRC6OX
A59xsRVlxBu5df8iDsyqDXiekMaUGoTl6hxAKdJd/06DF8pL9dFiUr1Ub42t
C3SII/XfemGy5scfNWr/ua6u+ON3el4AYviBgGXecHfx78tFAd/UtXN85d3L
XDeZLSEyqGa2svjRf4F4vC0RhY/i36iiP0dFgCL8QYN8TfcHbmMbvGgD18C8
Bxmi8xl8TzqQV1bUnvwd/oUytVe765v5vvoOIuy1egUDLJqKE7GApIE9Bq9I
MLDQcKs63azPQQWWqCjjin8CTdwQMP8ddcup4+aKw6BX9n7i5fmLRbl0eFTt
FDbEqre2cddaVxpvMDfFX8H1F+qNzpqroTqflnWtXuXNosJdOzaAIJz6Pcgb
DXCswQ4r/5L0WuLw6gdphODiI2YQuN2PLq7loDjJjUp3fQoAfEkgxz/lxvlI
Fj6fOJU7byWH13dVUFPbnO6WJicVQDCmrB5htA9bLoG1C+dpgBh+DbeOAp5H
FIqr+CizH7t9j/gvCeTeD3ISGpEj3ifg/G05FTi15H32i3Sojy4Wt76e2jmU
JFrpL/bvufzVr5S7a/m42Aj/0ti0HvbeiYI+nCzpZvncxQJ6PFSWlTeFz+XH
mF7KcoApPQEmSy4ed5LdNfyHA3SiVuFkWrhzJTbvKrwAhpJA9Fd/WuVwwL1Y
l1wz8eFq8+SvGKikYbR1C7YEs568ccskgprRzf4zIBaNaOf07kjwTPijAO1d
3t0BkH9j7Hwhd81bpzP8MxoB+f0v7o0Wr3pxAAA=

-->

</rfc>

