<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.4 (Ruby 3.0.2) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>

<?rfc rfcedstyle="yes"?>
<?rfc tocindent="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-tschofenig-tls-extended-key-update-01" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="Extended Key Update for TLS">Extended Key Update for Transport Layer Security (TLS) 1.3</title>

    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Siemens</organization>
      <address>
        <email>hannes.tschofenig@gmx.net</email>
      </address>
    </author>
    <author initials="M." surname="Tüxen" fullname="Michael Tüxen">
      <organization>Münster Univ. of Applied Sciences</organization>
      <address>
        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>
    <author initials="T." surname="Reddy" fullname="Tirumaleswar Reddy">
      <organization>Nokia</organization>
      <address>
        <email>kondtir@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Fries" fullname="Steffen Fries">
      <organization>Siemens</organization>
      <address>
        <email>steffen.fries@siemens.com</email>
      </address>
    </author>

    <date year="2024" month="March" day="02"/>

    <area>Security</area>
    <workgroup>TLS</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<?line 72?>

<t>The Transport Layer Security (TLS) 1.3 specification offers a dedicated
message to update cryptographic keys during the lifetime of an ongoing session.
The traffic secret and the initialization vector are updated directionally
but the sender may trigger the recipient, via the request_update field,
to transmit a key update message in the reverse direction.</t>

<t>In environments where sessions are long-lived, such as industrial IoT or
telecommunication networks, this key update alone is insufficient since
forward secrecy is not offered via this mechanism. Earlier versions
of TLS allowed the two peers to perform renegotiation, which is a handshake
that establishes new cryptographic parameters for an existing session.
When a security vulnerability with the renegotiation mechanism was discovered,
RFC 5746 was developed as a fix. Renegotiation has, however, been removed from
version 1.3 leaving a gap in the feature set of TLS.</t>

<t>This specification defines an extended key update that supports forward secrecy.</t>



    </abstract>



  </front>

  <middle>


<?line 91?>

<section anchor="introduction"><name>Introduction</name>

<t>The features of TLS and DTLS have changed over the years and while newer versions
optimized the protocol and at the same time enhanced features (often with the help
of extensions) some functionality was removed without replacement. The ability to
update keys and initialization vectors has been added in TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/>
using the KeyUpdate message and it intended to (partially) replace renegotiation from earlier
TLS versions. The renegotiation feature, while complex, offered additional
functionality that is not supported with TLS 1.3 anymore, including the update
keys with a Diffie-Hellman exchange during the lifetime of a session. If a traffic
secret (referred as application_traffic_secret_N) has been compromised, an attacker
can passively eavesdrop on all future data sent on the connection, including data
encrypted with application_traffic_secret_N+1, application_traffic_secret_N+2, etc.</t>

<t>While such a feature is less relevant in environments with shorter-lived sessions,
such as transactions on the web, there are uses of TLS and DTLS where long-lived
sessions are common. In those environments, such as industrial IoT and
telecommunication networks, availability is important and an interruption of the
communication due to periodic session resumptions is not an option. Re-running a
handshake with (EC)DHE and switching from the old to the new session may be a solution
for some applications but introduces complexity, impacts performance and may lead to
service interruption as well.</t>

<t>Some deployments have used IPsec in the past to secure their communication protocol
and have now decided to switch to TLS or DTLS instead. The requirement for updates of
cryptographic keys for an existing session has become a requirement. For IPsec, NIST,
BSI, and ANSSI recommend to re-run Diffie-Hellman exchanges frequently to provide forward
secrecy and force attackers to perform a dynamic key extraction <xref target="RFC7624"/>. ANSSI
writes "It is recommended to force the periodic renewal of the keys, e.g., every
hour and every 100 GB of data, in order to limit the impact of a key compromise."
<xref target="ANSSI-DAT-NT-003"/>. While IPsec/IKEv2 <xref target="RFC7296"/> offers the desired functionality,
developers often decide to use TLS/DTLS to simplify integration with cloud-based
environments.</t>

<t>This specification defines a new key update mechanism supporting forward
secrecy. It does so by re-using the design approach introduced by the "Exported Authenticators"
specification <xref target="RFC9261"/>, which uses the application layer protocol to exchange post-handshake
messages. This approach minimizes the impact on the TLS state machine but places more
burden on application layer protocol designer. To achieve interoperability the payloads
exchanged via the application layer are specified in this document and we make use of
Hybrid Public Key Encryption (HPKE) <xref target="RFC9180"/>, which offers an easy migration path
for the integration of post quantum cryptography with its key encapsulation construction
(KEM). Since HPKE requires the sender to possess the recipient's public key, those public
keys need to be exchanged upfront. This specification is silent about
when and how often these public keys are exchanged by the application layer protocol.
Note: To accomplish forward secrecy the public key of the recipient can be only used once.</t>

<t>To leave the exchange of the public keys up to the application is an intentional design decision
to offer flexibility for developers and there is experience with such an approach already from
secure end-to-end messaging protocols. To synchronize the switch to the new traffic secret,
the key updates are directional and accomplished with a new key update message. The trigger
to switch to the new traffic secrets is necessary since the TLS record layer conveys no key
identifier like an epoch or a Connection Identifier (CID).</t>

<t>The support for the functionality described in this specification is signaled using the
TLS extension mechanism. Using the extended key update message frequently forces an attacker
to perform dynamic key exfiltration.</t>

<t>This specification is applicable to both TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/> and
DTLS 1.3 <xref target="RFC9147"/>. Throughout the specification we do not distinguish between
these two protocols unless necessary for better understanding.</t>

</section>
<section anchor="terminology-and-requirements-language"><name>Terminology and Requirements Language</name>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

<t>To distinguish the key update procedure defined in <xref target="I-D.ietf-tls-rfc8446bis"/>
from the key update procedure specified in this document, we use the terms
"key update" and "extended key update", respectively.</t>

<t>This document re-uses the Key Encapsulation Mechanism (KEM) terminology
from RFC 9180 <xref target="RFC9180"/>.</t>

<t>The following abbreviations are used in this document:</t>

<t><list style="symbols">
  <t>KDF: Key Derivation Function</t>
  <t>AEAD: Authenticated Encryption with Associated Data</t>
  <t>HPKE: Hybrid Public Key Encryption</t>
</list></t>

</section>
<section anchor="negotiating-the-extended-key-update"><name>Negotiating the Extended Key Update</name>

<t>The "extended_key_update" extension is used by the client and the
server to negotiate an HPKE ciphersuite to use, which refers to the
combination of a KEM, KDF, AEAD combination. These HPKE ciphersuites
are communicated in the ClientHello and EncryptedExtensions messages.
The values for the KEM, the KDF, and the AEAD algorithms are taken from
the IANA registry created by <xref target="RFC9180"/>.</t>

<t>This extension is only supported with TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/>
and newer; if TLS 1.2 <xref target="RFC5246"/> or earlier is negotiated, the peers MUST ignore
this extension.</t>

<t>This document defines a new extension type, the extended_key_update(TBD1), as
shown in <xref target="extension-fig"/>, which can be used to signal the supported
HPKE ciphersuites for the extended key update message to the peer.</t>

<figure title="ExtensionType Structure." anchor="extension-fig"><artwork><![CDATA[
   enum {
       extended_key_update(TBD1), (65535)
   } ExtensionType;
]]></artwork></figure>

<t>This new extension is populated with the structure shown in <xref target="ciphersuite-fig"/>.</t>

<figure title="HpkeCipherSuites Structure." anchor="ciphersuite-fig"><artwork><![CDATA[
struct {
    uint16 kdf_id;
    uint16 aead_id;
    uint16 kem_id;
} HpkeCipherSuite;

struct {
    HpkeCipherSuite cipher_suites<4..2^16-4>;
} HpkeCipherSuites;
]]></artwork></figure>

<t>Whenever it is sent by the client as a ClientHello message extension
(<xref target="I-D.ietf-tls-rfc8446bis"/>, Section 4.1.2), it indicates what HPKE
ciphersuites it supports.</t>

<t>A server that supports and wants to use the extended key update feature
MUST send the "extended_key_update" extension in the EncryptedExtensions
message indicating what HPKE ciphersuites it prefers to use. The
extension, shown in <xref target="ciphersuite-fig"/>, contains a list of supported
ciphersuites in preference order, with the most preferred version first.</t>

<t>The server MUST select one of the ciphersuites from the list offered
by the client. If no suitable ciphersuite is found, the server MUST NOT
return an "extended_key_update" extension to the client.</t>

<t>If this extension is not present, as with any TLS extensions, servers
ignore any the functionality specified in this document and applications
have to rely on the features offered by the TLS 1.3-specified KeyUpdate
instead.</t>

</section>
<section anchor="using-hpke"><name>Using HPKE</name>

<t>To support interoperability between the two endpoints, the following payload
structure is defined.</t>

<figure title="HPKE_Payload Structure." anchor="hpke-payload-fig"><artwork><![CDATA[
struct {
    opaque kid<0..2^16-1>;    
    opaque enc<0..2^16-1>;
    opaque ct<32..2^8-1>;
} HPKE_Payload;
]]></artwork></figure>

<t>The fields have the following meaning:</t>

<t><list style="symbols">
  <t>kid: The identifier of the recipient public key used for the HPKE
     computation. This allows the sender to indicate what public
     key it used in case it has multiple public keys for a given
     recipient.</t>
  <t>enc: The HPKE encapsulated key, used by the peers to decrypt the
corresponding payload field.</t>
  <t>ct: The ciphertext, which is the result of encrypting a random value,
RAND, with HPKE, as described in <xref target="RFC9180"/> using the HPKE SealBase()
operation. RAND MUST be at least 32 bytes long but the maximum length
MUST NOT exceed 255 bytes. This RAND value is input to the
application_traffic_secret generation, as described in <xref target="key_update"/>.</t>
</list></t>

<t>This specification MUST use the HPKE Base mode; authenticated HPKE modes
are not supported.</t>

<t>The SealBase() operation requires four inputs, namely</t>

<t><list style="symbols">
  <t>the public key of the recipient,</t>
  <t>context information (info),</t>
  <t>associated data (aad), and</t>
  <t>plaintext.</t>
</list></t>

<t>SealBase() will return two outputs, "enc" and "ct", which will
be stored in the HPKE_Payload structure.</t>

<t>Two input values for the SealBase() operation require further
explanation:</t>

<t><list style="symbols">
  <t>The info value MUST be set to the empty string.</t>
  <t>The aad value MUST be populated with the TLS exporter secret.
The exporter interface is described in Section 7.5 of
<xref target="I-D.ietf-tls-rfc8446bis"/>. For (D)TLS 1.3, the
exporter_master_secret MUST be used, not the
early_exporter_master_secret.</t>
</list></t>

<t>The exporter value is computed as:</t>

<figure><artwork><![CDATA[
   TLS-Exporter(label, context_value, key_length) =
       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                         "exporter", Hash(context_value), key_length)
]]></artwork></figure>

<t>The following values are used for the TLS-Exporter function:</t>

<t><list style="symbols">
  <t>the label is set to "extended key update client" and
"extended key update server" for extended key updates sent by the
client or server, respectively</t>
  <t>the context_value is set to a zero length value.</t>
  <t>the length of the exported value is equal to the length of
the output of the hash function associated with the selected
ciphersuite.</t>
</list></t>

<t>The recipient will use the OpenBase() operation with the "enc"
and the "ct" parameters received from the sender.  The
"aad" and the "info" parameters are constructed as previously
described for SealBase().</t>

<t>The OpenBase function will, if successful, decrypt "ct".  When
decrypted, the result will either return the random value or an
error.</t>

</section>
<section anchor="ext-key-update"><name>Extended Key Update Message</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate that the sender
is updating its sending cryptographic keys.  This message can be sent
by either peer after it has sent a Finished message and exchanged the
necessary public key(s) and HPKE payload(s) by the application layer
protocol. Implementations that receive a ExtendedKeyUpdate message prior
to receiving a Finished message or prior to the exchange of the needed
application layer payloads (public key and HPKE) MUST terminate the
connection with an "unexpected_message" alert.</t>

<t>After sending the ExtendedKeyUpdate message, the sender MUST send all
its traffic using the next generation of keys, computed as described
in <xref target="key_update"/>. Upon receiving an ExtendedKeyUpdate message, the
receiver MUST update its receiving traffic keys.</t>

<figure title="ExtendedKeyUpdate Structure." anchor="extended-key-update-fig"><artwork><![CDATA[
enum {
    update_not_requested(0), update_requested(1), (255)
} KeyUpdateRequest;

struct {
    opaque kid<0..2^16-1>;
    KeyUpdateRequest request_update;
} ExtendedKeyUpdate;
]]></artwork></figure>

<t>The kid field indicates the public key of the recipient that was
used by HPKE to encrypt the random value.</t>

<t>The request_update field indicates whether the recipient of the
ExtendedKeyUpdate should respond with its own ExtendedKeyUpdate.
If an implementation receives any other value, it MUST terminate
the connection with an "illegal_parameter" alert.</t>

<t>If the request_update field is set to "update_requested", the
receiver MUST send an ExtendedKeyUpdate of its own with request_update set to
"update_not_requested" prior to sending its next Application Data
record.  This mechanism allows either side to force an update to the
entire connection, but causes an implementation which receives
multiple ExtendedKeyUpdates while it is silent to respond with a single
update.  Note that implementations may receive an arbitrary number of
messages between sending a ExtendedKeyUpdate with request_update set to
"update_requested" and receiving the peer's ExtendedKeyUpdate, because those
messages may already be in flight.</t>

<t>If implementations independently send their own ExtendedKeyUpdate with
request_update set to "update_requested", and they cross in flight,
then each side will also send a response, with the result that each
side increments by two generations.</t>

<t>The sender MUST encrypt ExtendedKeyUpdate messages with the old keys
and the receiver MUST decrypt ExtendedKeyUpdate messages with the old
keys. Senders MUST enforce that ExtendedKeyUpdate encrypted with the
old key is received before accepting any messages encrypted with the
new key.</t>

<t>If a sending implementation receives a ExtendedKeyUpdate with request_update
set to "update_requested", it MUST NOT send its own ExtendedKeyUpdate if
that would cause it to exceed these limits and SHOULD instead ignore the
"update_requested" flag.</t>

<t>The ExtendedKeyUpdate and the KeyUpdates MAY be used in combination.</t>

</section>
<section anchor="key_update"><name>Updating Traffic Secrets</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate that
the sender is updating its sending cryptographic keys.  This message can
be sent by either endpoint after three conditions are met:</t>

<t><list style="symbols">
  <t>The endpoint has sent a Finished message.</t>
  <t>The endpoint is configured with a public key of the recipient. The process
for exchanging and updating these public keys is application-specific.</t>
  <t>The endpoint has conveyed the HPKE payload at the application
layer to the peer. HPKE is used to securely exchange a random number
using a KEM.</t>
</list></t>

<t>The next generation of traffic keys is computed as described in this
section. The traffic keys are derived, as described in
Section 7.3 of <xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<t>There are two changes to the application_traffic_secret computation
described in <xref target="I-D.ietf-tls-rfc8446bis"/>, namely</t>

<t><list style="symbols">
  <t>the label is adjusted to distinguish it from the regular KeyUpdate
message, and</t>
  <t>the random value, which was securely exchanged between the two
endpoints, is included in the generation of the application
traffic secret.</t>
</list></t>

<t>The next generation application_traffic_secret is computed as:</t>

<figure><artwork><![CDATA[
application_traffic_secret_N+1 =
    HKDF-Expand-Label(RAND,
                      "traffic up2", "", Hash.length)
]]></artwork></figure>

<t>Once client_/server_application_traffic_secret_N+1 and its associated
traffic keys have been computed, implementations SHOULD delete
client_/server_application_traffic_secret_N and its associated
traffic keys.</t>

</section>
<section anchor="example"><name>Example</name>

<t><xref target="fig-key-update"/> shows the interaction between a TLS 1.3 client
and server graphically. This section shows an example message exchange
where a client updates its sending keys.</t>

<t>There are three phases worthwhile to highlight:</t>

<t><list style="numbers">
  <t>First, the support for the functionality in this specification
is negotiated in the ClientHello and the EncryptedExtensions
messages. As a result, the two peers have a shared understanding
of the negotiated HPKE ciphersuite, which includes a KEM, a KDF,
and an AEAD.</t>
  <t>Once the initial handshake is completed, application layer
payloads can be exchanged. The two peers exchange public keys
suitable for use with the HPKE KEM and subsequently an HPKE-
encrypted random value.</t>
  <t>When a key update needs to be triggered by the application,
it instructs the (D)TLS stack to transmit an ExtendedKeyUpdate
message.</t>
</list></t>

<t><xref target="fig-key-update"/> provides an overview of the exchange starting
with the initial negotiation followed by the key update, which
involves the application layer interaction.</t>

<figure title="Extended Key Update Message Exchange." anchor="fig-key-update"><artwork><![CDATA[
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share
     | + signature_algorithms
     v + extended_key_update   -------->
                                                  ServerHello  ^ Key
                                                  + key_share  | Exch
                                                               v
                                        {EncryptedExtensions   ^ Server
                                       + extended_key_update}  | Params
                                         {CertificateRequest}  v
                                                {Certificate}  ^
                                          {CertificateVerify}  | Auth
                                                   {Finished}  v
                               <--------           
     ^ {Certificate
Auth | {CertificateVerify}
     v {Finished}              -------->
                                  ...
                              some time later
                                  ...
  +---------------- Application Layer Exchange --------------+
  |                                                          |
  |     (a)  Sender sends public key to the client           |
  |                                                          |
  |     (b)  Client uses HPKE to generate enc, and ct        |
  |                                                          |
  |     (c)  Client sents enc, and ct to the server          |
  |                                                          |
  |     (d)  Client triggers the extended key update         |
  |          at the TLS layer                                |
  |                                                          |
  +---------------- Application Layer Exchange --------------+

       [ExtendedKeyUpdate]     -------->
                               <--------  [ExtendedKeyUpdate]
]]></artwork></figure>

<t>For the server to generate and transmit a public key it is
necessary to determine whether the extended key update extension
has been negotiated success and what HPKE ciphersuite was
selected. This information can be obtained by the application
by using the "Get HPKE Ciphersuite" API.</t>

<t>Once the public key has been sent to the client, it can use the
"Encapsulate" API with SealBase(pk, info, aad, rand) to produce
enc, and ct. A random value has to be passed into the API call.</t>

<t>The client transmit the enc, and ct values to the server, which
performs the reverse operation using the "Decapsulate" API with
OpenBase(enc, skR, info, aad, ct) returning the random value.</t>

<t>The server uses the "Update-Prepare" API to get the (D)TLS stack
ready for a key update.</t>

<t>When the client wants to switch to the new sending key it uses the
"Update-Trigger" API to inform the (D)TLS library to trigger the
transmission of the ExtendedKeyUpdate message.</t>

</section>
<section anchor="dtls-13-considerations"><name>DTLS 1.3 Considerations</name>

<t>As with other handshake messages with no built-in response, the
ExtendedKeyUpdate MUST be acknowledged.  In order to facilitate
epoch reconstruction implementations MUST NOT send records with
the new keys or send a new ExtendedKeyUpdate until the previous
ExtendedKeyUpdate has been acknowledged (this avoids having too
many epochs in active use).</t>

<t>Due to loss and/or reordering, DTLS 1.3 implementations may receive a
record with an older epoch than the current one (the requirements
above preclude receiving a newer record). They SHOULD attempt to
process those records with that epoch but MAY opt to discard
such out-of-epoch records.</t>

<t>Due to the possibility of an ACK message for an ExtendedKeyUpdate
being lost and thereby preventing the sender of the ExtendedKeyUpdate
from updating its keying material, receivers MUST retain the
pre-update keying material until receipt and successful decryption
of a message using the new keys.</t>

</section>
<section anchor="api-considerations"><name>API Considerations</name>

<t>The creation and processing of the extended key update messages SHOULD be
implemented inside the (D)TLS library even if it is possible to implement
it at the application layer. (D)TLS implementations supporting the use of
the extended key update SHOULD provide application programming interfaces
by which clients and server may request and process the extended key update
messages.</t>

<t>It is also possible to implement this API outside of the (D)TLS library.
This may be preferable in cases where the application does not have
access to a TLS library with these APIs or when TLS is handled independently
of the application-layer protocol.</t>

<t>All APIs MUST fail if the connection uses a (D)TLS version of 1.2 or earlier.</t>

<t>The following sub-sections describe APIs that are considered necessary to
implement the extended key update functionality but the description is
informative only.</t>

<section anchor="the-get-hpke-ciphersuite-api"><name>The "Get HPKE Ciphersuite" API</name>

<t>This API allows the application to determine the negotiated HPKE ciphersuite
from the (D)TLS stack. This information is useful for the application since
it needs to exchange or present public keys to the stack.</t>

<t>It takes a reference to the initial connection as input and returns the
HpkeCipherSuite structure (if the extension was successfully negotiated)
or an empty payload otherwise.</t>

</section>
<section anchor="the-encapsulate-api"><name>The "Encapsulate" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
SealBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>public key of the recipient</t>
  <t>HPKE ciphersuite</t>
  <t>Random value</t>
</list></t>

<t>It returns the <xref target="hpke-payload-fig"/> payload.</t>

</section>
<section anchor="the-decapsulate-api"><name>The "Decapsulate" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
OpenBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>a reference to the secret key corresponding to the previously exchanged public key</t>
  <t>the <xref target="hpke-payload-fig"/> payload</t>
</list></t>

<t>It returns the random value, in case of success.</t>

</section>
<section anchor="the-update-prepare-api"><name>The "Update-Prepare" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
OpenBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>the random value obtained from the "Decapsulate" API call</t>
</list></t>

<t>It returns the success or failure.</t>

</section>
<section anchor="the-update-trigger-api"><name>The "Update-Trigger" API</name>

<t>This API allows the application to request the (D)TLS stack to initiate
an extended key update using the message defined in <xref target="ext-key-update"/>.</t>

<t>It takes an identifier to the public key of the recipient as input and
returns success or failure.</t>

</section>
</section>
<section anchor="post-quantum-considerations"><name>Post-Quantum Considerations</name>

<t>Hybrid key exchange refers to using multiple key exchange algorithms
simultaneously and combining the result with the goal of providing
security even if all but one of the component algorithms is broken.
It is motivated by transition to post-quantum cryptography.  HPKE can
be extended to support hybrid post-quantum Key Encapsulation
Mechanisms (KEMs), as defined in <xref target="I-D.westerbaan-cfrg-hpke-xyber768d00"/></t>

</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t><xref target="RFC9325"/> provides a good summary of what (perfect) forward secrecy
is and how it relates to the TLS protocol. In summary, it says:</t>

<t>"Forward secrecy (also called "perfect forward secrecy" or "PFS") is a
defense against an attacker who records encrypted conversations where
the session keys are only encrypted with the communicating parties'
long-term keys. Should the attacker be able to obtain these long-term
keys at some point later in time, the session keys and thus the entire
conversation could be decrypted."</t>

<t>Appendix F of <xref target="I-D.ietf-tls-rfc8446bis"/> goes into details of
explaining the security properties of the TLS 1.3 protocol and notes
"... forward secrecy without rerunning (EC)DHE does not stop an attacker
from doing static key exfiltration." It concludes with a recommendation
by saying: "Frequently rerunning (EC)DHE forces an attacker to do dynamic
key exfiltration (or content exfiltration)." (The term key exfiltration
is defined in <xref target="RFC7624"/>.)</t>

<t>This specification re-uses public key encryption to update application
traffic secrets in one direction. Hence, updates of these application
traffic secrets in both directions requires two ExtendedKeyUpdate messages.</t>

<t>To perform public key encryption the sender needs to have access to the
public key of the recipient. This document makes the assumption that the
public key in the exchanged end-entity certificate can be used with the
HPKE KEM. The use of HPKE, and the recipients long-term public key, in
the ephemeral-static Diffie-Hellman exchange provides perfect forward
secrecy of the ongoing connection and demonstrates possession of the
long-term secret key.</t>

</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t>IANA is also requested to allocate a new value in the "TLS ExtensionType Values"
subregistry of the "Transport Layer Security (TLS) Extensions"
registry <xref target="TLS-Ext-Registry"/>, as follows:</t>

<t><list style="symbols">
  <t>Value: TBD1</t>
  <t>Extension Name: extended_key_update</t>
  <t>TLS 1.3: CH, EE</t>
  <t>DTLS-Only: N</t>
  <t>Recommended: Y</t>
  <t>Reference: [This document]</t>
</list></t>

<t>IANA is also requested to allocate a new value in the "TLS
HandshakeType" subregistry of the "Transport Layer Security (TLS)
Extensions" registry <xref target="TLS-Ext-Registry"/>, as follows:</t>

<t><list style="symbols">
  <t>Value: TBD2</t>
  <t>Description: ExtendedKeyUpdate</t>
  <t>DTLS-OK: Y</t>
  <t>Reference: [This document]</t>
</list></t>

</section>


  </middle>

  <back>


    <references title='Normative References' anchor="sec-normative-references">



<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="S. Bradner" initials="S." surname="Bradner"/>
    <date month="March" year="1997"/>
    <abstract>
      <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>


<reference anchor="I-D.ietf-tls-rfc8446bis">
   <front>
      <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
      <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
         <organization>Windy Hill Systems, LLC</organization>
      </author>
      <date day="7" month="July" year="2023"/>
      <abstract>
	 <t>   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

   This document updates RFCs 5705, 6066, 7627, and 8422 and obsoletes
   RFCs 5077, 5246, 6961, and 8446.  This document also specifies new
   requirements for TLS 1.2 implementations.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-rfc8446bis-09"/>
   
</reference>

<reference anchor="RFC9180">
  <front>
    <title>Hybrid Public Key Encryption</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="K. Bhargavan" initials="K." surname="Bhargavan"/>
    <author fullname="B. Lipp" initials="B." surname="Lipp"/>
    <author fullname="C. Wood" initials="C." surname="Wood"/>
    <date month="February" year="2022"/>
    <abstract>
      <t>This document describes a scheme for hybrid public key encryption (HPKE). This scheme provides a variant of public key encryption of arbitrary-sized plaintexts for a recipient public key. It also includes three authenticated variants, including one that authenticates possession of a pre-shared key and two optional ones that authenticate possession of a key encapsulation mechanism (KEM) private key. HPKE works for any combination of an asymmetric KEM, key derivation function (KDF), and authenticated encryption with additional data (AEAD) encryption function. Some authenticated variants may not be supported by all KEMs. We provide instantiations of the scheme using widely used and efficient primitives, such as Elliptic Curve Diffie-Hellman (ECDH) key agreement, HMAC-based key derivation function (HKDF), and SHA2.</t>
      <t>This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9180"/>
  <seriesInfo name="DOI" value="10.17487/RFC9180"/>
</reference>

<reference anchor="RFC9147">
  <front>
    <title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
    <author fullname="N. Modadugu" initials="N." surname="Modadugu"/>
    <date month="April" year="2022"/>
    <abstract>
      <t>This document specifies version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
      <t>The DTLS 1.3 protocol is based on the Transport Layer Security (TLS) 1.3 protocol and provides equivalent security guarantees with the exception of order protection / non-replayability. Datagram semantics of the underlying transport are preserved by the DTLS protocol.</t>
      <t>This document obsoletes RFC 6347.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9147"/>
  <seriesInfo name="DOI" value="10.17487/RFC9147"/>
</reference>




    </references>

    <references title='Informative References' anchor="sec-informative-references">



<reference anchor="RFC9325">
  <front>
    <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
    <author fullname="Y. Sheffer" initials="Y." surname="Sheffer"/>
    <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"/>
    <author fullname="T. Fossati" initials="T." surname="Fossati"/>
    <date month="November" year="2022"/>
    <abstract>
      <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are used to protect data exchanged over a wide range of application protocols and can also form the basis for secure transport protocols. Over the years, the industry has witnessed several serious attacks on TLS and DTLS, including attacks on the most commonly used cipher suites and their modes of operation. This document provides the latest recommendations for ensuring the security of deployed services that use TLS and DTLS. These recommendations are applicable to the majority of use cases.</t>
      <t>RFC 7525, an earlier version of the TLS recommendations, was published when the industry was transitioning to TLS 1.2. Years later, this transition is largely complete, and TLS 1.3 is widely available. This document updates the guidance given the new environment and obsoletes RFC 7525. In addition, this document updates RFCs 5288 and 6066 in view of recent attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="195"/>
  <seriesInfo name="RFC" value="9325"/>
  <seriesInfo name="DOI" value="10.17487/RFC9325"/>
</reference>

<reference anchor="RFC7296">
  <front>
    <title>Internet Key Exchange Protocol Version 2 (IKEv2)</title>
    <author fullname="C. Kaufman" initials="C." surname="Kaufman"/>
    <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
    <author fullname="Y. Nir" initials="Y." surname="Nir"/>
    <author fullname="P. Eronen" initials="P." surname="Eronen"/>
    <author fullname="T. Kivinen" initials="T." surname="Kivinen"/>
    <date month="October" year="2014"/>
    <abstract>
      <t>This document describes version 2 of the Internet Key Exchange (IKE) protocol. IKE is a component of IPsec used for performing mutual authentication and establishing and maintaining Security Associations (SAs). This document obsoletes RFC 5996, and includes all of the errata for it. It advances IKEv2 to be an Internet Standard.</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="79"/>
  <seriesInfo name="RFC" value="7296"/>
  <seriesInfo name="DOI" value="10.17487/RFC7296"/>
</reference>

<reference anchor="RFC9261">
  <front>
    <title>Exported Authenticators in TLS</title>
    <author fullname="N. Sullivan" initials="N." surname="Sullivan"/>
    <date month="July" year="2022"/>
    <abstract>
      <t>This document describes a mechanism that builds on Transport Layer Security (TLS) or Datagram Transport Layer Security (DTLS) and enables peers to provide proof of ownership of an identity, such as an X.509 certificate. This proof can be exported by one peer, transmitted out of band to the other peer, and verified by the receiving peer.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9261"/>
  <seriesInfo name="DOI" value="10.17487/RFC9261"/>
</reference>

<reference anchor="RFC5246">
  <front>
    <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
    <author fullname="T. Dierks" initials="T." surname="Dierks"/>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <date month="August" year="2008"/>
    <abstract>
      <t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="5246"/>
  <seriesInfo name="DOI" value="10.17487/RFC5246"/>
</reference>

<reference anchor="RFC7624">
  <front>
    <title>Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="B. Schneier" initials="B." surname="Schneier"/>
    <author fullname="C. Jennings" initials="C." surname="Jennings"/>
    <author fullname="T. Hardie" initials="T." surname="Hardie"/>
    <author fullname="B. Trammell" initials="B." surname="Trammell"/>
    <author fullname="C. Huitema" initials="C." surname="Huitema"/>
    <author fullname="D. Borkmann" initials="D." surname="Borkmann"/>
    <date month="August" year="2015"/>
    <abstract>
      <t>Since the initial revelations of pervasive surveillance in 2013, several classes of attacks on Internet communications have been discovered. In this document, we develop a threat model that describes these attacks on Internet confidentiality. We assume an attacker that is interested in undetected, indiscriminate eavesdropping. The threat model is based on published, verified attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="7624"/>
  <seriesInfo name="DOI" value="10.17487/RFC7624"/>
</reference>


<reference anchor="I-D.westerbaan-cfrg-hpke-xyber768d00">
   <front>
      <title>X25519Kyber768Draft00 hybrid post-quantum KEM for HPKE</title>
      <author fullname="Bas Westerbaan" initials="B." surname="Westerbaan">
         <organization>Cloudflare</organization>
      </author>
      <author fullname="Christopher A. Wood" initials="C. A." surname="Wood">
         <organization>Cloudflare</organization>
      </author>
      <date day="4" month="May" year="2023"/>
      <abstract>
	 <t>   This memo defines X25519Kyber768Draft00, a hybrid post-quantum KEM,
   for HPKE (RFC9180).  This KEM does not support the authenticated
   modes of HPKE.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-westerbaan-cfrg-hpke-xyber768d00-02"/>
   
</reference>


<reference anchor="ANSSI-DAT-NT-003" target="https://www.ssi.gouv.fr/uploads/2015/09/NT_IPsec_EN.pdf">
  <front>
    <title>Recommendations for securing networks with IPsec, Technical Report</title>
    <author >
      <organization>ANSSI</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="TLS-Ext-Registry" target="https://www.iana.org/assignments/tls-extensiontype-values">
  <front>
    <title>Transport Layer Security (TLS) Extensions</title>
    <author >
      <organization>IANA</organization>
    </author>
    <date year="2023" month="November"/>
  </front>
</reference>


    </references>


<?line 669?>

<section anchor="acknowledgments"><name>Acknowledgments</name>

<t>We would like to thank the members of the "TSVWG DTLS for SCTP
Requirements Design Team" for their discussion. The members, in
no particular order, are:</t>

<t><list style="symbols">
  <t>Marcelo Ricardo Leitner</t>
  <t>Zaheduzzaman Sarker</t>
  <t>Magnus Westerlund</t>
  <t>John Mattsson</t>
  <t>Claudio Porfiri</t>
  <t>Xin Long</t>
  <t>Michael Tuexen</t>
</list></t>

<t>Additionally, we would like to thank the chairs of the
Transport and Services Working Group (tsvwg) Gorry Fairhurst and
Marten Seemann as well as the responsible area director Martin Duke.</t>

<t>Finally, we would like to thank Martin Thomson, Ilari Liusvaara,
Benjamin Kaduk, Scott Fluhrer, Dennis Jackson, David Benjamin,
and Thom Wiggers for a review of an initial version of this
specification.</t>

</section>
<section anchor="rational"><name>Design Rational</name>

<t>The design in this document is motivated by long-lived TLS connections,
which can be observed in, at least, two use cases: industrial IoT
environments and telecommunication operator networks. In the discussions
the desire to develop a design that is also compatible with the ongoing
work on PQC algorithm and the use of KEMs in particular.</t>

<t>HPKE was selected as a building block due to its popularity in IETF
protocols and the availability of implementations. The core building
blocks of HPKE (a KEM and a key derivation function) could, howerver,
be used directly as well.</t>

<t>The design presented in this document utilizes HPKE with the Seal/Open
API calls instead of utilizing Encap/Decap API calls directly. Available
HPKE libraries expose the former API calls and this simplifies the
implementation of the solution described in this document. As a
side-effect, context information can also be passed into these API calls.</t>

<t>The downside of using the currently documented approach is the need to
additionally encrypt plaintext, which in our case is a random value. It
may also introduce complexity with the integration of hybrid approach.</t>

<t>The use of application layer protocol messages to exchange TLS handshake
messages is motiviated by the desire to reduce the impact on the TLS
state machine but also by the prior work on post-handshake authentication
using "Exported Authenticators". A design that exchanges messages
at the TLS layer is possible but raises the question about whether
post-handshake authentication messages should also be exchanged at
the TLS layer to accomplish some level of uniformity. Even the re-
introduction of session renegotation, a feature removed with TLS 1.3,
may seem worthwhile to consider.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAAAAAAAAA9U92XYbx5XvPIf/UAd+CJkAkEQttukkJ7RIWYwkShHpeDI5
E54CugBU2OhGurpJwQzzZXnLj83daulGg5TjzMPowQZ7qbp1962qR6PR7k5t
69wcqpNPtSkyk6k3Zq2+X2W6NmpWVuqi0oVblVWt3uq1qdS5mTaVrddq7+Lt
+b56Mn66u7O7oyeTylzfM8rb892drJwWeglzZZWe1aPaTRflzBR2PqpzNzLy
6ujKrEcNvTp6/GR3Zwo/5mW1PlSuznAuu6oOVV01rj54/Pjrxwcwe2X0YYBs
d+emrK7mVdmsDnliGBEuZYfqtKhNVZh6dIwQ4GCu1kV2qfOyALjWxu3urOzh
7o5S1WxqMlevc39dqbqcpr8tQFvU4YoDHFVm5uKF9bL9d13ZaXx+Wi6X8H68
b4vcFslsgJBRbl09goEmZQ4Pjspf/gpvASKXerWyxVye1k29KCuEe4T38Z8t
4IXXY3URsOzvMA1e66Iwrue2WWqbH6oF3R9HIv1uvvw0Btz558oKZj+3Bhbh
NiZ+BxP/65+fTNGe9J2dLrTJO/dkxroxcPF3s8Vo2cCYQKlxZlqzvfvXP+m6
+r6w12NVztTRapVbYLfzqTXF1GwCcjFWH02WrdtwXNiqWercuBtdte8LLFdl
kdW2gjXDn2MgVQuOs/LKaqU2Jjsfq1eVZfLFyc5rMwMMtm/JPI7vjWd473eO
sbkxX8Dy7k5RVktd22tDTPrx1cuDJ0++pt+no+OxNfWMhAm496tnz15MrPPP
ff3kq8fx97Mv4bctZt3Rvn568Nz//vLg6xfh+sGLJ/7384Nn4fqXLw6ehdlv
DBJnonUxms6q+WixujKjT+uJqb588VX2mKc/Ojs/h4ePLkZnF6PHj58eykoj
C6tk5fS0XBNF9dGw5ICCsGXhSL04Ev1iroA/UfidurH1Qp1+gBtDdWGmi8JO
dQ7voibz4+lqbkAeF3W9coePHt3c3Iyds+N52VwDQR41q7zUmXt08PjJ80eP
v350dnFJA16enI1X2UxGQT0FcDZz0EcKH8XroHVGoApHH80cBBh0172LPD06
O2qv8QGlS1rW4ervWYrVhR7D+I80LGpekK55FBQtvl2vV2Z0rfMmsCUv5qy8
NkugGizngLT7aDRSegIL0VNSmhcL8xl2QbmVmdoZIB4JBdI6M5VTWoGOx2sG
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
9RwY/M4+D18JBKb6X5Aisn+2dgAA

-->

</rfc>

