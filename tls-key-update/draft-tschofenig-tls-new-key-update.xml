<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.4 (Ruby 3.0.2) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>

<?rfc rfcedstyle="yes"?>
<?rfc tocindent="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-tschofenig-tls-extended-key-update-01" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="Extended Key Update for TLS">Extended Key Update for Transport Layer Security (TLS) 1.3</title>

    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Siemens</organization>
      <address>
        <email>hannes.tschofenig@gmx.net</email>
      </address>
    </author>
    <author initials="M." surname="Tüxen" fullname="Michael Tüxen">
      <organization>Münster Univ. of Applied Sciences</organization>
      <address>
        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>
    <author initials="T." surname="Reddy" fullname="Tirumaleswar Reddy">
      <organization>Nokia</organization>
      <address>
        <email>kondtir@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Fries" fullname="Steffen Fries">
      <organization>Siemens</organization>
      <address>
        <email>steffen.fries@siemens.com</email>
      </address>
    </author>

    <date year="2024" month="February" day="04"/>

    <area>Security</area>
    <workgroup>TLS</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<?line 72?>

<t>The Transport Layer Security (TLS) 1.3 specification offers a dedicated
message to update cryptographic keys during the lifetime of an ongoing session.
The traffic secret and the initialization vector are updated directionally
but the sender may trigger the recipient, via the request_update field,
to transmit a key update message in the reverse direction.</t>

<t>In environments where sessions are long-lived, such as industrial IoT or
telecommunication networks, this key update alone is insufficient since
forward secrecy is not offered via this mechanism. Earlier versions
of TLS allowed the two peers to perform renegotiation, which is a handshake
that establishes new cryptographic parameters for an existing session.
When a security vulnerability with the renegotiation mechanism was discovered,
RFC 5746 was developed as a fix. Renegotiation has, however, been removed from
version 1.3 leaving a gap in the feature set of TLS.</t>

<t>This specification defines an extended key update that supports forward secrecy.</t>



    </abstract>



  </front>

  <middle>


<?line 91?>

<section anchor="introduction"><name>Introduction</name>

<t>The features of TLS and DTLS have changed over the years and while newer versions
optimized the protocol and at the same time enhanced features (often with the help
of extensions) some functionality was removed without replacement. The ability to
update keys and initialization vectors has been added in TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/>
using the KeyUpdate message and it intended to (partially) replace renegotiation from earlier
TLS versions. The renegotiation feature, while complex, offered additional
functionality that is not supported with TLS 1.3 anymore, including the update
keys with a Diffie-Hellman exchange during the lifetime of a session. If a traffic
secret (referred as application_traffic_secret_N) has been compromised, an attacker
can passively eavesdrop on all future data sent on the connection, including data
encrypted with application_traffic_secret_N+1, application_traffic_secret_N+2, etc.</t>

<t>While such a feature is less relevant in environments with shorter-lived sessions,
such as transactions on the web, there are uses of TLS and DTLS where long-lived
sessions are common. In those environments, such as industrial IoT and
telecommunication networks, availability is important and an interruption of the
communication due to periodic session resumptions is not an option. Re-running a
handshake with (EC)DHE and switching from the old to the new session may be a solution
for some applications but introduces complexity, impacts performance and may lead to
service interruption as well.</t>

<t>Some deployments have used IPsec in the past to secure their communication protocol
and have now decided to switch to TLS or DTLS instead. The requirement for updates of
cryptographic keys for an existing session has become a requirement. For IPsec, NIST,
BSI, and ANSSI recommend to re-run Diffie-Hellman exchanges frequently to provide forward
secrecy and force attackers to perform a dynamic key extraction <xref target="RFC7624"/>. ANSSI
writes "It is recommended to force the periodic renewal of the keys, e.g., every
hour and every 100 GB of data, in order to limit the impact of a key compromise."
<xref target="ANSSI-DAT-NT-003"/>. While IPsec/IKEv2 <xref target="RFC7296"/> offers the desired functionality,
developers often decide to use TLS/DTLS to simplify integration with cloud-based
environments.</t>

<t>This specification defines a new key update mechanism supporting forward
secrecy. It does so by re-using the design approach introduced by the "Exported Authenticators"
specification <xref target="RFC9261"/>, which uses the application layer protocol to exchange post-handshake
messages. This approach minimizes the impact on the TLS state machine but places more
burden on application layer protocol designer. To achieve interoperability the payloads
exchanged via the application layer are specified in this document and we make use of
Hybrid Public Key Encryption (HPKE) <xref target="RFC9180"/>, which offers an easy migration path
for the integration of post quantum cryptography with its key encapsulation construction
(KEM). Since HPKE requires the sender to possess the recipient's public key, those public
keys need to be exchanged upfront. This specification is silent about
when and how often these public keys are exchanged by the application layer protocol. This is
an intentional design decision to offer flexibility for developers and there is experience with
such an approach already from secure end-to-end messaging protocols. To synchronize the
switch to the new traffic secret, the key updates are directional and accomplished with a new
key update message. The trigger to switch to the new traffic secrets is necessary since the
TLS record layer conveys no key identifier like an epoch or a Connection Identifier (CID).</t>

<t>The support for the functionality described in this specification is signaled using the
TLS extension mechanism. Using the extended key update message frequently forces an attacker
to perform dynamic key exfiltration.</t>

<t>This specification is applicable to both TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/> and
DTLS 1.3 <xref target="RFC9147"/>. Throughout the specification we do not distinguish between
these two protocols unless necessary for better understanding.</t>

</section>
<section anchor="terminology-and-requirements-language"><name>Terminology and Requirements Language</name>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

<t>To distinguish the key update procedure defined in <xref target="I-D.ietf-tls-rfc8446bis"/>
from the key update procedure specified in this document, we use the terms
"key update" and "extended key update", respectively.</t>

<t>This document re-uses the Key Encapsulation Mechanism (KEM) terminology
from RFC 9180 <xref target="RFC9180"/>.</t>

<t>The following terms are used in this document:</t>

<t><list style="symbols">
  <t>KDF: Key Derivation Function</t>
  <t>AEAD: Authenticated Encryption with Associated Data</t>
  <t>HPKE: Hybrid Public Key Encryption</t>
</list></t>

</section>
<section anchor="negotiating-the-extended-key-update"><name>Negotiating the Extended Key Update</name>

<t>The "extended_key_update" extension is used by the client and the
server to negotiate an HPKE ciphersuite to use, which refers to the
combination of a KEM, KDF, AEAD combination. These HPKE ciphersuites
are communicated in the ClientHello and EncryptedExtensions messages.
The values for the KEM, the KDF, and the AEAD algorithms are taken from
the IANA registry created by <xref target="RFC9180"/>.</t>

<t>This extension is only supported with TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/>
and newer; if TLS 1.2 <xref target="RFC5246"/> or earlier is negotiated, the peers MUST ignore
this extension.</t>

<t>This document defines a new extension type, the extended_key_update(TBD1), as
shown in <xref target="extension-fig"/>, which can be used to signal the supported
HPKE ciphersuites for the extended key update message to the peer.</t>

<figure title="ExtensionType Structure." anchor="extension-fig"><artwork><![CDATA[
   enum {
       extended_key_update(TBD1), (65535)
   } ExtensionType;
]]></artwork></figure>

<t>This new extension is populated with the structure shown in <xref target="ciphersuite-fig"/>.</t>

<figure title="HpkeCipherSuites Structure." anchor="ciphersuite-fig"><artwork><![CDATA[
struct {
    uint16 kdf_id;
    uint16 aead_id;
    uint16 kem_id;
} HpkeCipherSuite;

struct {
    HpkeCipherSuite cipher_suites<4..2^16-4>;
} HpkeCipherSuites;
]]></artwork></figure>

<t>Whenever it is sent by the client as a ClientHello message extension
(<xref target="I-D.ietf-tls-rfc8446bis"/>, Section 4.1.2), it indicates what HPKE
ciphersuites it supports.</t>

<t>A server that supports and wants to use the extended key update feature
MUST send the "extended_key_update" extension in the EncryptedExtensions
message indicating what HPKE ciphersuites it prefers to use. The
extension, shown in <xref target="ciphersuite-fig"/>, contains a list of supported
ciphersuites in preference order, with the most preferred version first.</t>

<t>The server MUST select one of the ciphersuites from the list offered
by the client. If no suitable ciphersuite is found, the server MUST NOT
return an "extended_key_update" extension to the client.</t>

<t>If this extension is not present, as with any TLS extensions, servers
ignore any the functionality specified in this document and applications
have to rely on the features offered by the TLS 1.3-specified KeyUpdate
instead.</t>

</section>
<section anchor="using-hpke"><name>Using HPKE</name>

<t>To support interoperability between the two peers, the following payload
structure is defined.</t>

<figure title="HPKE_Payload Structure." anchor="hpke-payload-fig"><artwork><![CDATA[
struct {
    opaque enc<0..2^16-1>;
    opaque ct<32..2^8-1>;
} HPKE_Payload;
]]></artwork></figure>

<t>The fields have the following meaning:</t>

<t><list style="symbols">
  <t>enc: The HPKE encapsulated key, used by the peers to decrypt the
corresponding payload field.</t>
  <t>ct: The ciphertext, which is the result of encrypting a random value,
RAND, with HPKE, as described in <xref target="RFC9180"/> using the HPKE SealBase()
operation. RAND MUST be at least 32 bytes long but the maximum length
MUST NOT exceed 255 bytes. This RAND value is input to the
application_traffic_secret generation, as described in <xref target="key_update"/>.</t>
</list></t>

<t>This specification MUST use the HPKE Base mode; authenticated modes
are not supported.</t>

<t>The SealBase() operation requires four inputs, namely</t>

<t><list style="symbols">
  <t>the public key of the recipient,</t>
  <t>context information (info),</t>
  <t>associated data (aad), and</t>
  <t>plaintext.</t>
</list></t>

<t>SealBase() will return two outputs, "enc" and "ct", which will
be stored in the HPKE_Payload structure.</t>

<t>Two input values for the SealBase() operation require further
explanation:</t>

<t><list style="symbols">
  <t>The info value MUST be set to the empty string.</t>
  <t>The aad value MUST be populated with the TLS exporter secret.
The exporter interface is described in Section 7.5 of
<xref target="I-D.ietf-tls-rfc8446bis"/>. For (D)TLS 1.3, the
exporter_master_secret MUST be used, not the
early_exporter_master_secret.</t>
</list></t>

<t>The exporter value is computed as:</t>

<figure><artwork><![CDATA[
   TLS-Exporter(label, context_value, key_length) =
       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                         "exporter", Hash(context_value), key_length)
]]></artwork></figure>

<t>The following values are used for the TLS-Exporter function:</t>

<t><list style="symbols">
  <t>the label is set to "extended key update client" and
"extended key update server" for extended key updates sent by the
client or server, respectively</t>
  <t>the context_value is set to a zero length value.</t>
  <t>the length of the exported value is equal to the length of
the output of the hash function associated with the selected
ciphersuite.</t>
</list></t>

<t>The recipient will use the OpenBase() operation with the "enc"
and the "ct" parameters received from the sender.  The
"aad" and the "info" parameters are constructed as previously
described for SealBase().</t>

<t>The OpenBase function will, if successful, decrypt "ct".  When
decrypted, the result will either return the random value or an
error.</t>

</section>
<section anchor="ext-key-update"><name>Extended Key Update Message</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate that the sender
is updating its sending cryptographic keys.  This message can be sent
by either peer after it has sent a Finished message and exchanged the
necessary public key(s) and HPKE payload(s) by the application layer
protocol. Implementations that receive a ExtendedKeyUpdate message prior
to receiving a Finished message or prior to the exchange of the needed
application layer payloads (public key and HPKE) MUST terminate the
connection with an "unexpected_message" alert.</t>

<t>After sending the ExtendedKeyUpdate message, the sender MUST send all
its traffic using the next generation of keys, computed as described
in <xref target="key_update"/>. Upon receiving an ExtendedKeyUpdate message, the
receiver MUST update its receiving traffic keys.</t>

<figure title="ExtendedKeyUpdate Structure." anchor="extended-key-update-fig"><artwork><![CDATA[
enum {
    update_not_requested(0), update_requested(1), (255)
} KeyUpdateRequest;

struct {
    KeyUpdateRequest request_update;
} ExtendedKeyUpdate;
]]></artwork></figure>

<t>The request_update field indicates whether the recipient of the
ExtendedKeyUpdate should respond with its own ExtendedKeyUpdate.
If an implementation receives any other value, it MUST terminate
the connection with an "illegal_parameter" alert.</t>

<t>If the request_update field is set to "update_requested", the
receiver MUST send an ExtendedKeyUpdate of its own with request_update set to
"update_not_requested" prior to sending its next Application Data
record.  This mechanism allows either side to force an update to the
entire connection, but causes an implementation which receives
multiple ExtendedKeyUpdates while it is silent to respond with a single
update.  Note that implementations may receive an arbitrary number of
messages between sending a ExtendedKeyUpdate with request_update set to
"update_requested" and receiving the peer's ExtendedKeyUpdate, because those
messages may already be in flight.  However, because send and receive
keys are derived from independent traffic secrets, retaining the
receive traffic secret does not threaten the forward secrecy of data
sent before the sender changed keys.</t>

<t>If implementations independently send their own ExtendedKeyUpdate with
request_update set to "update_requested", and they cross in flight,
then each side will also send a response, with the result that each
side increments by two generations.</t>

<t>The sender MUST encrypt ExtendedKeyUpdate messages with the old keys
and the receiver MUST decrypt ExtendedKeyUpdate messages with the old
keys. Senders MUST enforce that ExtendedKeyUpdate encrypted with the
old key is received before accepting any messages encrypted with the
new key.</t>

<t>If a sending implementation receives a ExtendedKeyUpdate with request_update
set to "update_requested", it MUST NOT send its own ExtendedKeyUpdate if
that would cause it to exceed these limits and SHOULD instead ignore the
"update_requested" flag.</t>

<t>The ExtendedKeyUpdate and the KeyUpdates MAY be used in combination.</t>

</section>
<section anchor="key_update"><name>Updating Traffic Secrets</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate that
the sender is updating its sending cryptographic keys.  This message can
be sent by either peer after three conditions are met:</t>

<t><list style="symbols">
  <t>The peer has sent a Finished message.</t>
  <t>The peer is configured with a public key of the recipient. The process
for exchanging and updating these public keys is application-specific.</t>
  <t>The peer has successfully sent the HPKE payload at the application
layer to the peer. HPKE is used to securely exchange a random number
using a KEM.</t>
</list></t>

<t>The next generation of traffic keys is computed by generating
client_/server_application_traffic_secret_N+1 from
client_/server_application_traffic_secret_N as described in this
section and then re-deriving the traffic keys as described in
Section 7.3 of <xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<t>There are two changes to the application_traffic_secret computation
described in <xref target="I-D.ietf-tls-rfc8446bis"/>, namely</t>

<t><list style="symbols">
  <t>the label is adjusted to distinguish it from the regular KeyUpdate
message, and</t>
  <t>the hash of the random value encrypted with HPKE is included as a
context value making the next generation of the application
traffic secret dependent on the HPKE-encrypted random value.</t>
</list></t>

<t>The next generation application_traffic_secret is computed as:</t>

<figure><artwork><![CDATA[
application_traffic_secret_N+1 =
    HKDF-Expand-Label(application_traffic_secret_N,
                      "traffic up2", Hash(RAND), Hash.length)
]]></artwork></figure>

<t>Once client_/server_application_traffic_secret_N+1 and its associated
traffic keys have been computed, implementations SHOULD delete
client_/server_application_traffic_secret_N and its associated
traffic keys.</t>

</section>
<section anchor="example"><name>Example</name>

<t><xref target="fig-key-update"/> shows the interaction between a TLS 1.3 client
and server graphically. The example flow shows an update of the sending
keys of the client.</t>

<t>There are three phases worthwhile to highlight:</t>

<t><list style="numbers">
  <t>First, the support for the functionality in this specification
is negotiated in the ClientHello and the EncryptedExtensions
messages. As a result, the two peers have a shared understanding
of the negotiated HPKE ciphersuite, which includes a KEM, a KDF,
and an AEAD.</t>
  <t>Once the initial handshake is completed, application layer
payloads can be exchanged. The two peers exchange public keys
suitable for use with the HPKE KEM and subsequently an HPKE-
encrypted random value.</t>
  <t>When a key update needs to be triggered by the application,
it instructs the (D)TLS stack to transmit an ExtendedKeyUpdate
message.</t>
</list></t>

<figure title="Extended Key Update Message Exchange." anchor="fig-key-update"><artwork><![CDATA[
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share
     | + signature_algorithms
     v + extended_key_update   -------->
                                                  ServerHello  ^ Key
                                                  + key_share  | Exch
                                                               v
                                        {EncryptedExtensions   ^ Server
                                       + extended_key_update}  | Params
                                         {CertificateRequest}  v
                                                {Certificate}  ^
                                          {CertificateVerify}  | Auth
                                                   {Finished}  v
                               <--------           
     ^ {Certificate
Auth | {CertificateVerify}
     v {Finished}              -------->
                                  ...
 ------------------ Application Layer Exchange -------------------
                                        "Get HPKE Ciphersuite" API

                               <--------                 [pk]

  CreateRandom() -> rand

  "Encapsulate" API
   with SealBase(pk, info, aad, rand) -> enc, ct                         

       [enc, ct]               -------->

                                                 "Decapsulate" API
                    with OpenBase(enc, skR, info, aad, ct) -> rand

                                              "Update-Prepare" API
  ------------------ Application Layer Exchange -------------------

  "Update-Trigger" API

       [ExtendedKeyUpdate]     -------->
                               <--------  [ExtendedKeyUpdate]
]]></artwork></figure>

</section>
<section anchor="api-considerations"><name>API Considerations</name>

<t>The creation and processing of the extended key update messages SHOULD be
implemented inside the (D)TLS library even if it is possible to implement
it at the application layer. (D)TLS implementations supporting the use of
the extended key update SHOULD provide application programming interfaces
by which clients and server may request and process the extended key update
messages.</t>

<t>It is also possible to implement this API outside of the(D) TLS library.
This may be preferable in cases where the application does not have
access to a TLS library with these APIs or when TLS is handled independently
of the application-layer protocol.</t>

<t>All APIs MUST fail if the connection uses a (D)TLS version of 1.2 or earlier.</t>

<t>The following sub-sections describe APIs that are considered necessary to
implement the extended key update functionality but the description is
informative only.</t>

<section anchor="the-get-hpke-ciphersuite-api"><name>The "Get HPKE Ciphersuite" API</name>

<t>This API allows the application to determine the negotiated HPKE ciphersuite
from the (D)TLS stack. This information is useful for the application since
it needs to exchange or present public keys to the stack.</t>

<t>It takes a reference to the initial connection as input and returns the
HpkeCipherSuite structure (if the extension was successfully negotiated)
or an empty payload otherwise.</t>

</section>
<section anchor="the-encapsulate-api"><name>The "Encapsulate" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
SealBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>public key of the recipient</t>
  <t>HPKE ciphersuite</t>
  <t>Random value</t>
</list></t>

<t>It returns the <xref target="hpke-payload-fig"/> payload.</t>

</section>
<section anchor="the-decapsulate-api"><name>The "Decapsulate" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
OpenBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>a reference to the secret key corresponding to the previously exchanged public key</t>
  <t>the <xref target="hpke-payload-fig"/> payload</t>
</list></t>

<t>It returns the random value, in case of success.</t>

</section>
<section anchor="the-update-prepare-api"><name>The "Update-Prepare" API</name>

<t>This API allows the application to request the (D)TLS stack to execute HPKE
OpenBase operation. It takes the following values as input:</t>

<t><list style="symbols">
  <t>a reference to the initial connection</t>
  <t>the random value obtained from the "Decapsulate" API call</t>
</list></t>

<t>It returns the success or failure.</t>

</section>
<section anchor="the-update-trigger-api"><name>The "Update-Trigger" API</name>

<t>This API allows the application to request the (D)TLS stack to initiate
an extended key update using the message defined in <xref target="ext-key-update"/>.</t>

<t>It takes no input values and returns success or failure.</t>

</section>
</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t><xref target="RFC9325"/> provides a good summary of what (perfect) forward secrecy
is and how it relates to the TLS protocol. In summary, it says:</t>

<t>"Forward secrecy (also called "perfect forward secrecy" or "PFS") is a
defense against an attacker who records encrypted conversations where
the session keys are only encrypted with the communicating parties'
long-term keys. Should the attacker be able to obtain these long-term
keys at some point later in time, the session keys and thus the entire
conversation could be decrypted."</t>

<t>Appendix F of <xref target="I-D.ietf-tls-rfc8446bis"/> goes into details of
explaining the security properties of the TLS 1.3 protocol and notes
"... forward secrecy without rerunning (EC)DHE does not stop an attacker
from doing static key exfiltration." It concludes with a recommendation
by saying: "Frequently rerunning (EC)DHE forces an attacker to do dynamic
key exfiltration (or content exfiltration)." (The term key exfiltration
is defined in <xref target="RFC7624"/>.)</t>

<t>This specification re-uses public key encryption to update application
traffic secrets in one direction. Hence, updates of these application
traffic secrets in both directions requires two ExtendedKeyUpdate messages.</t>

<t>To perform public key encryption the sender needs to have access to the
public key of the recipient. This document makes the assumption that the
public key in the exchanged end-entity certificate can be used with the
HPKE KEM. The use of HPKE, and the recipients long-term public key, in
the ephemeral-static Diffie-Hellman exchange provides perfect forward
secrecy of the ongoing connection and demonstrates possession of the
long-term secret key.</t>

</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t>IANA is also requested to allocate a new value in the "TLS ExtensionType Values"
subregistry of the "Transport Layer Security (TLS) Extensions"
registry <xref target="TLS-Ext-Registry"/>, as follows:</t>

<t><list style="symbols">
  <t>Value: TBD1</t>
  <t>Extension Name: extended_key_update</t>
  <t>TLS 1.3: CH, EE</t>
  <t>DTLS-Only: N</t>
  <t>Recommended: Y</t>
  <t>Reference: [This document]</t>
</list></t>

<t>IANA is also requested to allocate a new value in the "TLS
HandshakeType" subregistry of the "Transport Layer Security (TLS)
Extensions" registry <xref target="TLS-Ext-Registry"/>, as follows:</t>

<t><list style="symbols">
  <t>Value: TBD2</t>
  <t>Description: ExtendedKeyUpdate</t>
  <t>DTLS-OK: Y</t>
  <t>Reference: [This document]</t>
</list></t>

</section>


  </middle>

  <back>


    <references title='Normative References' anchor="sec-normative-references">



<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="S. Bradner" initials="S." surname="Bradner"/>
    <date month="March" year="1997"/>
    <abstract>
      <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>


<reference anchor="I-D.ietf-tls-rfc8446bis">
   <front>
      <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
      <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
         <organization>Windy Hill Systems, LLC</organization>
      </author>
      <date day="7" month="July" year="2023"/>
      <abstract>
	 <t>   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

   This document updates RFCs 5705, 6066, 7627, and 8422 and obsoletes
   RFCs 5077, 5246, 6961, and 8446.  This document also specifies new
   requirements for TLS 1.2 implementations.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-rfc8446bis-09"/>
   
</reference>


<reference anchor="I-D.ietf-tls-esni">
   <front>
      <title>TLS Encrypted Client Hello</title>
      <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
         <organization>RTFM, Inc.</organization>
      </author>
      <author fullname="Kazuho Oku" initials="K." surname="Oku">
         <organization>Fastly</organization>
      </author>
      <author fullname="Nick Sullivan" initials="N." surname="Sullivan">
         <organization>Cloudflare</organization>
      </author>
      <author fullname="Christopher A. Wood" initials="C. A." surname="Wood">
         <organization>Cloudflare</organization>
      </author>
      <date day="9" month="October" year="2023"/>
      <abstract>
	 <t>   This document describes a mechanism in Transport Layer Security (TLS)
   for encrypting a ClientHello message under a server public key.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Source for this draft and an issue tracker can be found at
   https://github.com/tlswg/draft-ietf-tls-esni
   (https://github.com/tlswg/draft-ietf-tls-esni).

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-esni-17"/>
   
</reference>

<reference anchor="RFC9180">
  <front>
    <title>Hybrid Public Key Encryption</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="K. Bhargavan" initials="K." surname="Bhargavan"/>
    <author fullname="B. Lipp" initials="B." surname="Lipp"/>
    <author fullname="C. Wood" initials="C." surname="Wood"/>
    <date month="February" year="2022"/>
    <abstract>
      <t>This document describes a scheme for hybrid public key encryption (HPKE). This scheme provides a variant of public key encryption of arbitrary-sized plaintexts for a recipient public key. It also includes three authenticated variants, including one that authenticates possession of a pre-shared key and two optional ones that authenticate possession of a key encapsulation mechanism (KEM) private key. HPKE works for any combination of an asymmetric KEM, key derivation function (KDF), and authenticated encryption with additional data (AEAD) encryption function. Some authenticated variants may not be supported by all KEMs. We provide instantiations of the scheme using widely used and efficient primitives, such as Elliptic Curve Diffie-Hellman (ECDH) key agreement, HMAC-based key derivation function (HKDF), and SHA2.</t>
      <t>This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9180"/>
  <seriesInfo name="DOI" value="10.17487/RFC9180"/>
</reference>

<reference anchor="RFC9147">
  <front>
    <title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
    <author fullname="N. Modadugu" initials="N." surname="Modadugu"/>
    <date month="April" year="2022"/>
    <abstract>
      <t>This document specifies version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
      <t>The DTLS 1.3 protocol is based on the Transport Layer Security (TLS) 1.3 protocol and provides equivalent security guarantees with the exception of order protection / non-replayability. Datagram semantics of the underlying transport are preserved by the DTLS protocol.</t>
      <t>This document obsoletes RFC 6347.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9147"/>
  <seriesInfo name="DOI" value="10.17487/RFC9147"/>
</reference>




    </references>

    <references title='Informative References' anchor="sec-informative-references">



<reference anchor="RFC9325">
  <front>
    <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
    <author fullname="Y. Sheffer" initials="Y." surname="Sheffer"/>
    <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"/>
    <author fullname="T. Fossati" initials="T." surname="Fossati"/>
    <date month="November" year="2022"/>
    <abstract>
      <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are used to protect data exchanged over a wide range of application protocols and can also form the basis for secure transport protocols. Over the years, the industry has witnessed several serious attacks on TLS and DTLS, including attacks on the most commonly used cipher suites and their modes of operation. This document provides the latest recommendations for ensuring the security of deployed services that use TLS and DTLS. These recommendations are applicable to the majority of use cases.</t>
      <t>RFC 7525, an earlier version of the TLS recommendations, was published when the industry was transitioning to TLS 1.2. Years later, this transition is largely complete, and TLS 1.3 is widely available. This document updates the guidance given the new environment and obsoletes RFC 7525. In addition, this document updates RFCs 5288 and 6066 in view of recent attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="195"/>
  <seriesInfo name="RFC" value="9325"/>
  <seriesInfo name="DOI" value="10.17487/RFC9325"/>
</reference>

<reference anchor="RFC7296">
  <front>
    <title>Internet Key Exchange Protocol Version 2 (IKEv2)</title>
    <author fullname="C. Kaufman" initials="C." surname="Kaufman"/>
    <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
    <author fullname="Y. Nir" initials="Y." surname="Nir"/>
    <author fullname="P. Eronen" initials="P." surname="Eronen"/>
    <author fullname="T. Kivinen" initials="T." surname="Kivinen"/>
    <date month="October" year="2014"/>
    <abstract>
      <t>This document describes version 2 of the Internet Key Exchange (IKE) protocol. IKE is a component of IPsec used for performing mutual authentication and establishing and maintaining Security Associations (SAs). This document obsoletes RFC 5996, and includes all of the errata for it. It advances IKEv2 to be an Internet Standard.</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="79"/>
  <seriesInfo name="RFC" value="7296"/>
  <seriesInfo name="DOI" value="10.17487/RFC7296"/>
</reference>

<reference anchor="RFC9261">
  <front>
    <title>Exported Authenticators in TLS</title>
    <author fullname="N. Sullivan" initials="N." surname="Sullivan"/>
    <date month="July" year="2022"/>
    <abstract>
      <t>This document describes a mechanism that builds on Transport Layer Security (TLS) or Datagram Transport Layer Security (DTLS) and enables peers to provide proof of ownership of an identity, such as an X.509 certificate. This proof can be exported by one peer, transmitted out of band to the other peer, and verified by the receiving peer.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9261"/>
  <seriesInfo name="DOI" value="10.17487/RFC9261"/>
</reference>

<reference anchor="RFC5246">
  <front>
    <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
    <author fullname="T. Dierks" initials="T." surname="Dierks"/>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <date month="August" year="2008"/>
    <abstract>
      <t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="5246"/>
  <seriesInfo name="DOI" value="10.17487/RFC5246"/>
</reference>

<reference anchor="RFC7624">
  <front>
    <title>Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="B. Schneier" initials="B." surname="Schneier"/>
    <author fullname="C. Jennings" initials="C." surname="Jennings"/>
    <author fullname="T. Hardie" initials="T." surname="Hardie"/>
    <author fullname="B. Trammell" initials="B." surname="Trammell"/>
    <author fullname="C. Huitema" initials="C." surname="Huitema"/>
    <author fullname="D. Borkmann" initials="D." surname="Borkmann"/>
    <date month="August" year="2015"/>
    <abstract>
      <t>Since the initial revelations of pervasive surveillance in 2013, several classes of attacks on Internet communications have been discovered. In this document, we develop a threat model that describes these attacks on Internet confidentiality. We assume an attacker that is interested in undetected, indiscriminate eavesdropping. The threat model is based on published, verified attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="7624"/>
  <seriesInfo name="DOI" value="10.17487/RFC7624"/>
</reference>


<reference anchor="ANSSI-DAT-NT-003" target="https://www.ssi.gouv.fr/uploads/2015/09/NT_IPsec_EN.pdf">
  <front>
    <title>Recommendations for securing networks with IPsec, Technical Report</title>
    <author >
      <organization>ANSSI</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="TLS-Ext-Registry" target="https://www.iana.org/assignments/tls-extensiontype-values">
  <front>
    <title>Transport Layer Security (TLS) Extensions</title>
    <author >
      <organization>IANA</organization>
    </author>
    <date year="2023" month="November"/>
  </front>
</reference>


    </references>


<?line 610?>

<section anchor="acknowledgments"><name>Acknowledgments</name>

<t>We would like to thank the members of the "TSVWG DTLS for SCTP
Requirements Design Team" for their discussion. The members, in
no particular order, are:</t>

<t><list style="symbols">
  <t>Marcelo Ricardo Leitner</t>
  <t>Zaheduzzaman Sarker</t>
  <t>Magnus Westerlund</t>
  <t>John Mattsson</t>
  <t>Claudio Porfiri</t>
  <t>Xin Long</t>
  <t>Michael Tuexen</t>
</list></t>

<t>Additionally, we would like to thank the chairs of the
Transport and Services Working Group (tsvwg) Gorry Fairhurst and
Marten Seemann as well as the responsible area director Martin Duke.</t>

<t>Finally, we would like to thank Martin Thomson, Ilari Liusvaara,
Benjamin Kaduk, Scott Fluhrer, Dennis Jackson, David Benjamin,
and Thom Wiggers for a review of an initial version of this
specification.</t>

</section>


  </back>

<!-- ##markdown-source:
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
l8StuZWvpPuAKsmrSRNSCgCGO/8LStnPFftjAAA=

-->

</rfc>

