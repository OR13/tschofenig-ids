<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.1 (Ruby 3.0.2) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>

<?rfc rfcedstyle="yes"?>
<?rfc tocindent="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-tschofenig-tls-extended-key-update-00" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="Extended Key Update for TLS">Extended Key Update for Transport Layer Security (TLS) 1.3</title>

    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>Siemens</organization>
      <address>
        <email>hannes.tschofenig@gmx.net</email>
      </address>
    </author>
    <author initials="M." surname="Tüxen" fullname="Michael Tüxen">
      <organization>Münster Univ. of Applied Sciences</organization>
      <address>
        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>
    <author initials="T." surname="Reddy" fullname="Tirumaleswar Reddy">
      <organization>Nokia</organization>
      <address>
        <email>kondtir@gmail.com</email>
      </address>
    </author>
    <author initials="S." surname="Fries" fullname="Steffen Fries">
      <organization>Siemens</organization>
      <address>
        <email>steffen.fries@siemens.com</email>
      </address>
    </author>

    <date year="2024" month="January" day="04"/>

    <area>Security</area>
    <workgroup>TLS</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<?line 70?>

<t>The Transport Layer Security (TLS) 1.3 specification offers a dedicated
message to update cryptographic keys during the lifetime of an ongoing session.
It allows the sender to perform an update of the key and initialization vector
and may trigger the recipient, via the request_update field, to transmit a
key update message in the reverse direction.</t>

<t>In environments where sessions are long-lived, such as industrial IoT or
telecommunication networks, this key update along is insufficient since
perfect forward secrecy is not offered via this mechanism. Earlier versions
of TLS allowed the two peers to perform renegotiation, which is a handshake
that establishes new cryptographic parameters for an existing session.
When a security vulnerability with the renegotiation mechanism was discovered,
RFC 5746 was standardized as a fix. Renegotiation has, however, been removed
from TLS 1.3.</t>

<t>This specification defines an extended key update message that supports
perfect forward secrecy using a Diffie-Hellman key exchange.</t>



    </abstract>



  </front>

  <middle>


<?line 90?>

<section anchor="introduction"><name>Introduction</name>

<t>The features of TLS and DTLS have changed over the years and while newer versions
optimized and enhanced features (often with the help of extensions) some functionality
was removed without replacement. The ability to update keys and initialization vectors
with forward secrecy has been added in TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/> using the
KeyUpdate message and it intended to (partially) replace renegotiation from earlier
TLS versions. The renegotiation feature, while complex, offered additional
functionality that is not supported with TLS 1.3 anymore, including the update
keys with a Diffie-Hellman exchange during the lifetime of a session. If a traffic secret (application_traffic_secret_N) has been compromised, an attacker can passively 
eavesdrop on all future data sent on the connection, including data
encrypted with application_traffic_secret_N+1, application_traffic_secret_N+2, etc.</t>

<t>While such a feature is less relevant in environments with shorter-lived sessions,
such as transactions on the web, there are uses of TLS and DTLS where long-lived
sessions are common. In those environments, such as industrial IoT and
telecommunication networks, availability is important and an interruption of the
communication due to periodic session resumptions is not an option. A full handshake 
with (EC)DHE gives protection against active attackers but prevents the use 
of long-lived sessions.</t>

<t>Some deployments have used IPsec in the past and have now decided to switch to TLS
or DTLS instead and the requirement for updates of cryptographic keys for an existing
session has become a requirement. For IPsec, NIST, BSI, and ANSSI recommends very frequent
re-run of Diffie-Hellman to provide forward secrecy and force attackers to perform a
dynamic key extraction <xref target="RFC7624"/>. ANSSI writes "It is recommended to force the periodic
renewal of the keys, e.g., every hour and every 100 GB of data, in order to limit the
impact of a key compromise." <xref target="ANSSI-DAT-NT-003"/>.</t>

<t>This specification defines a new, extended key update message supporting perfect
forward secrecy. It does so by utilizing a Diffie-Hellman exchange using one of the
groups negotiated during the initial exchange. The support for this extension is
signaled using the TLS flags extension mechanism. The frequent re-running of extended
key update forces an attacker to do dynamic key exfiltration.</t>

<t>This specification is applicable to both TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/> and
DTLS 1.3 <xref target="RFC9147"/>. Throughout the specification we do not distinguish between
these two protocols unless necessary for better understanding.</t>

</section>
<section anchor="terminology-and-requirements-language"><name>Terminology and Requirements Language</name>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

<t>To distinguish the key update procedure defined in <xref target="I-D.ietf-tls-rfc8446bis"/>
from the key update procedure specified in this document, we use the terms
"classic key update" and "extended key update", respectively.</t>

</section>
<section anchor="extensions"><name>Extensions</name>

<t>Client and servers use the TLS flags extension <xref target="I-D.ietf-tls-tlsflags"/>
to indicate support for the functionality defined in this document. We
call this the "extended_key_update" extension and the corresponding
flag is called "Extended_Key_Update" flag.</t>

<t>The "Extended_Key_Update" flag proposed by the client in the ClientHello
(CH) MUST be acknowledged in the EncryptedExtensions (EE), if the
server also supports the functionality defined in this document and
is configured to use it.</t>

<t>If the "Extended_Key_Update" flag is not set, servers
ignore any the functionality specified in this document and applications
that require perfect forward security will have to initiate a full handshake.</t>

</section>
<section anchor="extended-key-update"><name>Extended Key Update</name>

<section anchor="generic-considerations"><name>Generic Considerations</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate an update
of cryptographic keys. This key update process can be sent by either
peer after it has sent a Finished message.  Implementations that
receive a ExtendedKeyUpdate message prior to receiving a Finished
message MUST terminate the connection with an "unexpected_message"
alert.</t>

<t>The design of the ExtendedKeyUpdate message follows the design of
the classic KeyUpdate message. Both allow the update of keys in
one direction only. However, the ExtendedKeyUpdate message requires
a full-roundtrip due to the nature of the Diffie-Hellman exchange.</t>

<t>The KeyShare entry in the ExtendedKeyUpdate message MUST be the same
group mutually supported by the client and server during the initial
handshake. The peers MUST NOT send a KeyShare Entry in the ExtendedKeyUpdate
message that is not mutually supported by the client and server during 
the initial handshake. An implementation that receives any other value
MUST terminate the connection with an "illegal_parameter" alert.</t>

<t><xref target="fig-key-update"/> shows the interaction graphically.
First, support for the functionality in this specification
is negotiated in the ClientHello and the EncryptedExtensions
messages. Then, the ExtendedKeyUpdate message is sent to
update the application traffic secrets.</t>

<figure title="Extended Key Update Message Exchange." anchor="fig-key-update"><artwork><![CDATA[
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share
     | + signature_algorithms
     v + Extended_Key_Update       -------->
                                                  ServerHello  ^ Key
                                                  + key_share  | Exch
                                                               v
                                        {EncryptedExtensions   ^ Server
                                       + Extended_Key_Update}  | Params
                                         {CertificateRequest}  v
                                                {Certificate}  ^
                                          {CertificateVerify}  | Auth
                                                   {Finished}  v
                               <--------           
     ^ {Certificate}
Auth | {CertificateVerify}
     v {Finished}              -------->
       [Application Data]      <------->  [Application Data]
                                  ...
       [ExtendedKeyUpdate]     -------->
                               <--------  [ExtendedKeyUpdate]
                                  ...
       [ExtendedKeyUpdate]     <-------
                               -------->  [ExtendedKeyUpdate]
                                  ...
       [Application Data]      <------->  [Application Data]
]]></artwork></figure>

<t>The structure of the ExtendedKeyUpdate message is shown below.
The sender starts the key update process and the receiver responds
with its key share. The extended key update always consists of two
messages, one from the sender to the receiver and another one from
the receiver to the sender. Both messages use the same format but the
response message MUST NOT have the request_update set to update_requested(1).</t>

<t>The structures for KeyUpdateRequest and KeyShareEntry are defined in
<xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<figure><artwork><![CDATA[
enum {
    update_not_requested(0), update_requested(1), (255)
} KeyUpdateRequest;

struct {
    KeyUpdateRequest request_update;
    KeyShareEntry key_share;
} ExtendedKeyUpdate;
]]></artwork></figure>

<t>If the request_update field is set to "update_requested", then the
receiver MUST send an ExtendedKeyUpdate of its own with request_update set to
"update_not_requested" prior to sending its next Application Data
record.  This mechanism allows either side to force an update to the
entire connection, but causes an implementation which receives
multiple ExtendedKeyUpdate while it is silent to respond with a single
update.  Note that implementations may receive an arbitrary number of
messages between sending a ExtendedKeyUpdate with request_update set to
"update_requested" and receiving the peer's ExtendedKeyUpdate, because those
messages may already be in flight.  However, because send and receive
keys are derived from independent traffic secrets, retaining the
receive traffic secret does not threaten the forward secrecy of data
sent before the sender changed keys.</t>

<t>Note: Implementations may receive an arbitrary number of
messages between one peer sending a ExtendedKeyUpdate and this peer
receiving the peer's ExtendedKeyUpdate, because those
messages may already be in flight. This design aspect needs to be
taken into account when designing APIs that inform applications
using this extended key update procedure to guarantee perfect
forward security.</t>

<t>If implementations independently send their own ExtendedKeyUpdate
messages, and they cross in flight, the result is that each
side increments keys by two generations.</t>

<t>Both sender and receiver MUST encrypt their ExtendedKeyUpdate messages with
the old keys. Both sides MUST enforce that a ExtendedKeyUpdate messages
with the old key is received before accepting any messages encrypted
with the new key. Failure to do so may allow message truncation
attacks.</t>

<t>If a sending implementation receives a ExtendedKeyUpdate with
request_update set to "update_requested", it MUST NOT send its own
ExtendedKeyUpdate if that would cause it to exceed these limits.
This may result in an eventual need to terminate the connection
when the limits in Section 5.5 of <xref target="I-D.ietf-tls-rfc8446bis"/> are
reached.</t>

<t>The ExtendedKeyUpdate and the KeyUpdates MAY be used in combination,
depending on the desired security properties.</t>

<t>The updated Handshake structure is shown in <xref target="fig-handshake"/>.</t>

<figure title="Handshake Structure." anchor="fig-handshake"><artwork><![CDATA[
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
                          case extended_key_update:   ExtendedKeyUpdate;
          };
      } Handshake;
]]></artwork></figure>

</section>
<section anchor="dtls-13-specific-considerations"><name>DTLS 1.3-specific Considerations</name>

<t>DTLS 1.3 <xref target="RFC9147"/> requires the transmission of an ACK message to ensure
the reliable transmission of the KeyUpdate message. Since the design
of the ExtendedKeyUpdate message always requires a full roundtrip
there is no need for a dedicated ACK message.</t>

<t><xref target="fig-key-update-dtls"/> illustrates an example exchange of the
ExtendedKeyUpdate message used to update traffic secrets in
both directions in a DTLS 1.3 exchange.</t>

<figure title="DTLS 1.3 Extended Key Update Example." anchor="fig-key-update-dtls"><artwork><![CDATA[
   Client                                             Server

         /-------------------------------------------\
        |             Initial Handshake               |
         \-------------------------------------------/

    [Application Data]         ========>
    (epoch=3)

                               <========      [Application Data]
                                                       (epoch=3)

         /-------------------------------------------\
        |              Some time later ...            |
         \-------------------------------------------/

    [ExtendedKeyUpdate]
    (epoch 3)                  -------->


                               <========      [Application Data]
                                                       (epoch=3)

                                             [ExtendedKeyUpdate]
                               <--------               (epoch=3)

 /----------------------------\
|   Key Update (based on DH)   |
 \----------------------------/

    [Application Data]
    (epoch=4)                  ========>

                               <--------     [ExtendedKeyUpdate]
                                                       (epoch=3)

    [ExtendedKeyUpdate]        -------->
    (epoch=4)

                                /----------------------------\
                               |   Key Update (based on DH)   |
                                \----------------------------/

                               <========      [Application Data]
                                                       (epoch=4)
]]></artwork></figure>

<t>In order to facilitate epoch reconstruction in DTLS 1.3 (see
Section 4.2.2 of <xref target="RFC9147"/>), implementations MUST NOT send records
with the new keys or send a new ExtendedKeyUpdate messages until the
previous key update has been completed. This avoids having
too many epochs in active use.</t>

<t>Due to loss and/or reordering, DTLS 1.3 implementations may receive a
record with an older epoch than the current one (the requirements
above preclude receiving a newer record).  They SHOULD attempt to
process those records with that epoch (see Section 4.2.2 of <xref target="RFC9147"/>
for information on determining the correct epoch) but MAY opt to discard
such out-of-epoch records.</t>

<t>Due to the possibility of a response message of an initial ExtendedKeyUpdate
being lost and thereby preventing the sender of the ExtendedKeyUpdate from
updating its keying material, receivers MUST retain the pre-update keying material
until receipt and successful decryption of a message using the new
keys.</t>

</section>
</section>
<section anchor="key_update"><name>Updating Traffic Secrets</name>

<t>Once the handshake is complete, it is possible for either side to
update its sending traffic keys using the ExtendedKeyUpdate handshake
message. The next generation of traffic keys is
computed by generating client_/server_application_traffic_secret_N+1
from client_/server_application_traffic_secret_N as described in this
section and then re-deriving the traffic keys, as described in
Section 7.3 of <xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<t>There are three changes to the application_traffic_secret computation
described in <xref target="I-D.ietf-tls-rfc8446bis"/>, namely</t>

<t><list style="symbols">
  <t>The application_traffic_secret_N is not used as an secret as it
may be already exfiltrated by the attacker.</t>
  <t>the label is adjusted to distinguish it from the classic KeyUpdate
message, and</t>
  <t>the Diffie-Hellman derived shared secret, as 'dh-secret', is used
as input to the HKDF-Expand-Label() function to produce the value sk.
sk is subsequently included as a secret value in the computation of
the application_traffic_secret_N+1, making the next generation
traffic key of the application traffic secret dependent on the
DH-derived value.</t>
</list></t>

<t>The next-generation application_traffic_secret is computed as follows:</t>

<figure><artwork><![CDATA[
sk = HKDF-Extract(0, dh-secret)

application_traffic_secret_N+1 =
    Derive-Secret(sk,"traffic upd 2",
                  application_traffic_secret_N)
]]></artwork></figure>

<t>The next generation of traffic keys is computed using the HKDF, as
defined in <xref target="RFC5869"/>, and its two components, HKDF-Extract and
HKDF-Expand, as recommended in Appendix F.1.1 of
<xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<t>Once client_/server_application_traffic_secret_N+1 and its associated
traffic keys have been computed, implementations SHOULD delete
client_/server_application_traffic_secret_N and its associated
traffic keys.</t>

<t>If a hybrid key exchange, based on <xref target="I-D.ietf-tls-hybrid-design"/>, is used then
the two shared secrets concatenated together serve as input to
the HKDF-Extract function to produce the value sk.</t>

</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t><xref target="RFC9325"/> provides a good summary of what (perfect) forward secrecy
is and how it relates to the TLS protocol. In summary, it says:</t>

<t>"Forward secrecy (also called "perfect forward secrecy" or "PFS") is a
defense against an attacker who records encrypted conversations where
the session keys are only encrypted with the communicating parties'
long-term keys. Should the attacker be able to obtain these long-term
keys at some point later in time, the session keys and thus the entire
conversation could be decrypted."</t>

<t>Appendix F of <xref target="I-D.ietf-tls-rfc8446bis"/> goes into details of
explaining the security properties of the TLS 1.3 protocol and notes
"... forward secrecy without rerunning (EC)DHE does not stop an attacker
from doing static key exfiltration." It concludes with a recommendation
by saying: "Frequently rerunning (EC)DHE forces an attacker to do dynamic
key exfiltration (or content exfiltration)." (The term key exfiltration
is defined in <xref target="RFC7624"/>.)</t>

<t>This specification re-uses public key encryption to update application
traffic secrets in both direction. Unlike the classic Key Update message
defined in  <xref target="I-D.ietf-tls-rfc8446bis"/>, the key update procedure requires
two messages.</t>

</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t>IANA is requested to add the following entry to the "TLS Flags" extension
registry defined in <xref target="I-D.ietf-tls-tlsflags"/>:</t>

<t><list style="symbols">
  <t>Value: TBD1</t>
  <t>Flag Name: extended_key_update</t>
  <t>Messages: CH, EE</t>
  <t>Recommended: Y</t>
  <t>Reference: [This document]</t>
</list></t>

<t>IANA is requested to add the following entry to the
"TLS HandshakeType" <xref target="TLS-Ext-Registry"/> registry:</t>

<t><list style="symbols">
  <t>Value: TBD2</t>
  <t>Description: extended_key_update</t>
  <t>DTLS-OK: Y</t>
  <t>Reference: [This document]</t>
  <t>Comment:</t>
</list></t>

</section>


  </middle>

  <back>


    <references title='Normative References' anchor="sec-normative-references">



<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="S. Bradner" initials="S." surname="Bradner"/>
    <date month="March" year="1997"/>
    <abstract>
      <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>


<reference anchor="I-D.ietf-tls-rfc8446bis">
   <front>
      <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
      <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
         <organization>Windy Hill Systems, LLC</organization>
      </author>
      <date day="7" month="July" year="2023"/>
      <abstract>
	 <t>   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

   This document updates RFCs 5705, 6066, 7627, and 8422 and obsoletes
   RFCs 5077, 5246, 6961, and 8446.  This document also specifies new
   requirements for TLS 1.2 implementations.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-rfc8446bis-09"/>
   
</reference>


<reference anchor="I-D.ietf-tls-tlsflags">
   <front>
      <title>A Flags Extension for TLS 1.3</title>
      <author fullname="Yoav Nir" initials="Y." surname="Nir">
         <organization>Dell Technologies</organization>
      </author>
      <date day="23" month="July" year="2023"/>
      <abstract>
	 <t>   A number of extensions are proposed in the TLS working group that
   carry no interesting information except the 1-bit indication that a
   certain optional feature is supported.  Such extensions take 4 octets
   each.  This document defines a flags extension that can provide such
   indications at an average marginal cost of 1 bit each.  More
   precisely, it provides as many flag extensions as needed at 4 + the
   order of the last set bit divided by 8.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-tlsflags-12"/>
   
</reference>

<reference anchor="RFC9147">
  <front>
    <title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
    <author fullname="N. Modadugu" initials="N." surname="Modadugu"/>
    <date month="April" year="2022"/>
    <abstract>
      <t>This document specifies version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
      <t>The DTLS 1.3 protocol is based on the Transport Layer Security (TLS) 1.3 protocol and provides equivalent security guarantees with the exception of order protection / non-replayability. Datagram semantics of the underlying transport are preserved by the DTLS protocol.</t>
      <t>This document obsoletes RFC 6347.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9147"/>
  <seriesInfo name="DOI" value="10.17487/RFC9147"/>
</reference>

<reference anchor="RFC5869">
  <front>
    <title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
    <author fullname="H. Krawczyk" initials="H." surname="Krawczyk"/>
    <author fullname="P. Eronen" initials="P." surname="Eronen"/>
    <date month="May" year="2010"/>
    <abstract>
      <t>This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications. The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions. This document is not an Internet Standards Track specification; it is published for informational purposes.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="5869"/>
  <seriesInfo name="DOI" value="10.17487/RFC5869"/>
</reference>




    </references>

    <references title='Informative References' anchor="sec-informative-references">



<reference anchor="RFC9325">
  <front>
    <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
    <author fullname="Y. Sheffer" initials="Y." surname="Sheffer"/>
    <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"/>
    <author fullname="T. Fossati" initials="T." surname="Fossati"/>
    <date month="November" year="2022"/>
    <abstract>
      <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are used to protect data exchanged over a wide range of application protocols and can also form the basis for secure transport protocols. Over the years, the industry has witnessed several serious attacks on TLS and DTLS, including attacks on the most commonly used cipher suites and their modes of operation. This document provides the latest recommendations for ensuring the security of deployed services that use TLS and DTLS. These recommendations are applicable to the majority of use cases.</t>
      <t>RFC 7525, an earlier version of the TLS recommendations, was published when the industry was transitioning to TLS 1.2. Years later, this transition is largely complete, and TLS 1.3 is widely available. This document updates the guidance given the new environment and obsoletes RFC 7525. In addition, this document updates RFCs 5288 and 6066 in view of recent attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="195"/>
  <seriesInfo name="RFC" value="9325"/>
  <seriesInfo name="DOI" value="10.17487/RFC9325"/>
</reference>

<reference anchor="RFC7624">
  <front>
    <title>Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="B. Schneier" initials="B." surname="Schneier"/>
    <author fullname="C. Jennings" initials="C." surname="Jennings"/>
    <author fullname="T. Hardie" initials="T." surname="Hardie"/>
    <author fullname="B. Trammell" initials="B." surname="Trammell"/>
    <author fullname="C. Huitema" initials="C." surname="Huitema"/>
    <author fullname="D. Borkmann" initials="D." surname="Borkmann"/>
    <date month="August" year="2015"/>
    <abstract>
      <t>Since the initial revelations of pervasive surveillance in 2013, several classes of attacks on Internet communications have been discovered. In this document, we develop a threat model that describes these attacks on Internet confidentiality. We assume an attacker that is interested in undetected, indiscriminate eavesdropping. The threat model is based on published, verified attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="7624"/>
  <seriesInfo name="DOI" value="10.17487/RFC7624"/>
</reference>


<reference anchor="I-D.ietf-tls-hybrid-design">
   <front>
      <title>Hybrid key exchange in TLS 1.3</title>
      <author fullname="Douglas Stebila" initials="D." surname="Stebila">
         <organization>University of Waterloo</organization>
      </author>
      <author fullname="Scott Fluhrer" initials="S." surname="Fluhrer">
         <organization>Cisco Systems</organization>
      </author>
      <author fullname="Shay Gueron" initials="S." surname="Gueron">
         <organization>University of Haifa</organization>
      </author>
      <date day="7" month="September" year="2023"/>
      <abstract>
	 <t>   Hybrid key exchange refers to using multiple key exchange algorithms
   simultaneously and combining the result with the goal of providing
   security even if all but one of the component algorithms is broken.
   It is motivated by transition to post-quantum cryptography.  This
   document provides a construction for hybrid key exchange in the
   Transport Layer Security (TLS) protocol version 1.3.

   Discussion of this work is encouraged to happen on the TLS IETF
   mailing list tls@ietf.org or on the GitHub repository which contains
   the draft: https://github.com/dstebila/draft-ietf-tls-hybrid-design.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-hybrid-design-09"/>
   
</reference>


<reference anchor="ANSSI-DAT-NT-003" target="https://www.ssi.gouv.fr/uploads/2015/09/NT_IPsec_EN.pdf">
  <front>
    <title>Recommendations for securing networks with IPsec, Technical Report</title>
    <author >
      <organization>ANSSI</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="TLS-Ext-Registry" target="https://www.iana.org/assignments/tls-extensiontype-values">
  <front>
    <title>Transport Layer Security (TLS) Extensions</title>
    <author >
      <organization>IANA</organization>
    </author>
    <date year="2023" month="November"/>
  </front>
</reference>


    </references>


<?line 485?>

<section anchor="acknowledgments"><name>Acknowledgments</name>

<t>We would like to thank the members of the "TSVWG DTLS for SCTP
Requirements Design Team" for their discussion. The members, in
no particular order, are:</t>

<t><list style="symbols">
  <t>Marcelo Ricardo Leitner</t>
  <t>Zaheduzzaman Sarker</t>
  <t>Magnus Westerlund</t>
  <t>John Mattsson</t>
  <t>Claudio Porfiri</t>
  <t>Xin Long</t>
  <t>Michael Tüxen</t>
  <t>Hannes Tschofenig</t>
  <t>K Tirumaleswar Reddy</t>
  <t>Bertrand Rault</t>
</list></t>

<t>Additionally, we would like to thank the chairs of the
Transport and Services Working Group (tsvwg) Gorry Fairhurst and
Marten Seemann as well as the responsible area director Martin Duke.</t>

<t>Finally, we would like to thank Martin Thomson for his review of
this specification.</t>

</section>
<section anchor="alternative-designs-considered"><name>Alternative Designs Considered</name>

<t>The design presented in this document utilizes an ephemeral Diffie-Hellman,
which requires a full roundtrip since both parties need to exchange their
ephemeral public keys. Since the Key Update design defined in TLS 1.3
utilizes a one-shot message, this new extension changes the behavior and
is less efficient.</t>

<t>During the design of this specification two alternatives have been considered,
which retained the original design spirit of the one-shot Key Update message
by utilizing an ephemeral-static Diffie-Hellman. The static public key thereby
represents a previously exchanged Diffie-Hellman public key. For the first 
Key Update message sent, this public key would thereby be the Diffie-Hellman
public key from the key share in the initial ClientHello/ServerHello handshake
message exchange. We considered two designs, one using a classical ephemeral-static
Diffie-Hellman and a second design based on the Hybrid Public Key Encryption (HPKE)
specification. HPKE is already used in the encrypted ClientHello and may
therefore be present already in TLS stacks.</t>

<t>Ultimately, we decided against such an approach since it requires an implementation
to keep their Diffie-Hellman public and private keys somewhere in memory (even
though it is possible to utilize available hardware security modules to store
the private key). The design in this document allows an implementation to discard
this ephemeral Diffie-Hellman key pair immediately after the key update procedure
has been finalized.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAAAAAAAAA81cW3PbRpZ+ZxX/QxfzEClDUrZiJxN5MjWKJcfa2LLXouOd
nYuqSTRJjECAiwZEMx7nl83b/LH9zjndDYAEKdk7U7WoXCgA3X363G+NwWDQ
7RRxkZgTdf6+MGlkIvWTWau3y0gXRk2zXI1yndpllhfqhV6bXF2ZSZnHxVod
jF5cHaqHw6+7nW5Hj8e5ud0zy4urbifKJqleYK0o19NiUNjJPJuaNJ4NisQO
jBs6uDHrQclDBw8edDsT/Jhl+fpE2SKiteJlfqKKvLTF8YMH3z04xuq50ScB
sm5nleU3szwrlyeyMGbErehEXaSFyVNTDM4IAprMFjqNrnWSpYBrbWy3s4xP
uh2l8unERLZYJ/6+UkU2qf+OAW1ahDsWOMrN1FY31ovm30UeT6r3J9ligfHV
8zhN4rS2GhAySGJbDDDROEvw4iD76jf0CIhc6OUyTmfubV0W8ywnuAf0nK44
xYDnQzUKWPZPhAbPdZoa2/LYLHScnKg5Px9WRPrDbPF+CNz597Icq1/FBpuw
Wwu/xML//Md7kzYXfRlP5tokG8/cikVpcPMP0/lgUWJOUGoYmcZqL//5D76v
3qbx7VBlU3W6XCYx2O1qEpt0YrYBGQ3VGxNF6yYcozgvFzoxdqXz5nMHy02W
RkWcY8/4cwhSNeC4zG5irdTWYldD9SyPhXzVYleFmQKDzUduHSvPhlN69gcr
2NxaL2C520mzfKGL+NYwk7559vT44cPv+PfF4GwYm2LKwgTu/e2jR9+MY7v9
DP9OEz2zfobvHj761v9+/NtvaLY4nW6u893Xx4/972+/OX60Pe98Pc7jaBAZ
G89Sfnx6eXWFV05Hg8sRZPnrE7eril1VbZf8trvnlNIbI1ICZRBnqWVVYlnM
05kCL5KgW7WKi7m6eI0HfTUyk3kaT3SCsaS1/Hw6nxnI3rwolvbk6Gi1Wg2t
jYezrLwF8o/KZZLpyB4dP3j4+OjBd0eXo2ue8Pr8criMpm4W0kmAs5xB9yh6
le5Dwwyg9gZvzAzCCj21d5MXp5enzT3eoWBZo1ra/Z6txDrVQ8x/pC0hn/XK
UVCqNLpYL83gVidlYEHZzGV2axZjLHv84Jg1+WAwUHqMjegJK8jR3NzDBii7
NJN4CsQToSCZU5NbpRX0Od0zUNwLY62eGWhOJdpdTfL1sshmuV7O44mCkrYq
EtIWWDSJp6aIF4bEXGPKdJbRI4tpsMSw27kolE6SbGX5dUvGI6fZlyYn7qVB
biHMQK9gBdyMIKtxEesk/kWAvTWTIsuhRPFoodcwLfFsRlNhSI5dLaFair66
hcjLrf8BEotrN/c0NknUp3ULwtIiBlRscfzift9x6obfAjVGRTHmLmQn2Euq
THob55nQTq3mJjd+r0Ak/oCJmsEe3BqsZsvJXGmLOaOSzArY/SIbKdpFYRIW
mjL1xPByAiDnsVU10MjszVRM89hyCurRTpWNoUlhB4FGQEgyBy0ZkdwB4jW9
nmaFkBiaV9CCmwtInk5juxiqc51DK+eKdiqcCwqAVYReGESIAFAgFbFJjWa5
SWHsQR2CvA80wGDQiprsUWTn+gaQFXNdKJBAj2Ee5zBiqVltMNNS59C9Bc1O
OgOsYN5DOpsM9G4OraydQgE335ZJanI9jhP6i7WKUKwGU7VNtQIBothOIEFA
RL/bgWZUj7999A0/YccCeIt/wX417WAavydjVJ9srkGVOVCCKfpqbABPbhaY
EPIyzbMFIw3iNRRJBCKachaZaUxWnPfnPK8W1mOE2XJJImx3U7a0hB+tzmLw
ghk8N0mywMw0oXlPu56ZoVcRiziKEkN/faHIrcqzqGR29jpjanRR5oDNkx7S
dUY/5voWos+zRYpwx0heG00KAy+B5okhkjYZaAldILjEOybFePhn1SoH2RT7
r4g2N8mSlg4K0B7CQ4M2mZYpw6kTcRVBGodyHpyVBf5eJnpCJreAG4PJPEtU
qouV1U5dAngZkE0Eg9xCZB0RpaARHH3Vhw87zPfHj44s2FS3A6/6bZO0DEOB
qRz1AeIBmJ9gStaHfisbPMysZURIQS3A4BEt+914W3Dcd5SBclkm5n0/aABs
JhaMgmnr2BW+c/rCsZ9Dc9i4TteLjCaH0knKyCt/QTPrUWfft9jSs+ROmxEk
XV3QX1DPpOKEGIU60OQ6ihxdu2fX8uz68rAiFW0X6Iot6V0sq4tCT27AmxP8
sSR7e2uSNXxBA762UZ6B7VJSdOA0QhvZWQIFijUTCzDJ4FlPRMFVu6bXMEnK
esxjaR+Mv3nY3//8uK9MMWGJfceUE6vh6UmEgQdM7J+YW50SE20YIQLBzolq
uVieYJGg7bwNYrOnJ+KguS2uzJisDdkwMl2lbdEDYuIqq4YZ6+aObBjTjmbM
YDDroO20gJh9vwnUt/C7vTyT5VsQV9LuCTCQlCQpz8ul82NE7pqzRaVxNivO
IuYohhuItOViKYhwXE+OC98ZqlMwBLgi2DHllMTB+dPDs+fnagYkWAVeK4Q5
lJ5p2GXMMSE/PDAe+BI6akl+BBGJpcXSbAC2wmagFNP/ijRfBF2QrYW0rIQx
LBK/2Tsn4GdBBD9PsxUGTWKnVyzABdLxi4NqmFWmI8FotOhl7x/Bt6F12PaK
KDP9Wxy+DescmMAJ4IQA1/U5EWJhiPP2Ly+uRn31w9VFn5fnCIJ8NgkaLKm1
NbQdeWwpvNncDPKSqbqhS4iaeXaLnW7pbJoX9yZ1AtSdzG4nWiPOk/2QuclF
FqDSXaT08ePQQbaCmwFM9C5YKwY4Bb2yCFPBMRYBDDsI1q4cWLCwGc6G+C/v
DfYqF4vIfz588ED9+AO9TuqE1At8QucWJzH5pszOYHoAKUqSoK503LAHuDfD
NmzgLv+D7HV/rw/i9D+pOud/wFo0cQ1hL1SUYT6bqTFmKCCmv7T6JEH5i3HM
UhNklRM/5BOKBQM0NQPhzHXlz7C9c7AxM7IvG7wG0AksiZBKJ5goWGLWZBxE
116tOcDsADm2U8J1KcM5DThqxAhMe9swL6BYhH8avDWNE7BXCBpaCEKustiE
ccJKapzVjO0+L4M151n1pksMEPOO5kDpjF0jjrQaK64MwUm6LhIRLuGTQ3KL
laEMDwZY5+tDs2WTLLGqTNnuwAgSb5CEAu8YQZmdkqI49p0x1VD8y5HJF3Ga
JdlMxPFNpQ0sIlIsCQbzfidhipJ9ELOXb69Gvb78X12+4t9vzv/z7cWb8zP6
ffX89MWL8EPe6Hbw16u3L9wL9Ksa+vTVy5fnl2cy+uXpH3uidnqvXo8uXl2e
vuiJHiWeibJJySqQbBnRwYhlgd4uJCCIjJ3k8Vj8QAodKJMjiKdfXuiyBl59
GOv4BjiFF8xeBksiz7WHyi6q2DmLI63Mw5Lg99EnQpOd4dANBMEee5OE/J9J
ba6eIKRFEQBXsI9Lw8YsWTvS1rMb3c7ThANQmsKanHzSsGSbwG1s1Oe1aJvA
ODwDTj1sSPdGBFBHXGPDQ/WODD85cnyfRoZ9XWNf137HFUDeBE6ynPaaMRMD
54CKJJMmw0o9nyS/hjt//dbNQi8NPRPvfoWItczIcI/XspbgzBlwwSBpyazb
OXj6/FAx84P7oFVgz7H+zG/WqHPvbVZkgDtyfgjD4ZSpkAHuLDSyDyA/AYmi
VWjrWTqNZ2Uupo6IGheS+BDLtmfDPn4w4EHHFZhylmbkXKbrFmh2c7E4eZXT
bF0ywfkXqiUyltTAKmbX7ZZlWYwI5U82XLo6UzeLIPzgC/Uj7HkOgXmKpeFs
5B4IobofV0V5lbMYskhW3LY6g4dEF/uA204WafBm4ocl3lqOYcZGohPwk4nJ
Z6cEAdF8SvoYLgN5YvyGVs+wdTvH8g6cIWJ/igYJty5FS/gkx2Vi2Glt2ZTf
yhJeDts5eVnsvF+hyhcyAxdsAmh0M4JyYVKqemVq3pN2AQu5kb1uB1Y7L4JU
SWbaO1O7AZtmVVoxjGFTprzG2xo0VD+QpeUEVy2CpcXYz41hC8lLCWk/+CzQ
guq5T/7sB8kxKJV6mOcGsMhphLhn6aMRGp9KYOc2uMNlCujAKldzMk8gHoyw
1wk7YfCahH0AvfCullogzqVsQy3Eb+qmSp+3uGLdTiU+7DdJTtDbbM7rgi8C
sOd7ga2lmWu5h8+AUMjt3cUaiKcpxYw1lldOgzDDW1ZJGYmR4mx7t3NP/oWC
MTOdXIfMJUxp4N4PH6A9a4VR+GuIyx2Lsl/hgg4n9rRZDHwWw5Xq32EAvY5s
uHWstGsu9LZ5CcauxYgEKkg+Kb2Lu2OnYAoYLSc3NKCmqDeyNxLV/vrrr6G6
4lyH+19XTG6ahrS0+mvTdJ5DWNTf1W9IeK8tMZ5bie5xPECSdq2TWQb7MF/4
osotHreYMrfmwF2/r4pCnwqw4B7gYvLPmaW2I9oM7fNzpmlct/ef4UOby0Hb
8eS45zytWP5IO3pN8mM/YU8fnkLKhPHNG6ntfPykPbVNhBn++ikz1Mf+DBdh
uubNnJbF55Hng7ej99rK7zxj1u65QX9tbqvbIZAAWQvAQQTqi9evbfb/02lN
xM90of/SBOj3ba/cByHD4bBaZEvx/GUHOPfAT8tk/yp4/Cp3zjeoYedfAM7n
0YCV74cT9UXTMklV+/teiw+sXjp1f+49kd5H74vYIi8ndedlv7GA7SPHFb7W
0I2X6q8ttA9QWrzdKkPJtjpXLkjz5Zq4ECeZtaM4I20ZLZ2s9JpDGovInBOb
xSqrbF6f01Eh0K4K0421Jd0snoJ/X5yO8IobIhM4B9MvEgJj8sSUdGtwYpjD
NtmY3fDdyJ2SGGa7jI3wqipvXbuHJjp4eDjcopFkbQNlnNLkHXk3Tbw03UhM
kBuzMzNRGXSTlgv1QdjTgQM01UB6gPi0Bc6+Ojh+/Piw2/m4BdoT6fQi8P3M
W9A38fEkvFXbTrCcT2iRLQ594jYQgtq2TgHxdRjXvc1N9NhPSj0JHRcw6cQL
TlvEAtxHfEsCwUzcStdup9eGyl4Vg9EC5PfSXIikCrUp8gxRlkcI+UaNcr9v
wpDgUVFcW6Wzqx4MYWYibxHnzSIYse1Ec5FIb3nX0gLg3WtIWZkUMd5oQYXU
J2N2+y1+skfphdxXESmFS4VrAQu7ucwKHy1shLLUDBIC2RTcPI7hhoIRwKHU
MkNBYZBHl/EMiGyLfO9DoBpxSKCq2LhwsdGXdntm6h1gDEqtrAYW7UEnudHR
WnKQaprEs3mBjT+v+g5krGMyv6gvv4oU51xVYq1GjY9Lw92Pm345JfkKHaeh
Yu3xt1F95Sw/hWbFHLAVwvRbtRdXx6A0FCUozJRyPjWd6rsIOMlBgke0PNlK
SXwWHUkncx5kH0HFooDd6E2/2X8HsVjkXC5CcxYVUmoiK6ll2A3Eply7RFw2
mWQl0LUiVSJDCKLT1xfWsXkqlatGGsyXNnzxY8PmVSlirDAr4WMj6DStlRxO
mPnc3qZI1ViHwnEjFjnOWX/tjuZt3xvvtZrkmbUVbvpO1VroBRW7LRpNYQ2r
ohgBhysVMDdT4L/CHigTJ0AxrGxcHVvVRMCpX1eWd7Du9E2kZC5WPEscX4rd
Jlisn8yX+nSxL0Hm3ZLabK5saFgWnTyA3mbJdTVKPQRIQidBbRbqk8IsQ/VM
x4kjZpRRtU04j3JXIX+Sl6nPBUhRynqi6spaNHV1lQTZofxIRNrcjjZTCD3e
TAI5M0fB+ebcnK4GNldZCUSJcMU8s3k/MdJwZo2UQO3QVc5ELQjfpFyEpop6
qRMWLTZYO7I2QKmz025KmuDKZXQeDx+T4tpba8tZM4JJTTTcnf31/mq4AwY6
/SNpBk4Bx9ycMiYAyYx2OyJaUg8Nycvc1NLYVDyguM3YsKxgPqJ+cJdqrnzx
4GpzVYkc/ZAIq3tsEi80/Su5wqSj9RJ8bWfX1If6hB4dfVXLbtNd9dVRfWgJ
ZXb8SMGKz4r5k0b0gqHjNWEjTgO7Ngdb6gAp1EFYf+jXPmwCSNdEW58IvJ5T
euWkelZLCj1pHSdZw61xtWRN+zgQ6jqbXlMT1vqajJwMPk+jV1Nqn1yTz7Vr
qJPs66q57US15eHax0+qyN0LHC2+nQa5c3htw/Xhdy97yxmDk41xkkdoHz11
KYWT5jOfaWgfBH137fpJrot4cmN4o+rSrK7k7ohvtg+uSnyNNevuvtp5CaG2
q4U0VVvgUI38GP76WInPk414uyY5Em5X0nvlpddF1198oXxVf+BTvC31p7bK
f6g6SNFX2pulO0d6sk+f/qRqbd3gujI3PohNYulB2BjWUGhV9eSKmo5rFRcu
Ze1PBLg4PADpqnGhMsKAiBZLM9Hp3G1UNaXXN9CaZx9E0N1ARJwk1GXGKphL
KZoMX9WF4ntPdgPri3Y+Gmq6zRwdc6tGqA+xdtOBds3yjVe7n5z1rue9w62j
wf2vP1fj/t6Y98KVSipObF5/ry34509Y8MiDuitPhet7d7lM3oFZZpP5918f
NnbZfv3Oj5U/Py/b2Hq1Q/EvwbXifj5udE00VWmHw2H98f8d17vSirIp9fXh
9n79JL+nSf7f4f0+1+ckU9tS59tQ7KU6yEzkrSVKD8aa1AWh4jlhmui5l457
hKQhEo9a6FYTnk/c7Wcmn1uvLartypKrrcR92Nt9CH4XJe4Yfg9C3XHdj457
rn+75BAid2T32R56nyOYprZc/7mYSOeEXNT6UKd6Qt3X9JIoE8orphI9cAtj
Whm9A2tgVX1k9Wh4PDyW2Cr4KNSrtJFjaEaNkrW021EwgsncdxfQrT1RfZkW
cSIWnvqu46xsdNM0zgok1N/nEjb6NosjbrbmPrAio0AbQTrvWwy89HbDO2C7
fia9HEkm1YqjjGoUjDlM0K/wsjdT6TO1obcgSwj1gmyEye4UQpnncigBbLzR
t01tJuPsltI+hs4nmEaLjhzNkTUOOR0MVLhWSV0UZrGUjKYvu0j7vqODP6FD
SRoGiEis9lGYk0sqnEjlzhm4cBKb+1wbd9xN3JyHnFGmUDljUPiUls4jd2Yh
K4tBNh1UzAew6tjn3B0oELtTAtwmvVVREQ/YN4i0pK7GhoADKQsfyOdmvPaN
+x5wl3La6exKWYgZzafnwXn0c0GWH2v3Q67Ksb5kYGUbufF1uY1RmJOZmscu
XQdMOSGCwYumtn8KJr2rX3NjPeDgAskPu6a3tx7EkXNtr5xr++GLKvxhZfDK
e/pVFMMdgiI7fZfAFwok8vmAZm0hNIkQNnwqynvULNkVmHt66kJ2UUp9XPWo
0oJMkvqc1NVLQJaufci/ioVc8uDIJQP2n9pxPbifMGarW1hajK0/JyLcRem3
Aefp/d7r4Pc3J6nU6rdQKPsTVj5Z5I7zUM7eH+GzXmJ2b0AJ1lwusbGRPWv2
+fR8suYDh3IKbx+KXKcXh1magzS3OJ0RKkBqzSl1n10PvfRVK5jvvB/Sepza
02OTcEd99LeSkpJOlYRmbDBqqPJuNQYG7upLE+ygrSfPl1W4qujqHgWT6sto
PpA/v+z7pk9oZTIay7LwSH/+09mzwfn7JVYYvCBwDw5Dd5c71BKVTtq4HU3Z
G+zP3nBqrxxbOaKQrN1BNH9U1eFOhsT+2FqgYmiHvOt82kLfVPqiIV4YX3Gn
V3+7G75UVXHKXIH07PnAo4/hDBlNWmlQE+Q9nOn0Tula8l3j50kIsYGo7z2S
+WDPwYO+CpRhh3M/CtT34o2dMaQD0YkH9qbf8/uDKlPHdO5g2x/be0IxFJvv
p7uqfVa6kTZGzEZCWTs94D4DQSKoXdqdKiY0AZwFPn1XR4mwd40TmX/rh5sw
K5xU0tPv1bPhw+FD5p+79A2biU/SrAFciGI24cbFBpu5Y2/BVSN0bLuPzpOJ
DFkjqPxP0dN3rF8VUORbGY2j1X0VgokN1DQ+rEFkCU3gc3fEhgnUUCLcn0JJ
rlSL5poZMaG0DVXTIzK+QdB7aBA+9h0+A7GdThT/7evjxx8/+pN1pFdmWUZu
xmJB1Vcw6Yr8wANXRTzcrP9yEyqfRsxWpGxzk3AGzik/cob9oSI+J+omZg/C
6rXIce/ZRlH5gA8z+LMYO87C9yg46L1+dtU7ZAvAImLI/wunMmtntVbzLPi3
1QleEICcMsdWfNxVkO2POIbqOrWCq42jv07l+mOndGxOc+Xmy26Hj3mSA+wq
jFdzrnvVrRgbO3cGLBt7h9C6A7c01lf3CzkXv8xiKFdJJ9HL8cL01Ta07GuU
khGWVg7yiqqNAmYCZWy8C4lgqEd0qDTAXdWxWcalHTK25MkmltWFeb9MqsaC
tpKWtyI+SPK8wUDDOaCCao8yZZttBtW5f39Oz5/JDW0KtsiWdZI7Jy6ST5KQ
6mg5o9ej84wkhmRZwzH2vPFNG8QJa2JW/pZT71keDPI2MHcdEpQThXUI1AG4
GAAUZDfrDw4B28HIneTaApzlbtMkuJOshzsOHlKgQQ08y3KceFykIYaoEt81
/VnpxioLrppJ8KF6mybxjdl0sVQzQm8YsP1OZVtrIPc1VCcsSJeG/nVRdfTV
nhYtx7djq0LZmjaqo8g1s5AzQQSU8xVOa/WIPZ/RObXayTEK2eXrQXsO8lXn
21ixfaXUz6SQT9Toh7OH7g5NrC75s1Mt1Sf3kuvDtCfq6fO+Oj93t99UJvtE
/THcpI88wBSfqD+N6kep/vKZCIAMEgYalWE6dLz5GSUuP4UvKhEs1W6P5cYZ
hxLMYXu2S0mTwauf7rulr0Bn/jDbieSxKdk5hrQJI5yGU3QuT9LtvDOu7UAY
NeMUyw1jYMGfVgqKqTe6+vndj5LFoaj26unodbfTOM16Ji0+I6MXPX9eI845
gVG6j1mMqon7HMelmZiGSZnoXPJsfTIrJxI6vdRQG0mm3sSUA8nUCwTTKWmw
gfpvPQfz//KLpljkSuc3cvulnqVQ8e+IonlSSvTyH9k8xZOigG+T0o2niS6j
OFOvs3wa5zHd+i8w7YuMUl2DrU+9Ddq+ODdQP7V+i22gfoBOz/mwry4T/hDV
afjMSLLm06i7sI5144B0KKvw8SqajspfManRd1nOscmPfIbpoLC3q9mh+jHL
wanPMMG8zK3zbYFB6lC7MgZ4ov4rrJ4k/O0LaT2izBDnKuhDhE57gXY0jrKZ
pTsZ+CzeD7x7fzTPFpa+u4Ip5ixct7FZuZhrU/E6BXWa0IcN+YNtjods0Fcm
2jgAtwTI4La285Fy5N5VOZdzcGWuk42otU/tL9KUuaPyKp+QEl3uvJbQUxNq
pszZsOthlcp02Ho9uKbuHfw1FelsfbdTAU4ZzYGd07EvH4DzHinHWx3VDdmL
OQUElKHlD1HIaVU+nm78B7FcbjAcXKsfI9yyg2Q8dEWMZsjh6VHDIHlm7oNY
WR7PiEP8AnYJsSq88gi7ajN/zY8l1Eg3cL5Jk4LuqwfyqGaxXY6SrJHjEcKn
T3knVawSbSYyqknk+xys/+n0mZLzVRvVcMsnyqVzslp+5b1YTpS6k4bNhbqd
2vuNs+xypMnlKnxatta+c1Q/P7WdA6x9EeKdqZGKCSoEcY39/itZzh2hj0ls
YBvc0sQO9/qTl0N9yI66Idjj8EvCwdeyN0LYeeU8HTx//dM5/K6m3Cu6y7GJ
S2n5njDxzH0ssXlib6HXri+CmwfHxmuDMI+TKlu1/L1NEA2AfE51+U/C+EhI
PsXDeZY805O5k/64qCmIzbZuPqF/Y8zSGbh2diKAl3l8q/0XtyhSke8GcevX
IoOyPqB8Ou2JvlGxmTwmx1M0g//yT0IZ4Dxa6bwWRCwQ5CYSWcLT93FabelD
ERlHu+1j5dICv929Xi8+SHPtDqXKPLyE3cEMCxPFjG53BnuXz0pHZ13laUqK
gz6PxgT7Xz4ySqvYVwAA

-->

</rfc>

