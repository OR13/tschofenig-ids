<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc version 1.7.1 (Ruby 3.0.2) -->


<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">

]>

<?rfc rfcedstyle="yes"?>
<?rfc tocindent="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-tschofenig-tls-extended-key-update-00" category="std" consensus="true" tocInclude="true" sortRefs="true" symRefs="true">
  <front>
    <title abbrev="Extended Key Update for TLS">Extended Key Update for Transport Layer Security (TLS) 1.3</title>

    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization></organization>
      <address>
        <email>hannes.tschofenig@gmx.net</email>
      </address>
    </author>
    <author initials="M." surname="Tuexen" fullname="Michael Tuexen">
      <organization>Muenster Univ. of Applied Sciences</organization>
      <address>
        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>
    <author initials="T." surname="Reddy" fullname="Tirumaleswar Reddy">
      <organization>Nokia</organization>
      <address>
        <email>kondtir@gmail.com</email>
      </address>
    </author>

    <date year="2023" month="December" day="26"/>

    <area>Security</area>
    <workgroup>TLS</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<?line 65?>

<t>The Transport Layer Security (TLS) 1.3 specification offers a dedicated
message to update cryptographic keys during the lifetime of an ongoing session.
It allows the sender to perform an update of the key and initialization vector
and may trigger the recipient, via the request_update field, to transmit a
key update message in the reverse direction.</t>

<t>In environments where sessions are long-lived, such as industrial IoT or
telecommunication networks, this key update along is insufficient since
perfect forward secrecy is not offered via this mechanism. Earlier versions
of TLS allowed the two peers to perform renegotiation, which is a handshake
that establishes new cryptographic parameters for an existing session.
When a security vulnerability with the renegotiation mechanism was discovered,
RFC 5746 was standardized as a fix. Renegotiation has, however, been removed
from TLS 1.3.</t>

<t>This specification defines an extended key update message that supports
perfect forward secrecy using a Diffie-Hellman key exchange.</t>



    </abstract>



  </front>

  <middle>


<?line 85?>

<section anchor="introduction"><name>Introduction</name>

<t>The features of TLS and DTLS have changed over the years and while newer versions
optimized and enhanced features (often with the help of extensions) some functionality
was removed without replacement. The ability to update keys and initialization vectors
with forward secrecy has been added in TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/> using the
KeyUpdate message and it intended to (partially) replace renegotiation from earlier
TLS versions. The renegotiation feature, while complex, offered additional
functionality that is not supported with TLS 1.3 anymore, including the update
keys with a Diffie-Hellman exchange during the lifetime of a session. If a traffic secret (application_traffic_secret_N) has been compromised, an attacker can passively 
eavesdrop on all future data sent on the connection, including data
encrypted with application_traffic_secret_N+1, application_traffic_secret_N+2, etc.</t>

<t>While such a feature is less relevant in environments with shorter-lived sessions,
such as transactions on the web, there are uses of TLS and DTLS where long-lived
sessions are common. In those environments, such as industrial IoT and
telecommunication networks, availability is important and an interruption of the
communication due to periodic session resumptions is not an option. A full handshake 
with (EC)DHE gives protection against active attackers but prevents the use 
of long-lived sessions.</t>

<t>Some deployments have used IPsec in the past and have now decided to switch to TLS
or DTLS instead and the requirement for updates of cryptographic keys for an existing
session has become a requirement. For IPsec, NIST, BSI, and ANSSI recommends very frequent
re-run of Diffie-Hellman to provide forward secrecy and force attackers to perform a
dynamic key extraction <xref target="RFC7624"/>. ANSSI writes "It is recommended to force the periodic
renewal of the keys, e.g., every hour and every 100 GB of data, in order to limit the
impact of a key compromise." <xref target="ANSSI-DAT-NT-003"/>.</t>

<t>This specification defines a new, extended key update message supporting perfect
forward secrecy. It does so by utilizing a Diffie-Hellman exchange using one of the
groups negotiated during the initial exchange. The support for this extension is
signaled using the TLS flags extension mechanism. The frequent re-running of extended
key update forces an attacker to do dynamic key exfiltration.</t>

<t>This specification is applicable to both TLS 1.3 <xref target="I-D.ietf-tls-rfc8446bis"/> and
DTLS 1.3 <xref target="RFC9147"/>. Throughout the specification we do not distinguish between
these two protocols unless necessary for better understanding.</t>

</section>
<section anchor="terminology-and-requirements-language"><name>Terminology and Requirements Language</name>

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

<t>To distinguish the key update procedure defined in <xref target="I-D.ietf-tls-rfc8446bis"/>
from the key update procedure specified in this document, we use the terms
"classic key update" and "extended key update", respectively.</t>

</section>
<section anchor="extensions"><name>Extensions</name>

<t>Client and servers use the TLS flags extension <xref target="I-D.ietf-tls-tlsflags"/>
to indicate support for the functionality defined in this document. We
call this the "extended_key_update" extension and the corresponding
flag is called "Extended_Key_Update" flag.</t>

<t>The "Extended_Key_Update" flag proposed by the client in the ClientHello
(CH) MUST be acknowledged in the EncryptedExtensions (EE), if the
server also supports the functionality defined in this document and
is configured to use it.</t>

<t>If the "Extended_Key_Update" flag is not set, servers
ignore any the functionality specified in this document and applications
that require perfect forward security will have to initiate a full handshake.</t>

</section>
<section anchor="extended-key-update"><name>Extended Key Update</name>

<section anchor="generic-considerations"><name>Generic Considerations</name>

<t>The ExtendedKeyUpdate handshake message is used to indicate an update
of cryptographic keys. This key update process can be sent by either
peer after it has sent a Finished message.  Implementations that
receive a ExtendedKeyUpdate message prior to receiving a Finished
message MUST terminate the connection with an "unexpected_message"
alert.</t>

<t>The design of the ExtendedKeyUpdate message follows the design of
the classic KeyUpdate message. Both allow the update of keys in
one direction only. However, the ExtendedKeyUpdate message requires
a full-roundtrip due to the nature of the Diffie-Hellman exchange.</t>

<t>The KeyShare entry in the ExtendedKeyUpdate message MUST be the same</t>

<t>group mutually supported by the client and server during the initial
handshake. The peers MUST NOT send a KeyShare Entry in the ExtendedKeyUpdate
message that is not mutually supported by the client and server during 
the initial handshake. An implementation that receives any other value
MUST terminate the connection with an "illegal_parameter" alert.</t>

<t><xref target="fig-key-update"/> showns the interaction graphically.
First, support for the functionality in this specification
is negotiated in the ClientHello and the EncryptedExtensions
messages. Then, the ExtendedKeyUpdate message is sent to
update the application traffic secrets.</t>

<figure title="Extended Key Update Message Exchange." anchor="fig-key-update"><artwork><![CDATA[
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share
     | + signature_algorithms
     v + Extended_Key_Update       -------->
                                                  ServerHello  ^ Key
                                                  + key_share  | Exch
                                                               v
                                        {EncryptedExtensions   ^ Server
                                       + Extended_Key_Update}  | Params
                                         {CertificateRequest}  v
                                                {Certificate}  ^
                                          {CertificateVerify}  | Auth
                                                   {Finished}  v
                               <--------           
     ^ {Certificate}
Auth | {CertificateVerify}
     v {Finished}              -------->
       [Application Data]      <------->  [Application Data]
                                  ...
       [ExtendedKeyUpdate]     -------->
                               <--------  [ExtendedKeyUpdate]
                                  ...
       [ExtendedKeyUpdate]     <-------
                               -------->  [ExtendedKeyUpdate]
                                  ...
       [Application Data]      <------->  [Application Data]
]]></artwork></figure>

<t>The structure of the ExtendedKeyUpdate message is shown below.
The sender starts the key update process and the receiver responds
with its key share. The extended key update always consists of two
messages, one from the sender to the receiver and another one from
the receiver to the sender. Both messages use the same format but the
response message MUST NOT have the request_update set to update_requested(1).</t>

<t>The structures for KeyUpdateRequest and KeyShareEntry are defined in
<xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<figure><artwork><![CDATA[
enum {
    update_not_requested(0), update_requested(1), (255)
} KeyUpdateRequest;

struct {
    KeyUpdateRequest request_update;
    KeyShareEntry key_share;
} ExtendedKeyUpdate;
]]></artwork></figure>

<t>If the request_update field is set to "update_requested", then the
receiver MUST send an ExtendedKeyUpdate of its own with request_update set to
"update_not_requested" prior to sending its next Application Data
record.  This mechanism allows either side to force an update to the
entire connection, but causes an implementation which receives
multiple ExtendedKeyUpdate while it is silent to respond with a single
update.  Note that implementations may receive an arbitrary number of
messages between sending a ExtendedKeyUpdate with request_update set to
"update_requested" and receiving the peer's ExtendedKeyUpdate, because those
messages may already be in flight.  However, because send and receive
keys are derived from independent traffic secrets, retaining the
receive traffic secret does not threaten the forward secrecy of data
sent before the sender changed keys.</t>

<t>Note: Implementations may receive an arbitrary number of
messages between one peer sending a ExtendedKeyUpdate and this peer
receiving the peer's ExtendedKeyUpdate, because those
messages may already be in flight. This design aspect needs to be
taken into account when designing APIs that inform applications
using this extended key update procedure to guarantee perfect
forward security.</t>

<t>If implementations independently send their own ExtendedKeyUpdate
messages, and they cross in flight, the result is that each
side increments keys by two generations.</t>

<t>Both sender and receiver MUST encrypt their ExtendedKeyUpdate messages with
the old keys. Both sides MUST enforce that a ExtendedKeyUpdate messages
with the old key is received before accepting any messages encrypted
with the new key. Failure to do so may allow message truncation
attacks.</t>

<t>If a sending implementation receives a ExtendedKeyUpdate with
request_update set to "update_requested", it MUST NOT send its own
ExtendedKeyUpdate if that would cause it to exceed these limits.
This may result in an eventual need to terminate the connection
when the limits in Section 5.5 of <xref target="I-D.ietf-tls-rfc8446bis"/> are
reached.</t>

<t>The ExtendedKeyUpdate and the KeyUpdates MAY be used in combination,
depending on the desired security properties.</t>

<t>The updated Handshake structure is shown in <xref target="fig-handshake"/>.</t>

<figure title="Handshake Structure." anchor="fig-handshake"><artwork><![CDATA[
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
                          case extended_key_update:   ExtendedKeyUpdate;
          };
      } Handshake;
]]></artwork></figure>

</section>
<section anchor="dtls-13-specific-considerations"><name>DTLS 1.3-specific Considerations</name>

<t>DTLS 1.3 <xref target="RFC9147"/> requires the transmission of an ACK message to ensure
the reliable transmission of the KeyUpdate message. Since the design
of the ExtendedKeyUpdate message always requires a full roundtrip
there is no need for a dedicated ACK message.</t>

<t><xref target="fig-key-update-dtls"/> illustrates an example exchange of the
ExtendedKeyUpdate message used to update traffic secrets in
both directions in a DTLS 1.3 exchange.</t>

<figure title="DTLS 1.3 Extended Key Update Example." anchor="fig-key-update-dtls"><artwork><![CDATA[
   Client                                             Server

         /-------------------------------------------\
        |             Initial Handshake               |
         \-------------------------------------------/

    [Application Data]         ========>
    (epoch=3)

                               <========      [Application Data]
                                                       (epoch=3)

         /-------------------------------------------\
        |              Some time later ...            |
         \-------------------------------------------/

    [ExtendedKeyUpdate]
    (epoch 3)                  -------->


                               <========      [Application Data]
                                                       (epoch=3)

                                             [ExtendedKeyUpdate]
                               <--------               (epoch=3)

 /----------------------------\
|   Key Update (based on DH)   |
 \----------------------------/

    [Application Data]
    (epoch=4)                  ========>

                               <--------     [ExtendedKeyUpdate]
                                                       (epoch=3)

    [ExtendedKeyUpdate]        -------->
    (epoch=4)

                                /----------------------------\
                               |   Key Update (based on DH)   |
                                \----------------------------/

                               <========      [Application Data]
                                                       (epoch=4)
]]></artwork></figure>

<t>In order to facilitate epoch reconstruction in DTLS 1.3 (see
Section 4.2.2 of <xref target="RFC9147"/>), implementations MUST NOT send records
with the new keys or send a new ExtendedKeyUpdate messages until the
previous key update has been completed. This avoids having
too many epochs in active use.</t>

<t>Due to loss and/or reordering, DTLS 1.3 implementations may receive a
record with an older epoch than the current one (the requirements
above preclude receiving a newer record).  They SHOULD attempt to
process those records with that epoch (see Section 4.2.2 of <xref target="RFC9147"/>
for information on determining the correct epoch) but MAY opt to discard
such out-of-epoch records.</t>

<t>Due to the possibility of a response message of an initial ExtendedKeyUpdate
being lost and thereby preventing the sender of the ExtendedKeyUpdate from
updating its keying material, receivers MUST retain the pre-update keying material
until receipt and successful decryption of a message using the new
keys.</t>

</section>
</section>
<section anchor="key_update"><name>Updating Traffic Secrets</name>

<t>Once the handshake is complete, it is possible for either side to
update its sending traffic keys using the ExtendedKeyUpdate handshake
message. The next generation of traffic keys is
computed by generating client_/server_application_traffic_secret_N+1
from client_/server_application_traffic_secret_N as described in this
section and then re-deriving the traffic keys, as described in
Section 7.3 of <xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<t>There are three changes to the application_traffic_secret computation
described in <xref target="I-D.ietf-tls-rfc8446bis"/>, namely</t>

<t><list style="symbols">
  <t>The application_traffic_secret_N is not used as an secret as it
may be already exfiltrated by the attacker.</t>
  <t>the label is adjusted to distinguish it from the classic KeyUpdate
message, and</t>
  <t>the Diffie-Hellman derived shared secret, as 'dh-secret', is used
as input to the HKDF-Expand-Label() function to produce the value sk.
sk is subsequently included as a secret value in the computation of
the application_traffic_secret_N+1, making the next generation
traffic key of the application traffic secret dependent on the
DH-derived value.</t>
</list></t>

<t>The next-generation application_traffic_secret is computed as follows:</t>

<figure><artwork><![CDATA[
sk = HKDF-Extract(0, dh-secret)

application_traffic_secret_N+1 =
    Derive-Secret(sk,"traffic upd 2",
                  application_traffic_secret_N)
]]></artwork></figure>

<t>The next generation of traffic keys is computed using the HKDF, as
defined in <xref target="RFC5869"/>, and its two components, HKDF-Extract and
HKDF-Expand, as recommended in Appendix F.1.1 of
<xref target="I-D.ietf-tls-rfc8446bis"/>.</t>

<t>Once client_/server_application_traffic_secret_N+1 and its associated
traffic keys have been computed, implementations SHOULD delete
client_/server_application_traffic_secret_N and its associated
traffic keys.</t>

<t>If a hybrid key exchange, based on <xref target="I-D.ietf-tls-hybrid-design"/>, is used then the two shared</t>

<t>secrets concatenated together serve as input to</t>

<t>the HKDF-Extract function to produce the value sk.</t>

</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t><xref target="RFC9325"/> provides a good summary of what (perfect) forward secrecy
is and how it relates to the TLS protocol. In summary, it says:</t>

<t>"Forward secrecy (also called "perfect forward secrecy" or "PFS") is a
defense against an attacker who records encrypted conversations where
the session keys are only encrypted with the communicating parties'
long-term keys. Should the attacker be able to obtain these long-term
keys at some point later in time, the session keys and thus the entire
conversation could be decrypted."</t>

<t>Appendix F of <xref target="I-D.ietf-tls-rfc8446bis"/> goes into details of
explaining the security properties of the TLS 1.3 protocol and notes
"... forward secrecy without rerunning (EC)DHE does not stop an attacker
from doing static key exfiltration." It concludes with a recommendation
by saying: "Frequently rerunning (EC)DHE forces an attacker to do dynamic
key exfiltration (or content exfiltration)." (The term key exfiltration
is defined in <xref target="RFC7624"/>.)</t>

<t>This specification re-uses public key encryption to update application
traffic secrets in both direction. Unlike the classic Key Update message
defined in  <xref target="I-D.ietf-tls-rfc8446bis"/>, the key update procedure requires
to messages.</t>

</section>
<section anchor="iana-considerations"><name>IANA Considerations</name>

<t>IANA is requested to add the following entry to the "TLS Flags" extension
registry defined in <xref target="I-D.ietf-tls-tlsflags"/>:</t>

<t><list style="symbols">
  <t>Value: TBD1</t>
  <t>Flag Name: extended_key_update</t>
  <t>Messages: CH, EE</t>
  <t>Recommended: Y</t>
  <t>Reference: [This document]</t>
</list></t>

<t>IANA is requested to add the following entry to the
"TLS HandshakeType" <xref target="TLS-Ext-Registry"/> registry:</t>

<t><list style="symbols">
  <t>Value: TBD2</t>
  <t>Description: extended_key_update</t>
  <t>DTLS-OK: Y</t>
  <t>Reference: [This document]</t>
  <t>Comment:</t>
</list></t>

</section>


  </middle>

  <back>


    <references title='Normative References' anchor="sec-normative-references">



<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="S. Bradner" initials="S." surname="Bradner"/>
    <date month="March" year="1997"/>
    <abstract>
      <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>


<reference anchor="I-D.ietf-tls-rfc8446bis">
   <front>
      <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
      <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
         <organization>Windy Hill Systems, LLC</organization>
      </author>
      <date day="7" month="July" year="2023"/>
      <abstract>
	 <t>   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

   This document updates RFCs 5705, 6066, 7627, and 8422 and obsoletes
   RFCs 5077, 5246, 6961, and 8446.  This document also specifies new
   requirements for TLS 1.2 implementations.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-rfc8446bis-09"/>
   
</reference>


<reference anchor="I-D.ietf-tls-tlsflags">
   <front>
      <title>A Flags Extension for TLS 1.3</title>
      <author fullname="Yoav Nir" initials="Y." surname="Nir">
         <organization>Dell Technologies</organization>
      </author>
      <date day="23" month="July" year="2023"/>
      <abstract>
	 <t>   A number of extensions are proposed in the TLS working group that
   carry no interesting information except the 1-bit indication that a
   certain optional feature is supported.  Such extensions take 4 octets
   each.  This document defines a flags extension that can provide such
   indications at an average marginal cost of 1 bit each.  More
   precisely, it provides as many flag extensions as needed at 4 + the
   order of the last set bit divided by 8.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-tlsflags-12"/>
   
</reference>

<reference anchor="RFC9147">
  <front>
    <title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>
    <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
    <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
    <author fullname="N. Modadugu" initials="N." surname="Modadugu"/>
    <date month="April" year="2022"/>
    <abstract>
      <t>This document specifies version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
      <t>The DTLS 1.3 protocol is based on the Transport Layer Security (TLS) 1.3 protocol and provides equivalent security guarantees with the exception of order protection / non-replayability. Datagram semantics of the underlying transport are preserved by the DTLS protocol.</t>
      <t>This document obsoletes RFC 6347.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9147"/>
  <seriesInfo name="DOI" value="10.17487/RFC9147"/>
</reference>

<reference anchor="RFC5869">
  <front>
    <title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
    <author fullname="H. Krawczyk" initials="H." surname="Krawczyk"/>
    <author fullname="P. Eronen" initials="P." surname="Eronen"/>
    <date month="May" year="2010"/>
    <abstract>
      <t>This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications. The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions. This document is not an Internet Standards Track specification; it is published for informational purposes.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="5869"/>
  <seriesInfo name="DOI" value="10.17487/RFC5869"/>
</reference>




    </references>

    <references title='Informative References' anchor="sec-informative-references">



<reference anchor="RFC9325">
  <front>
    <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
    <author fullname="Y. Sheffer" initials="Y." surname="Sheffer"/>
    <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre"/>
    <author fullname="T. Fossati" initials="T." surname="Fossati"/>
    <date month="November" year="2022"/>
    <abstract>
      <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are used to protect data exchanged over a wide range of application protocols and can also form the basis for secure transport protocols. Over the years, the industry has witnessed several serious attacks on TLS and DTLS, including attacks on the most commonly used cipher suites and their modes of operation. This document provides the latest recommendations for ensuring the security of deployed services that use TLS and DTLS. These recommendations are applicable to the majority of use cases.</t>
      <t>RFC 7525, an earlier version of the TLS recommendations, was published when the industry was transitioning to TLS 1.2. Years later, this transition is largely complete, and TLS 1.3 is widely available. This document updates the guidance given the new environment and obsoletes RFC 7525. In addition, this document updates RFCs 5288 and 6066 in view of recent attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="195"/>
  <seriesInfo name="RFC" value="9325"/>
  <seriesInfo name="DOI" value="10.17487/RFC9325"/>
</reference>

<reference anchor="RFC7624">
  <front>
    <title>Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</title>
    <author fullname="R. Barnes" initials="R." surname="Barnes"/>
    <author fullname="B. Schneier" initials="B." surname="Schneier"/>
    <author fullname="C. Jennings" initials="C." surname="Jennings"/>
    <author fullname="T. Hardie" initials="T." surname="Hardie"/>
    <author fullname="B. Trammell" initials="B." surname="Trammell"/>
    <author fullname="C. Huitema" initials="C." surname="Huitema"/>
    <author fullname="D. Borkmann" initials="D." surname="Borkmann"/>
    <date month="August" year="2015"/>
    <abstract>
      <t>Since the initial revelations of pervasive surveillance in 2013, several classes of attacks on Internet communications have been discovered. In this document, we develop a threat model that describes these attacks on Internet confidentiality. We assume an attacker that is interested in undetected, indiscriminate eavesdropping. The threat model is based on published, verified attacks.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="7624"/>
  <seriesInfo name="DOI" value="10.17487/RFC7624"/>
</reference>


<reference anchor="I-D.ietf-tls-hybrid-design">
   <front>
      <title>Hybrid key exchange in TLS 1.3</title>
      <author fullname="Douglas Stebila" initials="D." surname="Stebila">
         <organization>University of Waterloo</organization>
      </author>
      <author fullname="Scott Fluhrer" initials="S." surname="Fluhrer">
         <organization>Cisco Systems</organization>
      </author>
      <author fullname="Shay Gueron" initials="S." surname="Gueron">
         <organization>University of Haifa</organization>
      </author>
      <date day="7" month="September" year="2023"/>
      <abstract>
	 <t>   Hybrid key exchange refers to using multiple key exchange algorithms
   simultaneously and combining the result with the goal of providing
   security even if all but one of the component algorithms is broken.
   It is motivated by transition to post-quantum cryptography.  This
   document provides a construction for hybrid key exchange in the
   Transport Layer Security (TLS) protocol version 1.3.

   Discussion of this work is encouraged to happen on the TLS IETF
   mailing list tls@ietf.org or on the GitHub repository which contains
   the draft: https://github.com/dstebila/draft-ietf-tls-hybrid-design.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-tls-hybrid-design-09"/>
   
</reference>


<reference anchor="ANSSI-DAT-NT-003" target="https://www.ssi.gouv.fr/uploads/2015/09/NT_IPsec_EN.pdf">
  <front>
    <title>Recommendations for securing networks with IPsec, Technical Report</title>
    <author >
      <organization>ANSSI</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="TLS-Ext-Registry" target="https://www.iana.org/assignments/tls-extensiontype-values">
  <front>
    <title>Transport Layer Security (TLS) Extensions</title>
    <author >
      <organization>IANA</organization>
    </author>
    <date year="2023" month="November"/>
  </front>
</reference>


    </references>


<?line 483?>

<section anchor="acknowledgments"><name>Acknowledgments</name>

<t>We would like to thank the members of the "TSVWG DTLS for SCTP
Requirements Design Team" for their discussion. The members, in
no particular order, are:</t>

<t><list style="symbols">
  <t>Marcelo Ricardo Leitner</t>
  <t>Zaheduzzaman Sarker</t>
  <t>Magnus Westerlund</t>
  <t>John Mattsson</t>
  <t>Claudio Porfiri</t>
  <t>Xin Long</t>
  <t>Michael Tuxen</t>
  <t>Hannes Tschofenig</t>
  <t>K Tirumaleswar Reddy</t>
  <t>Bertrand Rault</t>
</list></t>

<t>Additionally, we would like to thank the chairs of the
Transport and Services Working Group (tsvwg) Gorry Fairhurst and
Marten Seemann as well as the responsible area director Martin Duke.</t>

<t>Finally, we would like to thank Martin Thomson for his review of
this specification.</t>

</section>
<section anchor="alternative-designs-considered"><name>Alternative Designs Considered</name>

<t>The design presented in this document utilizes an ephemeral Diffie-Hellman,
which requires a full roundtrip since both parties need to exchange their
ephemeral public keys. Since the Key Update design defined in TLS 1.3
utilizes a one-shot message, this new extension changes the behavior and
is less efficient.</t>

<t>During the design of this specification two alternatives have been considered,
which retained the original design spirit of the one-shot Key Update message
by utilizing an ephemeral-static Diffie-Hellman. The static public key thereby
represents a previously exchanged Diffie-Hellman public key. For the first 
Key Update message sent, this public key would thereby be the Diffie-Hellman
public key from the key share in the initial ClientHello/ServerHello handshake
message exchange. We considered two designs, one using a classical ephemeral-static
Diffie-Hellman and a second design based on the Hybrid Public Key Encryption (HPKE)
specification. HPKE is already used in the encrypted ClientHello and may
therefore be present already in TLS stacks.</t>

<t>Ultimately, we decided against such an approach since it requires an implementation
to keep their Diffie-Hellman public and private keys somewhere in memory (even
though it is possible to utilize available hardware security modules to store
the private key). The design in this document allows an implementation to discard
this ephemeral Diffie-Hellman key pair immediately after the key update procedure
has been finalized.</t>

</section>


  </back>

<!-- ##markdown-source:
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
T8+62tMEFQd+I40I9r9EA2NnZVcAAA==

-->

</rfc>

